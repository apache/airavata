#
# Autogenerated by Thrift Compiler (1.0.0-dev)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
#  options string: py
#

from thrift.Thrift import TType, TMessageType, TFrozenDict, TException, TApplicationException
from thrift.protocol.TProtocol import TProtocolException
from thrift.TRecursive import fix_spec

import sys
import logging
from .ttypes import *
from thrift.Thrift import TProcessor
from thrift.transport import TTransport
all_structs = []


class Iface(object):
    def createAllocationRequest(self, allocDetail):
        """
        <p>API method to create new allocation requests</p>

        Parameters:
         - allocDetail
        """
        pass

    def deleteAllocationRequest(self, projectId):
        """
        <p>API method to delete allocation request</p>

        Parameters:
         - projectId
        """
        pass

    def getAllocationRequest(self, projectId):
        """
        <p>API method to get an allocation Request</p>

        Parameters:
         - projectId
        """
        pass

    def updateAllocationRequest(self, allocDetail):
        """
        <p>API method to update an allocation Request</p>

        Parameters:
         - allocDetail
        """
        pass

    def getAllocationRequestStatus(self, projectId):
        """
        <p>API method to get an allocation Request status</p>

        Parameters:
         - projectId
        """
        pass

    def getAllocationRequestUserEmail(self, userName):
        """
        <p>API method to get an allocation Request PI email</p>

        Parameters:
         - userName
        """
        pass

    def getAllocationManagerAdminEmail(self, userType):
        """
        <p>API method to get an allocation Request Admin email</p>

        Parameters:
         - userType
        """
        pass

    def getAllocationRequestUserName(self, projectId):
        """
        <p>API method to get an allocation Request PI</p>

        Parameters:
         - projectId
        """
        pass

    def getAllRequestsForAdmin(self, userName):
        """
        <p>API method to get all requests for admin</p>

        Parameters:
         - userName
        """
        pass

    def assignReviewers(self, projectId, reviewerId, adminId):
        """
        <p>API method to assign reviewers</p>

        Parameters:
         - projectId
         - reviewerId
         - adminId
        """
        pass

    def updateRequestByReviewer(self, reviewerAllocationDetail):
        """
        <p>API method to update request submitted by reviewer</p>

        Parameters:
         - reviewerAllocationDetail
        """
        pass

    def isAdmin(self, userName):
        """
        <p>API method to check if the logged in user is an Admin</p>

        Parameters:
         - userName
        """
        pass

    def isReviewer(self, userName):
        """
        <p>API method to check if the logged in user is a Reviewer</p>

        Parameters:
         - userName
        """
        pass

    def getAllRequestsForReviewers(self, userName):
        """
        <p>API method to get all requests assigned to the reviewers</p>

        Parameters:
         - userName
        """
        pass

    def getUserDetails(self, userName):
        """
        <p>API method to get a user details</p>

        Parameters:
         - userName
        """
        pass

    def getAllReviewsForARequest(self, projectId):
        """
        <p>API method to get all the reviews for a request</p>

        Parameters:
         - projectId
        """
        pass

    def getAllReviewers(self):
        """
        <p>API method to get all reviewers</p>
        """
        pass

    def getAllUnassignedReviewersForRequest(self, projectId):
        """
        <p>API method to get all unassigned reviewers for a request</p>

        Parameters:
         - projectId
        """
        pass

    def approveRequest(self, projectId, adminId, startDate, endDate, awardAllocation):
        """
        <p>API method to approve a request</p>

        Parameters:
         - projectId
         - adminId
         - startDate
         - endDate
         - awardAllocation
        """
        pass

    def rejectRequest(self, projectId, adminId):
        """
        <p>API method to reject a request</p>

        Parameters:
         - projectId
         - adminId
        """
        pass

    def createUser(self, userDetail):
        """
        <p>API method to create a new user</p>

        Parameters:
         - userDetail
        """
        pass


class Client(Iface):
    def __init__(self, iprot, oprot=None):
        self._iprot = self._oprot = iprot
        if oprot is not None:
            self._oprot = oprot
        self._seqid = 0

    def createAllocationRequest(self, allocDetail):
        """
        <p>API method to create new allocation requests</p>

        Parameters:
         - allocDetail
        """
        self.send_createAllocationRequest(allocDetail)
        return self.recv_createAllocationRequest()

    def send_createAllocationRequest(self, allocDetail):
        self._oprot.writeMessageBegin('createAllocationRequest', TMessageType.CALL, self._seqid)
        args = createAllocationRequest_args()
        args.allocDetail = allocDetail
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_createAllocationRequest(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = createAllocationRequest_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "createAllocationRequest failed: unknown result")

    def deleteAllocationRequest(self, projectId):
        """
        <p>API method to delete allocation request</p>

        Parameters:
         - projectId
        """
        self.send_deleteAllocationRequest(projectId)
        return self.recv_deleteAllocationRequest()

    def send_deleteAllocationRequest(self, projectId):
        self._oprot.writeMessageBegin('deleteAllocationRequest', TMessageType.CALL, self._seqid)
        args = deleteAllocationRequest_args()
        args.projectId = projectId
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_deleteAllocationRequest(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = deleteAllocationRequest_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "deleteAllocationRequest failed: unknown result")

    def getAllocationRequest(self, projectId):
        """
        <p>API method to get an allocation Request</p>

        Parameters:
         - projectId
        """
        self.send_getAllocationRequest(projectId)
        return self.recv_getAllocationRequest()

    def send_getAllocationRequest(self, projectId):
        self._oprot.writeMessageBegin('getAllocationRequest', TMessageType.CALL, self._seqid)
        args = getAllocationRequest_args()
        args.projectId = projectId
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getAllocationRequest(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getAllocationRequest_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "getAllocationRequest failed: unknown result")

    def updateAllocationRequest(self, allocDetail):
        """
        <p>API method to update an allocation Request</p>

        Parameters:
         - allocDetail
        """
        self.send_updateAllocationRequest(allocDetail)
        return self.recv_updateAllocationRequest()

    def send_updateAllocationRequest(self, allocDetail):
        self._oprot.writeMessageBegin('updateAllocationRequest', TMessageType.CALL, self._seqid)
        args = updateAllocationRequest_args()
        args.allocDetail = allocDetail
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_updateAllocationRequest(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = updateAllocationRequest_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "updateAllocationRequest failed: unknown result")

    def getAllocationRequestStatus(self, projectId):
        """
        <p>API method to get an allocation Request status</p>

        Parameters:
         - projectId
        """
        self.send_getAllocationRequestStatus(projectId)
        return self.recv_getAllocationRequestStatus()

    def send_getAllocationRequestStatus(self, projectId):
        self._oprot.writeMessageBegin('getAllocationRequestStatus', TMessageType.CALL, self._seqid)
        args = getAllocationRequestStatus_args()
        args.projectId = projectId
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getAllocationRequestStatus(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getAllocationRequestStatus_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "getAllocationRequestStatus failed: unknown result")

    def getAllocationRequestUserEmail(self, userName):
        """
        <p>API method to get an allocation Request PI email</p>

        Parameters:
         - userName
        """
        self.send_getAllocationRequestUserEmail(userName)
        return self.recv_getAllocationRequestUserEmail()

    def send_getAllocationRequestUserEmail(self, userName):
        self._oprot.writeMessageBegin('getAllocationRequestUserEmail', TMessageType.CALL, self._seqid)
        args = getAllocationRequestUserEmail_args()
        args.userName = userName
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getAllocationRequestUserEmail(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getAllocationRequestUserEmail_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "getAllocationRequestUserEmail failed: unknown result")

    def getAllocationManagerAdminEmail(self, userType):
        """
        <p>API method to get an allocation Request Admin email</p>

        Parameters:
         - userType
        """
        self.send_getAllocationManagerAdminEmail(userType)
        return self.recv_getAllocationManagerAdminEmail()

    def send_getAllocationManagerAdminEmail(self, userType):
        self._oprot.writeMessageBegin('getAllocationManagerAdminEmail', TMessageType.CALL, self._seqid)
        args = getAllocationManagerAdminEmail_args()
        args.userType = userType
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getAllocationManagerAdminEmail(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getAllocationManagerAdminEmail_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "getAllocationManagerAdminEmail failed: unknown result")

    def getAllocationRequestUserName(self, projectId):
        """
        <p>API method to get an allocation Request PI</p>

        Parameters:
         - projectId
        """
        self.send_getAllocationRequestUserName(projectId)
        return self.recv_getAllocationRequestUserName()

    def send_getAllocationRequestUserName(self, projectId):
        self._oprot.writeMessageBegin('getAllocationRequestUserName', TMessageType.CALL, self._seqid)
        args = getAllocationRequestUserName_args()
        args.projectId = projectId
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getAllocationRequestUserName(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getAllocationRequestUserName_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "getAllocationRequestUserName failed: unknown result")

    def getAllRequestsForAdmin(self, userName):
        """
        <p>API method to get all requests for admin</p>

        Parameters:
         - userName
        """
        self.send_getAllRequestsForAdmin(userName)
        return self.recv_getAllRequestsForAdmin()

    def send_getAllRequestsForAdmin(self, userName):
        self._oprot.writeMessageBegin('getAllRequestsForAdmin', TMessageType.CALL, self._seqid)
        args = getAllRequestsForAdmin_args()
        args.userName = userName
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getAllRequestsForAdmin(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getAllRequestsForAdmin_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "getAllRequestsForAdmin failed: unknown result")

    def assignReviewers(self, projectId, reviewerId, adminId):
        """
        <p>API method to assign reviewers</p>

        Parameters:
         - projectId
         - reviewerId
         - adminId
        """
        self.send_assignReviewers(projectId, reviewerId, adminId)
        return self.recv_assignReviewers()

    def send_assignReviewers(self, projectId, reviewerId, adminId):
        self._oprot.writeMessageBegin('assignReviewers', TMessageType.CALL, self._seqid)
        args = assignReviewers_args()
        args.projectId = projectId
        args.reviewerId = reviewerId
        args.adminId = adminId
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_assignReviewers(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = assignReviewers_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "assignReviewers failed: unknown result")

    def updateRequestByReviewer(self, reviewerAllocationDetail):
        """
        <p>API method to update request submitted by reviewer</p>

        Parameters:
         - reviewerAllocationDetail
        """
        self.send_updateRequestByReviewer(reviewerAllocationDetail)
        return self.recv_updateRequestByReviewer()

    def send_updateRequestByReviewer(self, reviewerAllocationDetail):
        self._oprot.writeMessageBegin('updateRequestByReviewer', TMessageType.CALL, self._seqid)
        args = updateRequestByReviewer_args()
        args.reviewerAllocationDetail = reviewerAllocationDetail
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_updateRequestByReviewer(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = updateRequestByReviewer_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "updateRequestByReviewer failed: unknown result")

    def isAdmin(self, userName):
        """
        <p>API method to check if the logged in user is an Admin</p>

        Parameters:
         - userName
        """
        self.send_isAdmin(userName)
        return self.recv_isAdmin()

    def send_isAdmin(self, userName):
        self._oprot.writeMessageBegin('isAdmin', TMessageType.CALL, self._seqid)
        args = isAdmin_args()
        args.userName = userName
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_isAdmin(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = isAdmin_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "isAdmin failed: unknown result")

    def isReviewer(self, userName):
        """
        <p>API method to check if the logged in user is a Reviewer</p>

        Parameters:
         - userName
        """
        self.send_isReviewer(userName)
        return self.recv_isReviewer()

    def send_isReviewer(self, userName):
        self._oprot.writeMessageBegin('isReviewer', TMessageType.CALL, self._seqid)
        args = isReviewer_args()
        args.userName = userName
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_isReviewer(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = isReviewer_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "isReviewer failed: unknown result")

    def getAllRequestsForReviewers(self, userName):
        """
        <p>API method to get all requests assigned to the reviewers</p>

        Parameters:
         - userName
        """
        self.send_getAllRequestsForReviewers(userName)
        return self.recv_getAllRequestsForReviewers()

    def send_getAllRequestsForReviewers(self, userName):
        self._oprot.writeMessageBegin('getAllRequestsForReviewers', TMessageType.CALL, self._seqid)
        args = getAllRequestsForReviewers_args()
        args.userName = userName
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getAllRequestsForReviewers(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getAllRequestsForReviewers_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "getAllRequestsForReviewers failed: unknown result")

    def getUserDetails(self, userName):
        """
        <p>API method to get a user details</p>

        Parameters:
         - userName
        """
        self.send_getUserDetails(userName)
        return self.recv_getUserDetails()

    def send_getUserDetails(self, userName):
        self._oprot.writeMessageBegin('getUserDetails', TMessageType.CALL, self._seqid)
        args = getUserDetails_args()
        args.userName = userName
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getUserDetails(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getUserDetails_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "getUserDetails failed: unknown result")

    def getAllReviewsForARequest(self, projectId):
        """
        <p>API method to get all the reviews for a request</p>

        Parameters:
         - projectId
        """
        self.send_getAllReviewsForARequest(projectId)
        return self.recv_getAllReviewsForARequest()

    def send_getAllReviewsForARequest(self, projectId):
        self._oprot.writeMessageBegin('getAllReviewsForARequest', TMessageType.CALL, self._seqid)
        args = getAllReviewsForARequest_args()
        args.projectId = projectId
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getAllReviewsForARequest(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getAllReviewsForARequest_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "getAllReviewsForARequest failed: unknown result")

    def getAllReviewers(self):
        """
        <p>API method to get all reviewers</p>
        """
        self.send_getAllReviewers()
        return self.recv_getAllReviewers()

    def send_getAllReviewers(self):
        self._oprot.writeMessageBegin('getAllReviewers', TMessageType.CALL, self._seqid)
        args = getAllReviewers_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getAllReviewers(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getAllReviewers_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "getAllReviewers failed: unknown result")

    def getAllUnassignedReviewersForRequest(self, projectId):
        """
        <p>API method to get all unassigned reviewers for a request</p>

        Parameters:
         - projectId
        """
        self.send_getAllUnassignedReviewersForRequest(projectId)
        return self.recv_getAllUnassignedReviewersForRequest()

    def send_getAllUnassignedReviewersForRequest(self, projectId):
        self._oprot.writeMessageBegin('getAllUnassignedReviewersForRequest', TMessageType.CALL, self._seqid)
        args = getAllUnassignedReviewersForRequest_args()
        args.projectId = projectId
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getAllUnassignedReviewersForRequest(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getAllUnassignedReviewersForRequest_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "getAllUnassignedReviewersForRequest failed: unknown result")

    def approveRequest(self, projectId, adminId, startDate, endDate, awardAllocation):
        """
        <p>API method to approve a request</p>

        Parameters:
         - projectId
         - adminId
         - startDate
         - endDate
         - awardAllocation
        """
        self.send_approveRequest(projectId, adminId, startDate, endDate, awardAllocation)
        return self.recv_approveRequest()

    def send_approveRequest(self, projectId, adminId, startDate, endDate, awardAllocation):
        self._oprot.writeMessageBegin('approveRequest', TMessageType.CALL, self._seqid)
        args = approveRequest_args()
        args.projectId = projectId
        args.adminId = adminId
        args.startDate = startDate
        args.endDate = endDate
        args.awardAllocation = awardAllocation
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_approveRequest(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = approveRequest_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "approveRequest failed: unknown result")

    def rejectRequest(self, projectId, adminId):
        """
        <p>API method to reject a request</p>

        Parameters:
         - projectId
         - adminId
        """
        self.send_rejectRequest(projectId, adminId)
        return self.recv_rejectRequest()

    def send_rejectRequest(self, projectId, adminId):
        self._oprot.writeMessageBegin('rejectRequest', TMessageType.CALL, self._seqid)
        args = rejectRequest_args()
        args.projectId = projectId
        args.adminId = adminId
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_rejectRequest(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = rejectRequest_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "rejectRequest failed: unknown result")

    def createUser(self, userDetail):
        """
        <p>API method to create a new user</p>

        Parameters:
         - userDetail
        """
        self.send_createUser(userDetail)
        return self.recv_createUser()

    def send_createUser(self, userDetail):
        self._oprot.writeMessageBegin('createUser', TMessageType.CALL, self._seqid)
        args = createUser_args()
        args.userDetail = userDetail
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_createUser(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = createUser_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "createUser failed: unknown result")


class Processor(Iface, TProcessor):
    def __init__(self, handler):
        self._handler = handler
        self._processMap = {}
        self._processMap["createAllocationRequest"] = Processor.process_createAllocationRequest
        self._processMap["deleteAllocationRequest"] = Processor.process_deleteAllocationRequest
        self._processMap["getAllocationRequest"] = Processor.process_getAllocationRequest
        self._processMap["updateAllocationRequest"] = Processor.process_updateAllocationRequest
        self._processMap["getAllocationRequestStatus"] = Processor.process_getAllocationRequestStatus
        self._processMap["getAllocationRequestUserEmail"] = Processor.process_getAllocationRequestUserEmail
        self._processMap["getAllocationManagerAdminEmail"] = Processor.process_getAllocationManagerAdminEmail
        self._processMap["getAllocationRequestUserName"] = Processor.process_getAllocationRequestUserName
        self._processMap["getAllRequestsForAdmin"] = Processor.process_getAllRequestsForAdmin
        self._processMap["assignReviewers"] = Processor.process_assignReviewers
        self._processMap["updateRequestByReviewer"] = Processor.process_updateRequestByReviewer
        self._processMap["isAdmin"] = Processor.process_isAdmin
        self._processMap["isReviewer"] = Processor.process_isReviewer
        self._processMap["getAllRequestsForReviewers"] = Processor.process_getAllRequestsForReviewers
        self._processMap["getUserDetails"] = Processor.process_getUserDetails
        self._processMap["getAllReviewsForARequest"] = Processor.process_getAllReviewsForARequest
        self._processMap["getAllReviewers"] = Processor.process_getAllReviewers
        self._processMap["getAllUnassignedReviewersForRequest"] = Processor.process_getAllUnassignedReviewersForRequest
        self._processMap["approveRequest"] = Processor.process_approveRequest
        self._processMap["rejectRequest"] = Processor.process_rejectRequest
        self._processMap["createUser"] = Processor.process_createUser

    def process(self, iprot, oprot):
        (name, type, seqid) = iprot.readMessageBegin()
        if name not in self._processMap:
            iprot.skip(TType.STRUCT)
            iprot.readMessageEnd()
            x = TApplicationException(TApplicationException.UNKNOWN_METHOD, 'Unknown function %s' % (name))
            oprot.writeMessageBegin(name, TMessageType.EXCEPTION, seqid)
            x.write(oprot)
            oprot.writeMessageEnd()
            oprot.trans.flush()
            return
        else:
            self._processMap[name](self, seqid, iprot, oprot)
        return True

    def process_createAllocationRequest(self, seqid, iprot, oprot):
        args = createAllocationRequest_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = createAllocationRequest_result()
        try:
            result.success = self._handler.createAllocationRequest(args.allocDetail)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("createAllocationRequest", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_deleteAllocationRequest(self, seqid, iprot, oprot):
        args = deleteAllocationRequest_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = deleteAllocationRequest_result()
        try:
            result.success = self._handler.deleteAllocationRequest(args.projectId)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("deleteAllocationRequest", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getAllocationRequest(self, seqid, iprot, oprot):
        args = getAllocationRequest_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getAllocationRequest_result()
        try:
            result.success = self._handler.getAllocationRequest(args.projectId)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("getAllocationRequest", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_updateAllocationRequest(self, seqid, iprot, oprot):
        args = updateAllocationRequest_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = updateAllocationRequest_result()
        try:
            result.success = self._handler.updateAllocationRequest(args.allocDetail)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("updateAllocationRequest", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getAllocationRequestStatus(self, seqid, iprot, oprot):
        args = getAllocationRequestStatus_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getAllocationRequestStatus_result()
        try:
            result.success = self._handler.getAllocationRequestStatus(args.projectId)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("getAllocationRequestStatus", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getAllocationRequestUserEmail(self, seqid, iprot, oprot):
        args = getAllocationRequestUserEmail_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getAllocationRequestUserEmail_result()
        try:
            result.success = self._handler.getAllocationRequestUserEmail(args.userName)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("getAllocationRequestUserEmail", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getAllocationManagerAdminEmail(self, seqid, iprot, oprot):
        args = getAllocationManagerAdminEmail_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getAllocationManagerAdminEmail_result()
        try:
            result.success = self._handler.getAllocationManagerAdminEmail(args.userType)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("getAllocationManagerAdminEmail", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getAllocationRequestUserName(self, seqid, iprot, oprot):
        args = getAllocationRequestUserName_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getAllocationRequestUserName_result()
        try:
            result.success = self._handler.getAllocationRequestUserName(args.projectId)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("getAllocationRequestUserName", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getAllRequestsForAdmin(self, seqid, iprot, oprot):
        args = getAllRequestsForAdmin_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getAllRequestsForAdmin_result()
        try:
            result.success = self._handler.getAllRequestsForAdmin(args.userName)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("getAllRequestsForAdmin", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_assignReviewers(self, seqid, iprot, oprot):
        args = assignReviewers_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = assignReviewers_result()
        try:
            result.success = self._handler.assignReviewers(args.projectId, args.reviewerId, args.adminId)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("assignReviewers", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_updateRequestByReviewer(self, seqid, iprot, oprot):
        args = updateRequestByReviewer_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = updateRequestByReviewer_result()
        try:
            result.success = self._handler.updateRequestByReviewer(args.reviewerAllocationDetail)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("updateRequestByReviewer", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_isAdmin(self, seqid, iprot, oprot):
        args = isAdmin_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = isAdmin_result()
        try:
            result.success = self._handler.isAdmin(args.userName)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("isAdmin", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_isReviewer(self, seqid, iprot, oprot):
        args = isReviewer_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = isReviewer_result()
        try:
            result.success = self._handler.isReviewer(args.userName)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("isReviewer", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getAllRequestsForReviewers(self, seqid, iprot, oprot):
        args = getAllRequestsForReviewers_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getAllRequestsForReviewers_result()
        try:
            result.success = self._handler.getAllRequestsForReviewers(args.userName)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("getAllRequestsForReviewers", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getUserDetails(self, seqid, iprot, oprot):
        args = getUserDetails_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getUserDetails_result()
        try:
            result.success = self._handler.getUserDetails(args.userName)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("getUserDetails", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getAllReviewsForARequest(self, seqid, iprot, oprot):
        args = getAllReviewsForARequest_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getAllReviewsForARequest_result()
        try:
            result.success = self._handler.getAllReviewsForARequest(args.projectId)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("getAllReviewsForARequest", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getAllReviewers(self, seqid, iprot, oprot):
        args = getAllReviewers_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getAllReviewers_result()
        try:
            result.success = self._handler.getAllReviewers()
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("getAllReviewers", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getAllUnassignedReviewersForRequest(self, seqid, iprot, oprot):
        args = getAllUnassignedReviewersForRequest_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getAllUnassignedReviewersForRequest_result()
        try:
            result.success = self._handler.getAllUnassignedReviewersForRequest(args.projectId)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("getAllUnassignedReviewersForRequest", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_approveRequest(self, seqid, iprot, oprot):
        args = approveRequest_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = approveRequest_result()
        try:
            result.success = self._handler.approveRequest(args.projectId, args.adminId, args.startDate, args.endDate, args.awardAllocation)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("approveRequest", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_rejectRequest(self, seqid, iprot, oprot):
        args = rejectRequest_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = rejectRequest_result()
        try:
            result.success = self._handler.rejectRequest(args.projectId, args.adminId)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("rejectRequest", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_createUser(self, seqid, iprot, oprot):
        args = createUser_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = createUser_result()
        try:
            result.success = self._handler.createUser(args.userDetail)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("createUser", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

# HELPER FUNCTIONS AND STRUCTURES


class createAllocationRequest_args(object):
    """
    Attributes:
     - allocDetail
    """


    def __init__(self, allocDetail=None,):
        self.allocDetail = allocDetail

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.allocDetail = allocation_manager_models.ttypes.UserAllocationDetail()
                    self.allocDetail.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('createAllocationRequest_args')
        if self.allocDetail is not None:
            oprot.writeFieldBegin('allocDetail', TType.STRUCT, 1)
            self.allocDetail.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.allocDetail is None:
            raise TProtocolException(message='Required field allocDetail is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(createAllocationRequest_args)
createAllocationRequest_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'allocDetail', [allocation_manager_models.ttypes.UserAllocationDetail, None], None, ),  # 1
)


class createAllocationRequest_result(object):
    """
    Attributes:
     - success
    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRING:
                    self.success = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('createAllocationRequest_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRING, 0)
            oprot.writeString(self.success.encode('utf-8') if sys.version_info[0] == 2 else self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(createAllocationRequest_result)
createAllocationRequest_result.thrift_spec = (
    (0, TType.STRING, 'success', 'UTF8', None, ),  # 0
)


class deleteAllocationRequest_args(object):
    """
    Attributes:
     - projectId
    """


    def __init__(self, projectId=None,):
        self.projectId = projectId

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.projectId = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('deleteAllocationRequest_args')
        if self.projectId is not None:
            oprot.writeFieldBegin('projectId', TType.STRING, 1)
            oprot.writeString(self.projectId.encode('utf-8') if sys.version_info[0] == 2 else self.projectId)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.projectId is None:
            raise TProtocolException(message='Required field projectId is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(deleteAllocationRequest_args)
deleteAllocationRequest_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'projectId', 'UTF8', None, ),  # 1
)


class deleteAllocationRequest_result(object):
    """
    Attributes:
     - success
    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.BOOL:
                    self.success = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('deleteAllocationRequest_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.BOOL, 0)
            oprot.writeBool(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(deleteAllocationRequest_result)
deleteAllocationRequest_result.thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ),  # 0
)


class getAllocationRequest_args(object):
    """
    Attributes:
     - projectId
    """


    def __init__(self, projectId=None,):
        self.projectId = projectId

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.projectId = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getAllocationRequest_args')
        if self.projectId is not None:
            oprot.writeFieldBegin('projectId', TType.STRING, 1)
            oprot.writeString(self.projectId.encode('utf-8') if sys.version_info[0] == 2 else self.projectId)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.projectId is None:
            raise TProtocolException(message='Required field projectId is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getAllocationRequest_args)
getAllocationRequest_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'projectId', 'UTF8', None, ),  # 1
)


class getAllocationRequest_result(object):
    """
    Attributes:
     - success
    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = allocation_manager_models.ttypes.UserAllocationDetail()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getAllocationRequest_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getAllocationRequest_result)
getAllocationRequest_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [allocation_manager_models.ttypes.UserAllocationDetail, None], None, ),  # 0
)


class updateAllocationRequest_args(object):
    """
    Attributes:
     - allocDetail
    """


    def __init__(self, allocDetail=None,):
        self.allocDetail = allocDetail

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.allocDetail = allocation_manager_models.ttypes.UserAllocationDetail()
                    self.allocDetail.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('updateAllocationRequest_args')
        if self.allocDetail is not None:
            oprot.writeFieldBegin('allocDetail', TType.STRUCT, 1)
            self.allocDetail.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.allocDetail is None:
            raise TProtocolException(message='Required field allocDetail is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(updateAllocationRequest_args)
updateAllocationRequest_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'allocDetail', [allocation_manager_models.ttypes.UserAllocationDetail, None], None, ),  # 1
)


class updateAllocationRequest_result(object):
    """
    Attributes:
     - success
    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.BOOL:
                    self.success = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('updateAllocationRequest_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.BOOL, 0)
            oprot.writeBool(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(updateAllocationRequest_result)
updateAllocationRequest_result.thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ),  # 0
)


class getAllocationRequestStatus_args(object):
    """
    Attributes:
     - projectId
    """


    def __init__(self, projectId=None,):
        self.projectId = projectId

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.projectId = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getAllocationRequestStatus_args')
        if self.projectId is not None:
            oprot.writeFieldBegin('projectId', TType.STRING, 1)
            oprot.writeString(self.projectId.encode('utf-8') if sys.version_info[0] == 2 else self.projectId)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.projectId is None:
            raise TProtocolException(message='Required field projectId is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getAllocationRequestStatus_args)
getAllocationRequestStatus_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'projectId', 'UTF8', None, ),  # 1
)


class getAllocationRequestStatus_result(object):
    """
    Attributes:
     - success
    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRING:
                    self.success = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getAllocationRequestStatus_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRING, 0)
            oprot.writeString(self.success.encode('utf-8') if sys.version_info[0] == 2 else self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getAllocationRequestStatus_result)
getAllocationRequestStatus_result.thrift_spec = (
    (0, TType.STRING, 'success', 'UTF8', None, ),  # 0
)


class getAllocationRequestUserEmail_args(object):
    """
    Attributes:
     - userName
    """


    def __init__(self, userName=None,):
        self.userName = userName

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.userName = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getAllocationRequestUserEmail_args')
        if self.userName is not None:
            oprot.writeFieldBegin('userName', TType.STRING, 1)
            oprot.writeString(self.userName.encode('utf-8') if sys.version_info[0] == 2 else self.userName)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.userName is None:
            raise TProtocolException(message='Required field userName is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getAllocationRequestUserEmail_args)
getAllocationRequestUserEmail_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'userName', 'UTF8', None, ),  # 1
)


class getAllocationRequestUserEmail_result(object):
    """
    Attributes:
     - success
    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRING:
                    self.success = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getAllocationRequestUserEmail_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRING, 0)
            oprot.writeString(self.success.encode('utf-8') if sys.version_info[0] == 2 else self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getAllocationRequestUserEmail_result)
getAllocationRequestUserEmail_result.thrift_spec = (
    (0, TType.STRING, 'success', 'UTF8', None, ),  # 0
)


class getAllocationManagerAdminEmail_args(object):
    """
    Attributes:
     - userType
    """


    def __init__(self, userType=None,):
        self.userType = userType

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.userType = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getAllocationManagerAdminEmail_args')
        if self.userType is not None:
            oprot.writeFieldBegin('userType', TType.STRING, 1)
            oprot.writeString(self.userType.encode('utf-8') if sys.version_info[0] == 2 else self.userType)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.userType is None:
            raise TProtocolException(message='Required field userType is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getAllocationManagerAdminEmail_args)
getAllocationManagerAdminEmail_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'userType', 'UTF8', None, ),  # 1
)


class getAllocationManagerAdminEmail_result(object):
    """
    Attributes:
     - success
    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRING:
                    self.success = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getAllocationManagerAdminEmail_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRING, 0)
            oprot.writeString(self.success.encode('utf-8') if sys.version_info[0] == 2 else self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getAllocationManagerAdminEmail_result)
getAllocationManagerAdminEmail_result.thrift_spec = (
    (0, TType.STRING, 'success', 'UTF8', None, ),  # 0
)


class getAllocationRequestUserName_args(object):
    """
    Attributes:
     - projectId
    """


    def __init__(self, projectId=None,):
        self.projectId = projectId

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.projectId = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getAllocationRequestUserName_args')
        if self.projectId is not None:
            oprot.writeFieldBegin('projectId', TType.STRING, 1)
            oprot.writeString(self.projectId.encode('utf-8') if sys.version_info[0] == 2 else self.projectId)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.projectId is None:
            raise TProtocolException(message='Required field projectId is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getAllocationRequestUserName_args)
getAllocationRequestUserName_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'projectId', 'UTF8', None, ),  # 1
)


class getAllocationRequestUserName_result(object):
    """
    Attributes:
     - success
    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRING:
                    self.success = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getAllocationRequestUserName_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRING, 0)
            oprot.writeString(self.success.encode('utf-8') if sys.version_info[0] == 2 else self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getAllocationRequestUserName_result)
getAllocationRequestUserName_result.thrift_spec = (
    (0, TType.STRING, 'success', 'UTF8', None, ),  # 0
)


class getAllRequestsForAdmin_args(object):
    """
    Attributes:
     - userName
    """


    def __init__(self, userName=None,):
        self.userName = userName

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.userName = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getAllRequestsForAdmin_args')
        if self.userName is not None:
            oprot.writeFieldBegin('userName', TType.STRING, 1)
            oprot.writeString(self.userName.encode('utf-8') if sys.version_info[0] == 2 else self.userName)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.userName is None:
            raise TProtocolException(message='Required field userName is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getAllRequestsForAdmin_args)
getAllRequestsForAdmin_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'userName', 'UTF8', None, ),  # 1
)


class getAllRequestsForAdmin_result(object):
    """
    Attributes:
     - success
    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype3, _size0) = iprot.readListBegin()
                    for _i4 in range(_size0):
                        _elem5 = allocation_manager_models.ttypes.UserAllocationDetail()
                        _elem5.read(iprot)
                        self.success.append(_elem5)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getAllRequestsForAdmin_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter6 in self.success:
                iter6.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getAllRequestsForAdmin_result)
getAllRequestsForAdmin_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT, [allocation_manager_models.ttypes.UserAllocationDetail, None], False), None, ),  # 0
)


class assignReviewers_args(object):
    """
    Attributes:
     - projectId
     - reviewerId
     - adminId
    """


    def __init__(self, projectId=None, reviewerId=None, adminId=None,):
        self.projectId = projectId
        self.reviewerId = reviewerId
        self.adminId = adminId

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.projectId = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.reviewerId = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.adminId = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('assignReviewers_args')
        if self.projectId is not None:
            oprot.writeFieldBegin('projectId', TType.STRING, 1)
            oprot.writeString(self.projectId.encode('utf-8') if sys.version_info[0] == 2 else self.projectId)
            oprot.writeFieldEnd()
        if self.reviewerId is not None:
            oprot.writeFieldBegin('reviewerId', TType.STRING, 2)
            oprot.writeString(self.reviewerId.encode('utf-8') if sys.version_info[0] == 2 else self.reviewerId)
            oprot.writeFieldEnd()
        if self.adminId is not None:
            oprot.writeFieldBegin('adminId', TType.STRING, 3)
            oprot.writeString(self.adminId.encode('utf-8') if sys.version_info[0] == 2 else self.adminId)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.projectId is None:
            raise TProtocolException(message='Required field projectId is unset!')
        if self.reviewerId is None:
            raise TProtocolException(message='Required field reviewerId is unset!')
        if self.adminId is None:
            raise TProtocolException(message='Required field adminId is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(assignReviewers_args)
assignReviewers_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'projectId', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'reviewerId', 'UTF8', None, ),  # 2
    (3, TType.STRING, 'adminId', 'UTF8', None, ),  # 3
)


class assignReviewers_result(object):
    """
    Attributes:
     - success
    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.BOOL:
                    self.success = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('assignReviewers_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.BOOL, 0)
            oprot.writeBool(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(assignReviewers_result)
assignReviewers_result.thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ),  # 0
)


class updateRequestByReviewer_args(object):
    """
    Attributes:
     - reviewerAllocationDetail
    """


    def __init__(self, reviewerAllocationDetail=None,):
        self.reviewerAllocationDetail = reviewerAllocationDetail

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.reviewerAllocationDetail = allocation_manager_models.ttypes.ReviewerAllocationDetail()
                    self.reviewerAllocationDetail.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('updateRequestByReviewer_args')
        if self.reviewerAllocationDetail is not None:
            oprot.writeFieldBegin('reviewerAllocationDetail', TType.STRUCT, 1)
            self.reviewerAllocationDetail.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.reviewerAllocationDetail is None:
            raise TProtocolException(message='Required field reviewerAllocationDetail is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(updateRequestByReviewer_args)
updateRequestByReviewer_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'reviewerAllocationDetail', [allocation_manager_models.ttypes.ReviewerAllocationDetail, None], None, ),  # 1
)


class updateRequestByReviewer_result(object):
    """
    Attributes:
     - success
    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.BOOL:
                    self.success = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('updateRequestByReviewer_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.BOOL, 0)
            oprot.writeBool(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(updateRequestByReviewer_result)
updateRequestByReviewer_result.thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ),  # 0
)


class isAdmin_args(object):
    """
    Attributes:
     - userName
    """


    def __init__(self, userName=None,):
        self.userName = userName

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.userName = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('isAdmin_args')
        if self.userName is not None:
            oprot.writeFieldBegin('userName', TType.STRING, 1)
            oprot.writeString(self.userName.encode('utf-8') if sys.version_info[0] == 2 else self.userName)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.userName is None:
            raise TProtocolException(message='Required field userName is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(isAdmin_args)
isAdmin_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'userName', 'UTF8', None, ),  # 1
)


class isAdmin_result(object):
    """
    Attributes:
     - success
    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.BOOL:
                    self.success = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('isAdmin_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.BOOL, 0)
            oprot.writeBool(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(isAdmin_result)
isAdmin_result.thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ),  # 0
)


class isReviewer_args(object):
    """
    Attributes:
     - userName
    """


    def __init__(self, userName=None,):
        self.userName = userName

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.userName = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('isReviewer_args')
        if self.userName is not None:
            oprot.writeFieldBegin('userName', TType.STRING, 1)
            oprot.writeString(self.userName.encode('utf-8') if sys.version_info[0] == 2 else self.userName)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.userName is None:
            raise TProtocolException(message='Required field userName is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(isReviewer_args)
isReviewer_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'userName', 'UTF8', None, ),  # 1
)


class isReviewer_result(object):
    """
    Attributes:
     - success
    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.BOOL:
                    self.success = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('isReviewer_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.BOOL, 0)
            oprot.writeBool(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(isReviewer_result)
isReviewer_result.thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ),  # 0
)


class getAllRequestsForReviewers_args(object):
    """
    Attributes:
     - userName
    """


    def __init__(self, userName=None,):
        self.userName = userName

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.userName = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getAllRequestsForReviewers_args')
        if self.userName is not None:
            oprot.writeFieldBegin('userName', TType.STRING, 1)
            oprot.writeString(self.userName.encode('utf-8') if sys.version_info[0] == 2 else self.userName)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.userName is None:
            raise TProtocolException(message='Required field userName is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getAllRequestsForReviewers_args)
getAllRequestsForReviewers_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'userName', 'UTF8', None, ),  # 1
)


class getAllRequestsForReviewers_result(object):
    """
    Attributes:
     - success
    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype10, _size7) = iprot.readListBegin()
                    for _i11 in range(_size7):
                        _elem12 = allocation_manager_models.ttypes.UserAllocationDetail()
                        _elem12.read(iprot)
                        self.success.append(_elem12)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getAllRequestsForReviewers_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter13 in self.success:
                iter13.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getAllRequestsForReviewers_result)
getAllRequestsForReviewers_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT, [allocation_manager_models.ttypes.UserAllocationDetail, None], False), None, ),  # 0
)


class getUserDetails_args(object):
    """
    Attributes:
     - userName
    """


    def __init__(self, userName=None,):
        self.userName = userName

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.userName = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getUserDetails_args')
        if self.userName is not None:
            oprot.writeFieldBegin('userName', TType.STRING, 1)
            oprot.writeString(self.userName.encode('utf-8') if sys.version_info[0] == 2 else self.userName)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.userName is None:
            raise TProtocolException(message='Required field userName is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getUserDetails_args)
getUserDetails_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'userName', 'UTF8', None, ),  # 1
)


class getUserDetails_result(object):
    """
    Attributes:
     - success
    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = allocation_manager_models.ttypes.UserDetail()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getUserDetails_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getUserDetails_result)
getUserDetails_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [allocation_manager_models.ttypes.UserDetail, None], None, ),  # 0
)


class getAllReviewsForARequest_args(object):
    """
    Attributes:
     - projectId
    """


    def __init__(self, projectId=None,):
        self.projectId = projectId

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.projectId = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getAllReviewsForARequest_args')
        if self.projectId is not None:
            oprot.writeFieldBegin('projectId', TType.STRING, 1)
            oprot.writeString(self.projectId.encode('utf-8') if sys.version_info[0] == 2 else self.projectId)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.projectId is None:
            raise TProtocolException(message='Required field projectId is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getAllReviewsForARequest_args)
getAllReviewsForARequest_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'projectId', 'UTF8', None, ),  # 1
)


class getAllReviewsForARequest_result(object):
    """
    Attributes:
     - success
    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype17, _size14) = iprot.readListBegin()
                    for _i18 in range(_size14):
                        _elem19 = allocation_manager_models.ttypes.ReviewerAllocationDetail()
                        _elem19.read(iprot)
                        self.success.append(_elem19)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getAllReviewsForARequest_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter20 in self.success:
                iter20.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getAllReviewsForARequest_result)
getAllReviewsForARequest_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT, [allocation_manager_models.ttypes.ReviewerAllocationDetail, None], False), None, ),  # 0
)


class getAllReviewers_args(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getAllReviewers_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getAllReviewers_args)
getAllReviewers_args.thrift_spec = (
)


class getAllReviewers_result(object):
    """
    Attributes:
     - success
    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype24, _size21) = iprot.readListBegin()
                    for _i25 in range(_size21):
                        _elem26 = allocation_manager_models.ttypes.UserDetail()
                        _elem26.read(iprot)
                        self.success.append(_elem26)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getAllReviewers_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter27 in self.success:
                iter27.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getAllReviewers_result)
getAllReviewers_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT, [allocation_manager_models.ttypes.UserDetail, None], False), None, ),  # 0
)


class getAllUnassignedReviewersForRequest_args(object):
    """
    Attributes:
     - projectId
    """


    def __init__(self, projectId=None,):
        self.projectId = projectId

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.projectId = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getAllUnassignedReviewersForRequest_args')
        if self.projectId is not None:
            oprot.writeFieldBegin('projectId', TType.STRING, 1)
            oprot.writeString(self.projectId.encode('utf-8') if sys.version_info[0] == 2 else self.projectId)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.projectId is None:
            raise TProtocolException(message='Required field projectId is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getAllUnassignedReviewersForRequest_args)
getAllUnassignedReviewersForRequest_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'projectId', 'UTF8', None, ),  # 1
)


class getAllUnassignedReviewersForRequest_result(object):
    """
    Attributes:
     - success
    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype31, _size28) = iprot.readListBegin()
                    for _i32 in range(_size28):
                        _elem33 = allocation_manager_models.ttypes.UserDetail()
                        _elem33.read(iprot)
                        self.success.append(_elem33)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getAllUnassignedReviewersForRequest_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter34 in self.success:
                iter34.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getAllUnassignedReviewersForRequest_result)
getAllUnassignedReviewersForRequest_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT, [allocation_manager_models.ttypes.UserDetail, None], False), None, ),  # 0
)


class approveRequest_args(object):
    """
    Attributes:
     - projectId
     - adminId
     - startDate
     - endDate
     - awardAllocation
    """


    def __init__(self, projectId=None, adminId=None, startDate=None, endDate=None, awardAllocation=None,):
        self.projectId = projectId
        self.adminId = adminId
        self.startDate = startDate
        self.endDate = endDate
        self.awardAllocation = awardAllocation

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.projectId = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.adminId = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I64:
                    self.startDate = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I64:
                    self.endDate = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.I64:
                    self.awardAllocation = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('approveRequest_args')
        if self.projectId is not None:
            oprot.writeFieldBegin('projectId', TType.STRING, 1)
            oprot.writeString(self.projectId.encode('utf-8') if sys.version_info[0] == 2 else self.projectId)
            oprot.writeFieldEnd()
        if self.adminId is not None:
            oprot.writeFieldBegin('adminId', TType.STRING, 2)
            oprot.writeString(self.adminId.encode('utf-8') if sys.version_info[0] == 2 else self.adminId)
            oprot.writeFieldEnd()
        if self.startDate is not None:
            oprot.writeFieldBegin('startDate', TType.I64, 3)
            oprot.writeI64(self.startDate)
            oprot.writeFieldEnd()
        if self.endDate is not None:
            oprot.writeFieldBegin('endDate', TType.I64, 4)
            oprot.writeI64(self.endDate)
            oprot.writeFieldEnd()
        if self.awardAllocation is not None:
            oprot.writeFieldBegin('awardAllocation', TType.I64, 5)
            oprot.writeI64(self.awardAllocation)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.projectId is None:
            raise TProtocolException(message='Required field projectId is unset!')
        if self.adminId is None:
            raise TProtocolException(message='Required field adminId is unset!')
        if self.startDate is None:
            raise TProtocolException(message='Required field startDate is unset!')
        if self.endDate is None:
            raise TProtocolException(message='Required field endDate is unset!')
        if self.awardAllocation is None:
            raise TProtocolException(message='Required field awardAllocation is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(approveRequest_args)
approveRequest_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'projectId', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'adminId', 'UTF8', None, ),  # 2
    (3, TType.I64, 'startDate', None, None, ),  # 3
    (4, TType.I64, 'endDate', None, None, ),  # 4
    (5, TType.I64, 'awardAllocation', None, None, ),  # 5
)


class approveRequest_result(object):
    """
    Attributes:
     - success
    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.BOOL:
                    self.success = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('approveRequest_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.BOOL, 0)
            oprot.writeBool(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(approveRequest_result)
approveRequest_result.thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ),  # 0
)


class rejectRequest_args(object):
    """
    Attributes:
     - projectId
     - adminId
    """


    def __init__(self, projectId=None, adminId=None,):
        self.projectId = projectId
        self.adminId = adminId

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.projectId = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.adminId = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('rejectRequest_args')
        if self.projectId is not None:
            oprot.writeFieldBegin('projectId', TType.STRING, 1)
            oprot.writeString(self.projectId.encode('utf-8') if sys.version_info[0] == 2 else self.projectId)
            oprot.writeFieldEnd()
        if self.adminId is not None:
            oprot.writeFieldBegin('adminId', TType.STRING, 2)
            oprot.writeString(self.adminId.encode('utf-8') if sys.version_info[0] == 2 else self.adminId)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.projectId is None:
            raise TProtocolException(message='Required field projectId is unset!')
        if self.adminId is None:
            raise TProtocolException(message='Required field adminId is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(rejectRequest_args)
rejectRequest_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'projectId', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'adminId', 'UTF8', None, ),  # 2
)


class rejectRequest_result(object):
    """
    Attributes:
     - success
    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.BOOL:
                    self.success = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('rejectRequest_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.BOOL, 0)
            oprot.writeBool(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(rejectRequest_result)
rejectRequest_result.thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ),  # 0
)


class createUser_args(object):
    """
    Attributes:
     - userDetail
    """


    def __init__(self, userDetail=None,):
        self.userDetail = userDetail

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.userDetail = allocation_manager_models.ttypes.UserDetail()
                    self.userDetail.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('createUser_args')
        if self.userDetail is not None:
            oprot.writeFieldBegin('userDetail', TType.STRUCT, 1)
            self.userDetail.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.userDetail is None:
            raise TProtocolException(message='Required field userDetail is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(createUser_args)
createUser_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'userDetail', [allocation_manager_models.ttypes.UserDetail, None], None, ),  # 1
)


class createUser_result(object):
    """
    Attributes:
     - success
    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.BOOL:
                    self.success = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('createUser_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.BOOL, 0)
            oprot.writeBool(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(createUser_result)
createUser_result.thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ),  # 0
)
fix_spec(all_structs)
del all_structs

