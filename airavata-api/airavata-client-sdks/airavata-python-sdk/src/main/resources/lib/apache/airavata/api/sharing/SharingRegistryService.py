#
# Autogenerated by Thrift Compiler (0.9.3)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
#  options string: py
#

from thrift.Thrift import TType, TMessageType, TException, TApplicationException
import logging
from ttypes import *
from thrift.Thrift import TProcessor
from thrift.transport import TTransport
from thrift.protocol import TBinaryProtocol, TProtocol
try:
  from thrift.protocol import fastbinary
except:
  fastbinary = None


class Iface:
  def createDomain(self, domain):
    """
    <p>API method to create a new domain</p>

    Parameters:
     - domain
    """
    pass

  def updateDomain(self, domain):
    """
    <p>API method to update a domain</p>

    Parameters:
     - domain
    """
    pass

  def isDomainExists(self, domainId):
    """
    <p>API method to check Domain Exists</p>

    Parameters:
     - domainId
    """
    pass

  def deleteDomain(self, domainId):
    """
    <p>API method to delete domain</p>

    Parameters:
     - domainId
    """
    pass

  def getDomain(self, domainId):
    """
    <p>API method to retrieve a domain</p>

    Parameters:
     - domainId
    """
    pass

  def getDomains(self, offset, limit):
    """
    <p>API method to get all domain.</p>

    Parameters:
     - offset
     - limit
    """
    pass

  def createUser(self, user):
    """
    <p>API method to register a user in the system</p>

    Parameters:
     - user
    """
    pass

  def updatedUser(self, user):
    """
    <p>API method to update existing user</p>

    Parameters:
     - user
    """
    pass

  def isUserExists(self, domainId, userId):
    """
    <p>API method to check User Exists</p>

    Parameters:
     - domainId
     - userId
    """
    pass

  def deleteUser(self, domainId, userId):
    """
    <p>API method to delete user</p>

    Parameters:
     - domainId
     - userId
    """
    pass

  def getUser(self, domainId, userId):
    """
    <p>API method to get a user</p>

    Parameters:
     - domainId
     - userId
    """
    pass

  def getUsers(self, domainId, offset, limit):
    """
    <p>API method to get a list of users in a specific domain.</p>
    <li>domainId : Domain id</li>
    <li>offset : Starting result number</li>
    <li>limit : Number of max results to be sent</li>

    Parameters:
     - domainId
     - offset
     - limit
    """
    pass

  def createGroup(self, group):
    """
    <p>API method to create a new group</p>

    Parameters:
     - group
    """
    pass

  def updateGroup(self, group):
    """
    <p>API method to update a group</p>

    Parameters:
     - group
    """
    pass

  def isGroupExists(self, domainId, groupId):
    """
    <p>API method to check Group Exists</p>

    Parameters:
     - domainId
     - groupId
    """
    pass

  def deleteGroup(self, domainId, groupId):
    """
    <p>API method to delete a group</p>

    Parameters:
     - domainId
     - groupId
    """
    pass

  def getGroup(self, domainId, groupId):
    """
    <p>API method to get a group</p>

    Parameters:
     - domainId
     - groupId
    """
    pass

  def getGroups(self, domainId, offset, limit):
    """
    <p>API method to get groups in a domainId.</p>

    Parameters:
     - domainId
     - offset
     - limit
    """
    pass

  def addUsersToGroup(self, domainId, userIds, groupId):
    """
    <p>API method to add list of users to a group</p>

    Parameters:
     - domainId
     - userIds
     - groupId
    """
    pass

  def removeUsersFromGroup(self, domainId, userIds, groupId):
    """
    <p>API method to remove users from a group</p>

    Parameters:
     - domainId
     - userIds
     - groupId
    """
    pass

  def getGroupMembersOfTypeUser(self, domainId, groupId, offset, limit):
    """
    <p>API method to get list of child users in a group. Only the direct members will be returned.</p>

    Parameters:
     - domainId
     - groupId
     - offset
     - limit
    """
    pass

  def getGroupMembersOfTypeGroup(self, domainId, groupId, offset, limit):
    """
    <p>API method to get list of child groups in a group. Only the direct members will be returned.</p>

    Parameters:
     - domainId
     - groupId
     - offset
     - limit
    """
    pass

  def addChildGroupsToParentGroup(self, domainId, childIds, groupId):
    """
    <p>API method to add a child group to a parent group.</p>

    Parameters:
     - domainId
     - childIds
     - groupId
    """
    pass

  def removeChildGroupFromParentGroup(self, domainId, childId, groupId):
    """
    <p>API method to remove a child group from parent group.</p>

    Parameters:
     - domainId
     - childId
     - groupId
    """
    pass

  def getAllMemberGroupsForUser(self, domainId, userId):
    """
    Parameters:
     - domainId
     - userId
    """
    pass

  def createEntityType(self, entityType):
    """
    <p>API method to create a new entity type</p>

    Parameters:
     - entityType
    """
    pass

  def updateEntityType(self, entityType):
    """
    <p>API method to update entity type</p>

    Parameters:
     - entityType
    """
    pass

  def isEntityTypeExists(self, domainId, entityTypeId):
    """
    <p>API method to check EntityType Exists</p>

    Parameters:
     - domainId
     - entityTypeId
    """
    pass

  def deleteEntityType(self, domainId, entityTypeId):
    """
    <p>API method to delete entity type</p>

    Parameters:
     - domainId
     - entityTypeId
    """
    pass

  def getEntityType(self, domainId, entityTypeId):
    """
    <p>API method to get an entity type</p>

    Parameters:
     - domainId
     - entityTypeId
    """
    pass

  def getEntityTypes(self, domainId, offset, limit):
    """
    <p>API method to get entity types in a domainId.</p>

    Parameters:
     - domainId
     - offset
     - limit
    """
    pass

  def createEntity(self, entity):
    """
    <p>API method to register new entity</p>

    Parameters:
     - entity
    """
    pass

  def updateEntity(self, entity):
    """
    <p>API method to update entity</p>

    Parameters:
     - entity
    """
    pass

  def isEntityExists(self, domainId, entityId):
    """
    <p>API method to check Entity Exists</p>

    Parameters:
     - domainId
     - entityId
    """
    pass

  def deleteEntity(self, domainId, entityId):
    """
    <p>API method to delete entity</p>

    Parameters:
     - domainId
     - entityId
    """
    pass

  def getEntity(self, domainId, entityId):
    """
    <p>API method to get entity</p>

    Parameters:
     - domainId
     - entityId
    """
    pass

  def searchEntities(self, domainId, userId, filters, offset, limit):
    """
    <p>API method to search entities</p>

    Parameters:
     - domainId
     - userId
     - filters
     - offset
     - limit
    """
    pass

  def getListOfSharedUsers(self, domainId, entityId, permissionTypeId):
    """
    <p>API method to get a list of shared users given the entity id</p>

    Parameters:
     - domainId
     - entityId
     - permissionTypeId
    """
    pass

  def getListOfSharedGroups(self, domainId, entityId, permissionTypeId):
    """
    <p>API method to get a list of shared groups given the entity id</p>

    Parameters:
     - domainId
     - entityId
     - permissionTypeId
    """
    pass

  def createPermissionType(self, permissionType):
    """
    <p>API method to create permission type</p>

    Parameters:
     - permissionType
    """
    pass

  def updatePermissionType(self, permissionType):
    """
    <p>API method to update permission type</p>

    Parameters:
     - permissionType
    """
    pass

  def isPermissionExists(self, dimainId, permissionId):
    """
    <p>API method to check Permission Exists</p>

    Parameters:
     - dimainId
     - permissionId
    """
    pass

  def deletePermissionType(self, domainId, permissionTypeId):
    """
    <p>API method to delete permission type</p>

    Parameters:
     - domainId
     - permissionTypeId
    """
    pass

  def getPermissionType(self, domainId, permissionTypeId):
    """
    <p>API method to get permission type</p>

    Parameters:
     - domainId
     - permissionTypeId
    """
    pass

  def getPermissionTypes(self, domainId, offset, limit):
    """
    <p>API method to get list of permission types in a given domainId.</p>

    Parameters:
     - domainId
     - offset
     - limit
    """
    pass

  def shareEntityWithUsers(self, domainId, entityId, userList, perssionTypeId, cascadePermission):
    """
    <p>API method to share an entity with users</p>

    Parameters:
     - domainId
     - entityId
     - userList
     - perssionTypeId
     - cascadePermission
    """
    pass

  def revokeEntitySharingFromUsers(self, domainId, entityId, userList, perssionTypeId):
    """
    <p>API method to revoke sharing from a list of users</p>

    Parameters:
     - domainId
     - entityId
     - userList
     - perssionTypeId
    """
    pass

  def shareEntityWithGroups(self, domainId, entityId, groupList, perssionTypeId, cascadePermission):
    """
    <p>API method to share an entity with list of groups</p>

    Parameters:
     - domainId
     - entityId
     - groupList
     - perssionTypeId
     - cascadePermission
    """
    pass

  def revokeEntitySharingFromGroups(self, domainId, entityId, groupList, perssionTypeId):
    """
    <p>API method to revoke sharing from list of users</p>

    Parameters:
     - domainId
     - entityId
     - groupList
     - perssionTypeId
    """
    pass

  def userHasAccess(self, domainId, userId, entityId, permissionTypeId):
    """
    <p>API method to check whether a user has access to a specific entity</p>

    Parameters:
     - domainId
     - userId
     - entityId
     - permissionTypeId
    """
    pass


class Client(Iface):
  def __init__(self, iprot, oprot=None):
    self._iprot = self._oprot = iprot
    if oprot is not None:
      self._oprot = oprot
    self._seqid = 0

  def createDomain(self, domain):
    """
    <p>API method to create a new domain</p>

    Parameters:
     - domain
    """
    self.send_createDomain(domain)
    return self.recv_createDomain()

  def send_createDomain(self, domain):
    self._oprot.writeMessageBegin('createDomain', TMessageType.CALL, self._seqid)
    args = createDomain_args()
    args.domain = domain
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_createDomain(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = createDomain_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.sre is not None:
      raise result.sre
    if result.dee is not None:
      raise result.dee
    raise TApplicationException(TApplicationException.MISSING_RESULT, "createDomain failed: unknown result")

  def updateDomain(self, domain):
    """
    <p>API method to update a domain</p>

    Parameters:
     - domain
    """
    self.send_updateDomain(domain)
    return self.recv_updateDomain()

  def send_updateDomain(self, domain):
    self._oprot.writeMessageBegin('updateDomain', TMessageType.CALL, self._seqid)
    args = updateDomain_args()
    args.domain = domain
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_updateDomain(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = updateDomain_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.sre is not None:
      raise result.sre
    raise TApplicationException(TApplicationException.MISSING_RESULT, "updateDomain failed: unknown result")

  def isDomainExists(self, domainId):
    """
    <p>API method to check Domain Exists</p>

    Parameters:
     - domainId
    """
    self.send_isDomainExists(domainId)
    return self.recv_isDomainExists()

  def send_isDomainExists(self, domainId):
    self._oprot.writeMessageBegin('isDomainExists', TMessageType.CALL, self._seqid)
    args = isDomainExists_args()
    args.domainId = domainId
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_isDomainExists(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = isDomainExists_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.sre is not None:
      raise result.sre
    raise TApplicationException(TApplicationException.MISSING_RESULT, "isDomainExists failed: unknown result")

  def deleteDomain(self, domainId):
    """
    <p>API method to delete domain</p>

    Parameters:
     - domainId
    """
    self.send_deleteDomain(domainId)
    return self.recv_deleteDomain()

  def send_deleteDomain(self, domainId):
    self._oprot.writeMessageBegin('deleteDomain', TMessageType.CALL, self._seqid)
    args = deleteDomain_args()
    args.domainId = domainId
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_deleteDomain(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = deleteDomain_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.sre is not None:
      raise result.sre
    raise TApplicationException(TApplicationException.MISSING_RESULT, "deleteDomain failed: unknown result")

  def getDomain(self, domainId):
    """
    <p>API method to retrieve a domain</p>

    Parameters:
     - domainId
    """
    self.send_getDomain(domainId)
    return self.recv_getDomain()

  def send_getDomain(self, domainId):
    self._oprot.writeMessageBegin('getDomain', TMessageType.CALL, self._seqid)
    args = getDomain_args()
    args.domainId = domainId
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_getDomain(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = getDomain_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.sre is not None:
      raise result.sre
    raise TApplicationException(TApplicationException.MISSING_RESULT, "getDomain failed: unknown result")

  def getDomains(self, offset, limit):
    """
    <p>API method to get all domain.</p>

    Parameters:
     - offset
     - limit
    """
    self.send_getDomains(offset, limit)
    return self.recv_getDomains()

  def send_getDomains(self, offset, limit):
    self._oprot.writeMessageBegin('getDomains', TMessageType.CALL, self._seqid)
    args = getDomains_args()
    args.offset = offset
    args.limit = limit
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_getDomains(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = getDomains_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.sre is not None:
      raise result.sre
    raise TApplicationException(TApplicationException.MISSING_RESULT, "getDomains failed: unknown result")

  def createUser(self, user):
    """
    <p>API method to register a user in the system</p>

    Parameters:
     - user
    """
    self.send_createUser(user)
    return self.recv_createUser()

  def send_createUser(self, user):
    self._oprot.writeMessageBegin('createUser', TMessageType.CALL, self._seqid)
    args = createUser_args()
    args.user = user
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_createUser(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = createUser_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.sre is not None:
      raise result.sre
    if result.dee is not None:
      raise result.dee
    raise TApplicationException(TApplicationException.MISSING_RESULT, "createUser failed: unknown result")

  def updatedUser(self, user):
    """
    <p>API method to update existing user</p>

    Parameters:
     - user
    """
    self.send_updatedUser(user)
    return self.recv_updatedUser()

  def send_updatedUser(self, user):
    self._oprot.writeMessageBegin('updatedUser', TMessageType.CALL, self._seqid)
    args = updatedUser_args()
    args.user = user
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_updatedUser(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = updatedUser_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.sre is not None:
      raise result.sre
    raise TApplicationException(TApplicationException.MISSING_RESULT, "updatedUser failed: unknown result")

  def isUserExists(self, domainId, userId):
    """
    <p>API method to check User Exists</p>

    Parameters:
     - domainId
     - userId
    """
    self.send_isUserExists(domainId, userId)
    return self.recv_isUserExists()

  def send_isUserExists(self, domainId, userId):
    self._oprot.writeMessageBegin('isUserExists', TMessageType.CALL, self._seqid)
    args = isUserExists_args()
    args.domainId = domainId
    args.userId = userId
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_isUserExists(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = isUserExists_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.sre is not None:
      raise result.sre
    raise TApplicationException(TApplicationException.MISSING_RESULT, "isUserExists failed: unknown result")

  def deleteUser(self, domainId, userId):
    """
    <p>API method to delete user</p>

    Parameters:
     - domainId
     - userId
    """
    self.send_deleteUser(domainId, userId)
    return self.recv_deleteUser()

  def send_deleteUser(self, domainId, userId):
    self._oprot.writeMessageBegin('deleteUser', TMessageType.CALL, self._seqid)
    args = deleteUser_args()
    args.domainId = domainId
    args.userId = userId
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_deleteUser(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = deleteUser_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.sre is not None:
      raise result.sre
    raise TApplicationException(TApplicationException.MISSING_RESULT, "deleteUser failed: unknown result")

  def getUser(self, domainId, userId):
    """
    <p>API method to get a user</p>

    Parameters:
     - domainId
     - userId
    """
    self.send_getUser(domainId, userId)
    return self.recv_getUser()

  def send_getUser(self, domainId, userId):
    self._oprot.writeMessageBegin('getUser', TMessageType.CALL, self._seqid)
    args = getUser_args()
    args.domainId = domainId
    args.userId = userId
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_getUser(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = getUser_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.sre is not None:
      raise result.sre
    raise TApplicationException(TApplicationException.MISSING_RESULT, "getUser failed: unknown result")

  def getUsers(self, domainId, offset, limit):
    """
    <p>API method to get a list of users in a specific domain.</p>
    <li>domainId : Domain id</li>
    <li>offset : Starting result number</li>
    <li>limit : Number of max results to be sent</li>

    Parameters:
     - domainId
     - offset
     - limit
    """
    self.send_getUsers(domainId, offset, limit)
    return self.recv_getUsers()

  def send_getUsers(self, domainId, offset, limit):
    self._oprot.writeMessageBegin('getUsers', TMessageType.CALL, self._seqid)
    args = getUsers_args()
    args.domainId = domainId
    args.offset = offset
    args.limit = limit
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_getUsers(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = getUsers_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.sre is not None:
      raise result.sre
    raise TApplicationException(TApplicationException.MISSING_RESULT, "getUsers failed: unknown result")

  def createGroup(self, group):
    """
    <p>API method to create a new group</p>

    Parameters:
     - group
    """
    self.send_createGroup(group)
    return self.recv_createGroup()

  def send_createGroup(self, group):
    self._oprot.writeMessageBegin('createGroup', TMessageType.CALL, self._seqid)
    args = createGroup_args()
    args.group = group
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_createGroup(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = createGroup_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.sre is not None:
      raise result.sre
    raise TApplicationException(TApplicationException.MISSING_RESULT, "createGroup failed: unknown result")

  def updateGroup(self, group):
    """
    <p>API method to update a group</p>

    Parameters:
     - group
    """
    self.send_updateGroup(group)
    return self.recv_updateGroup()

  def send_updateGroup(self, group):
    self._oprot.writeMessageBegin('updateGroup', TMessageType.CALL, self._seqid)
    args = updateGroup_args()
    args.group = group
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_updateGroup(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = updateGroup_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.sre is not None:
      raise result.sre
    raise TApplicationException(TApplicationException.MISSING_RESULT, "updateGroup failed: unknown result")

  def isGroupExists(self, domainId, groupId):
    """
    <p>API method to check Group Exists</p>

    Parameters:
     - domainId
     - groupId
    """
    self.send_isGroupExists(domainId, groupId)
    return self.recv_isGroupExists()

  def send_isGroupExists(self, domainId, groupId):
    self._oprot.writeMessageBegin('isGroupExists', TMessageType.CALL, self._seqid)
    args = isGroupExists_args()
    args.domainId = domainId
    args.groupId = groupId
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_isGroupExists(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = isGroupExists_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.sre is not None:
      raise result.sre
    raise TApplicationException(TApplicationException.MISSING_RESULT, "isGroupExists failed: unknown result")

  def deleteGroup(self, domainId, groupId):
    """
    <p>API method to delete a group</p>

    Parameters:
     - domainId
     - groupId
    """
    self.send_deleteGroup(domainId, groupId)
    return self.recv_deleteGroup()

  def send_deleteGroup(self, domainId, groupId):
    self._oprot.writeMessageBegin('deleteGroup', TMessageType.CALL, self._seqid)
    args = deleteGroup_args()
    args.domainId = domainId
    args.groupId = groupId
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_deleteGroup(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = deleteGroup_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.sre is not None:
      raise result.sre
    raise TApplicationException(TApplicationException.MISSING_RESULT, "deleteGroup failed: unknown result")

  def getGroup(self, domainId, groupId):
    """
    <p>API method to get a group</p>

    Parameters:
     - domainId
     - groupId
    """
    self.send_getGroup(domainId, groupId)
    return self.recv_getGroup()

  def send_getGroup(self, domainId, groupId):
    self._oprot.writeMessageBegin('getGroup', TMessageType.CALL, self._seqid)
    args = getGroup_args()
    args.domainId = domainId
    args.groupId = groupId
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_getGroup(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = getGroup_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.sre is not None:
      raise result.sre
    raise TApplicationException(TApplicationException.MISSING_RESULT, "getGroup failed: unknown result")

  def getGroups(self, domainId, offset, limit):
    """
    <p>API method to get groups in a domainId.</p>

    Parameters:
     - domainId
     - offset
     - limit
    """
    self.send_getGroups(domainId, offset, limit)
    return self.recv_getGroups()

  def send_getGroups(self, domainId, offset, limit):
    self._oprot.writeMessageBegin('getGroups', TMessageType.CALL, self._seqid)
    args = getGroups_args()
    args.domainId = domainId
    args.offset = offset
    args.limit = limit
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_getGroups(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = getGroups_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "getGroups failed: unknown result")

  def addUsersToGroup(self, domainId, userIds, groupId):
    """
    <p>API method to add list of users to a group</p>

    Parameters:
     - domainId
     - userIds
     - groupId
    """
    self.send_addUsersToGroup(domainId, userIds, groupId)
    return self.recv_addUsersToGroup()

  def send_addUsersToGroup(self, domainId, userIds, groupId):
    self._oprot.writeMessageBegin('addUsersToGroup', TMessageType.CALL, self._seqid)
    args = addUsersToGroup_args()
    args.domainId = domainId
    args.userIds = userIds
    args.groupId = groupId
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_addUsersToGroup(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = addUsersToGroup_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.sre is not None:
      raise result.sre
    raise TApplicationException(TApplicationException.MISSING_RESULT, "addUsersToGroup failed: unknown result")

  def removeUsersFromGroup(self, domainId, userIds, groupId):
    """
    <p>API method to remove users from a group</p>

    Parameters:
     - domainId
     - userIds
     - groupId
    """
    self.send_removeUsersFromGroup(domainId, userIds, groupId)
    return self.recv_removeUsersFromGroup()

  def send_removeUsersFromGroup(self, domainId, userIds, groupId):
    self._oprot.writeMessageBegin('removeUsersFromGroup', TMessageType.CALL, self._seqid)
    args = removeUsersFromGroup_args()
    args.domainId = domainId
    args.userIds = userIds
    args.groupId = groupId
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_removeUsersFromGroup(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = removeUsersFromGroup_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.sre is not None:
      raise result.sre
    raise TApplicationException(TApplicationException.MISSING_RESULT, "removeUsersFromGroup failed: unknown result")

  def getGroupMembersOfTypeUser(self, domainId, groupId, offset, limit):
    """
    <p>API method to get list of child users in a group. Only the direct members will be returned.</p>

    Parameters:
     - domainId
     - groupId
     - offset
     - limit
    """
    self.send_getGroupMembersOfTypeUser(domainId, groupId, offset, limit)
    return self.recv_getGroupMembersOfTypeUser()

  def send_getGroupMembersOfTypeUser(self, domainId, groupId, offset, limit):
    self._oprot.writeMessageBegin('getGroupMembersOfTypeUser', TMessageType.CALL, self._seqid)
    args = getGroupMembersOfTypeUser_args()
    args.domainId = domainId
    args.groupId = groupId
    args.offset = offset
    args.limit = limit
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_getGroupMembersOfTypeUser(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = getGroupMembersOfTypeUser_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.sre is not None:
      raise result.sre
    raise TApplicationException(TApplicationException.MISSING_RESULT, "getGroupMembersOfTypeUser failed: unknown result")

  def getGroupMembersOfTypeGroup(self, domainId, groupId, offset, limit):
    """
    <p>API method to get list of child groups in a group. Only the direct members will be returned.</p>

    Parameters:
     - domainId
     - groupId
     - offset
     - limit
    """
    self.send_getGroupMembersOfTypeGroup(domainId, groupId, offset, limit)
    return self.recv_getGroupMembersOfTypeGroup()

  def send_getGroupMembersOfTypeGroup(self, domainId, groupId, offset, limit):
    self._oprot.writeMessageBegin('getGroupMembersOfTypeGroup', TMessageType.CALL, self._seqid)
    args = getGroupMembersOfTypeGroup_args()
    args.domainId = domainId
    args.groupId = groupId
    args.offset = offset
    args.limit = limit
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_getGroupMembersOfTypeGroup(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = getGroupMembersOfTypeGroup_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.sre is not None:
      raise result.sre
    raise TApplicationException(TApplicationException.MISSING_RESULT, "getGroupMembersOfTypeGroup failed: unknown result")

  def addChildGroupsToParentGroup(self, domainId, childIds, groupId):
    """
    <p>API method to add a child group to a parent group.</p>

    Parameters:
     - domainId
     - childIds
     - groupId
    """
    self.send_addChildGroupsToParentGroup(domainId, childIds, groupId)
    return self.recv_addChildGroupsToParentGroup()

  def send_addChildGroupsToParentGroup(self, domainId, childIds, groupId):
    self._oprot.writeMessageBegin('addChildGroupsToParentGroup', TMessageType.CALL, self._seqid)
    args = addChildGroupsToParentGroup_args()
    args.domainId = domainId
    args.childIds = childIds
    args.groupId = groupId
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_addChildGroupsToParentGroup(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = addChildGroupsToParentGroup_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.sre is not None:
      raise result.sre
    raise TApplicationException(TApplicationException.MISSING_RESULT, "addChildGroupsToParentGroup failed: unknown result")

  def removeChildGroupFromParentGroup(self, domainId, childId, groupId):
    """
    <p>API method to remove a child group from parent group.</p>

    Parameters:
     - domainId
     - childId
     - groupId
    """
    self.send_removeChildGroupFromParentGroup(domainId, childId, groupId)
    return self.recv_removeChildGroupFromParentGroup()

  def send_removeChildGroupFromParentGroup(self, domainId, childId, groupId):
    self._oprot.writeMessageBegin('removeChildGroupFromParentGroup', TMessageType.CALL, self._seqid)
    args = removeChildGroupFromParentGroup_args()
    args.domainId = domainId
    args.childId = childId
    args.groupId = groupId
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_removeChildGroupFromParentGroup(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = removeChildGroupFromParentGroup_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.sre is not None:
      raise result.sre
    raise TApplicationException(TApplicationException.MISSING_RESULT, "removeChildGroupFromParentGroup failed: unknown result")

  def getAllMemberGroupsForUser(self, domainId, userId):
    """
    Parameters:
     - domainId
     - userId
    """
    self.send_getAllMemberGroupsForUser(domainId, userId)
    return self.recv_getAllMemberGroupsForUser()

  def send_getAllMemberGroupsForUser(self, domainId, userId):
    self._oprot.writeMessageBegin('getAllMemberGroupsForUser', TMessageType.CALL, self._seqid)
    args = getAllMemberGroupsForUser_args()
    args.domainId = domainId
    args.userId = userId
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_getAllMemberGroupsForUser(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = getAllMemberGroupsForUser_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.sre is not None:
      raise result.sre
    raise TApplicationException(TApplicationException.MISSING_RESULT, "getAllMemberGroupsForUser failed: unknown result")

  def createEntityType(self, entityType):
    """
    <p>API method to create a new entity type</p>

    Parameters:
     - entityType
    """
    self.send_createEntityType(entityType)
    return self.recv_createEntityType()

  def send_createEntityType(self, entityType):
    self._oprot.writeMessageBegin('createEntityType', TMessageType.CALL, self._seqid)
    args = createEntityType_args()
    args.entityType = entityType
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_createEntityType(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = createEntityType_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.sre is not None:
      raise result.sre
    if result.dee is not None:
      raise result.dee
    raise TApplicationException(TApplicationException.MISSING_RESULT, "createEntityType failed: unknown result")

  def updateEntityType(self, entityType):
    """
    <p>API method to update entity type</p>

    Parameters:
     - entityType
    """
    self.send_updateEntityType(entityType)
    return self.recv_updateEntityType()

  def send_updateEntityType(self, entityType):
    self._oprot.writeMessageBegin('updateEntityType', TMessageType.CALL, self._seqid)
    args = updateEntityType_args()
    args.entityType = entityType
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_updateEntityType(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = updateEntityType_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.sre is not None:
      raise result.sre
    raise TApplicationException(TApplicationException.MISSING_RESULT, "updateEntityType failed: unknown result")

  def isEntityTypeExists(self, domainId, entityTypeId):
    """
    <p>API method to check EntityType Exists</p>

    Parameters:
     - domainId
     - entityTypeId
    """
    self.send_isEntityTypeExists(domainId, entityTypeId)
    return self.recv_isEntityTypeExists()

  def send_isEntityTypeExists(self, domainId, entityTypeId):
    self._oprot.writeMessageBegin('isEntityTypeExists', TMessageType.CALL, self._seqid)
    args = isEntityTypeExists_args()
    args.domainId = domainId
    args.entityTypeId = entityTypeId
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_isEntityTypeExists(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = isEntityTypeExists_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.sre is not None:
      raise result.sre
    raise TApplicationException(TApplicationException.MISSING_RESULT, "isEntityTypeExists failed: unknown result")

  def deleteEntityType(self, domainId, entityTypeId):
    """
    <p>API method to delete entity type</p>

    Parameters:
     - domainId
     - entityTypeId
    """
    self.send_deleteEntityType(domainId, entityTypeId)
    return self.recv_deleteEntityType()

  def send_deleteEntityType(self, domainId, entityTypeId):
    self._oprot.writeMessageBegin('deleteEntityType', TMessageType.CALL, self._seqid)
    args = deleteEntityType_args()
    args.domainId = domainId
    args.entityTypeId = entityTypeId
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_deleteEntityType(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = deleteEntityType_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.sre is not None:
      raise result.sre
    raise TApplicationException(TApplicationException.MISSING_RESULT, "deleteEntityType failed: unknown result")

  def getEntityType(self, domainId, entityTypeId):
    """
    <p>API method to get an entity type</p>

    Parameters:
     - domainId
     - entityTypeId
    """
    self.send_getEntityType(domainId, entityTypeId)
    return self.recv_getEntityType()

  def send_getEntityType(self, domainId, entityTypeId):
    self._oprot.writeMessageBegin('getEntityType', TMessageType.CALL, self._seqid)
    args = getEntityType_args()
    args.domainId = domainId
    args.entityTypeId = entityTypeId
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_getEntityType(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = getEntityType_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.sre is not None:
      raise result.sre
    raise TApplicationException(TApplicationException.MISSING_RESULT, "getEntityType failed: unknown result")

  def getEntityTypes(self, domainId, offset, limit):
    """
    <p>API method to get entity types in a domainId.</p>

    Parameters:
     - domainId
     - offset
     - limit
    """
    self.send_getEntityTypes(domainId, offset, limit)
    return self.recv_getEntityTypes()

  def send_getEntityTypes(self, domainId, offset, limit):
    self._oprot.writeMessageBegin('getEntityTypes', TMessageType.CALL, self._seqid)
    args = getEntityTypes_args()
    args.domainId = domainId
    args.offset = offset
    args.limit = limit
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_getEntityTypes(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = getEntityTypes_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.sre is not None:
      raise result.sre
    raise TApplicationException(TApplicationException.MISSING_RESULT, "getEntityTypes failed: unknown result")

  def createEntity(self, entity):
    """
    <p>API method to register new entity</p>

    Parameters:
     - entity
    """
    self.send_createEntity(entity)
    return self.recv_createEntity()

  def send_createEntity(self, entity):
    self._oprot.writeMessageBegin('createEntity', TMessageType.CALL, self._seqid)
    args = createEntity_args()
    args.entity = entity
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_createEntity(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = createEntity_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.sre is not None:
      raise result.sre
    raise TApplicationException(TApplicationException.MISSING_RESULT, "createEntity failed: unknown result")

  def updateEntity(self, entity):
    """
    <p>API method to update entity</p>

    Parameters:
     - entity
    """
    self.send_updateEntity(entity)
    return self.recv_updateEntity()

  def send_updateEntity(self, entity):
    self._oprot.writeMessageBegin('updateEntity', TMessageType.CALL, self._seqid)
    args = updateEntity_args()
    args.entity = entity
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_updateEntity(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = updateEntity_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.sre is not None:
      raise result.sre
    raise TApplicationException(TApplicationException.MISSING_RESULT, "updateEntity failed: unknown result")

  def isEntityExists(self, domainId, entityId):
    """
    <p>API method to check Entity Exists</p>

    Parameters:
     - domainId
     - entityId
    """
    self.send_isEntityExists(domainId, entityId)
    return self.recv_isEntityExists()

  def send_isEntityExists(self, domainId, entityId):
    self._oprot.writeMessageBegin('isEntityExists', TMessageType.CALL, self._seqid)
    args = isEntityExists_args()
    args.domainId = domainId
    args.entityId = entityId
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_isEntityExists(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = isEntityExists_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.sre is not None:
      raise result.sre
    raise TApplicationException(TApplicationException.MISSING_RESULT, "isEntityExists failed: unknown result")

  def deleteEntity(self, domainId, entityId):
    """
    <p>API method to delete entity</p>

    Parameters:
     - domainId
     - entityId
    """
    self.send_deleteEntity(domainId, entityId)
    return self.recv_deleteEntity()

  def send_deleteEntity(self, domainId, entityId):
    self._oprot.writeMessageBegin('deleteEntity', TMessageType.CALL, self._seqid)
    args = deleteEntity_args()
    args.domainId = domainId
    args.entityId = entityId
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_deleteEntity(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = deleteEntity_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.sre is not None:
      raise result.sre
    raise TApplicationException(TApplicationException.MISSING_RESULT, "deleteEntity failed: unknown result")

  def getEntity(self, domainId, entityId):
    """
    <p>API method to get entity</p>

    Parameters:
     - domainId
     - entityId
    """
    self.send_getEntity(domainId, entityId)
    return self.recv_getEntity()

  def send_getEntity(self, domainId, entityId):
    self._oprot.writeMessageBegin('getEntity', TMessageType.CALL, self._seqid)
    args = getEntity_args()
    args.domainId = domainId
    args.entityId = entityId
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_getEntity(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = getEntity_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.sre is not None:
      raise result.sre
    raise TApplicationException(TApplicationException.MISSING_RESULT, "getEntity failed: unknown result")

  def searchEntities(self, domainId, userId, filters, offset, limit):
    """
    <p>API method to search entities</p>

    Parameters:
     - domainId
     - userId
     - filters
     - offset
     - limit
    """
    self.send_searchEntities(domainId, userId, filters, offset, limit)
    return self.recv_searchEntities()

  def send_searchEntities(self, domainId, userId, filters, offset, limit):
    self._oprot.writeMessageBegin('searchEntities', TMessageType.CALL, self._seqid)
    args = searchEntities_args()
    args.domainId = domainId
    args.userId = userId
    args.filters = filters
    args.offset = offset
    args.limit = limit
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_searchEntities(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = searchEntities_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.sre is not None:
      raise result.sre
    raise TApplicationException(TApplicationException.MISSING_RESULT, "searchEntities failed: unknown result")

  def getListOfSharedUsers(self, domainId, entityId, permissionTypeId):
    """
    <p>API method to get a list of shared users given the entity id</p>

    Parameters:
     - domainId
     - entityId
     - permissionTypeId
    """
    self.send_getListOfSharedUsers(domainId, entityId, permissionTypeId)
    return self.recv_getListOfSharedUsers()

  def send_getListOfSharedUsers(self, domainId, entityId, permissionTypeId):
    self._oprot.writeMessageBegin('getListOfSharedUsers', TMessageType.CALL, self._seqid)
    args = getListOfSharedUsers_args()
    args.domainId = domainId
    args.entityId = entityId
    args.permissionTypeId = permissionTypeId
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_getListOfSharedUsers(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = getListOfSharedUsers_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.sre is not None:
      raise result.sre
    raise TApplicationException(TApplicationException.MISSING_RESULT, "getListOfSharedUsers failed: unknown result")

  def getListOfSharedGroups(self, domainId, entityId, permissionTypeId):
    """
    <p>API method to get a list of shared groups given the entity id</p>

    Parameters:
     - domainId
     - entityId
     - permissionTypeId
    """
    self.send_getListOfSharedGroups(domainId, entityId, permissionTypeId)
    return self.recv_getListOfSharedGroups()

  def send_getListOfSharedGroups(self, domainId, entityId, permissionTypeId):
    self._oprot.writeMessageBegin('getListOfSharedGroups', TMessageType.CALL, self._seqid)
    args = getListOfSharedGroups_args()
    args.domainId = domainId
    args.entityId = entityId
    args.permissionTypeId = permissionTypeId
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_getListOfSharedGroups(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = getListOfSharedGroups_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.sre is not None:
      raise result.sre
    raise TApplicationException(TApplicationException.MISSING_RESULT, "getListOfSharedGroups failed: unknown result")

  def createPermissionType(self, permissionType):
    """
    <p>API method to create permission type</p>

    Parameters:
     - permissionType
    """
    self.send_createPermissionType(permissionType)
    return self.recv_createPermissionType()

  def send_createPermissionType(self, permissionType):
    self._oprot.writeMessageBegin('createPermissionType', TMessageType.CALL, self._seqid)
    args = createPermissionType_args()
    args.permissionType = permissionType
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_createPermissionType(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = createPermissionType_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.sre is not None:
      raise result.sre
    if result.dee is not None:
      raise result.dee
    raise TApplicationException(TApplicationException.MISSING_RESULT, "createPermissionType failed: unknown result")

  def updatePermissionType(self, permissionType):
    """
    <p>API method to update permission type</p>

    Parameters:
     - permissionType
    """
    self.send_updatePermissionType(permissionType)
    return self.recv_updatePermissionType()

  def send_updatePermissionType(self, permissionType):
    self._oprot.writeMessageBegin('updatePermissionType', TMessageType.CALL, self._seqid)
    args = updatePermissionType_args()
    args.permissionType = permissionType
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_updatePermissionType(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = updatePermissionType_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.sre is not None:
      raise result.sre
    raise TApplicationException(TApplicationException.MISSING_RESULT, "updatePermissionType failed: unknown result")

  def isPermissionExists(self, dimainId, permissionId):
    """
    <p>API method to check Permission Exists</p>

    Parameters:
     - dimainId
     - permissionId
    """
    self.send_isPermissionExists(dimainId, permissionId)
    return self.recv_isPermissionExists()

  def send_isPermissionExists(self, dimainId, permissionId):
    self._oprot.writeMessageBegin('isPermissionExists', TMessageType.CALL, self._seqid)
    args = isPermissionExists_args()
    args.dimainId = dimainId
    args.permissionId = permissionId
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_isPermissionExists(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = isPermissionExists_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.sre is not None:
      raise result.sre
    raise TApplicationException(TApplicationException.MISSING_RESULT, "isPermissionExists failed: unknown result")

  def deletePermissionType(self, domainId, permissionTypeId):
    """
    <p>API method to delete permission type</p>

    Parameters:
     - domainId
     - permissionTypeId
    """
    self.send_deletePermissionType(domainId, permissionTypeId)
    return self.recv_deletePermissionType()

  def send_deletePermissionType(self, domainId, permissionTypeId):
    self._oprot.writeMessageBegin('deletePermissionType', TMessageType.CALL, self._seqid)
    args = deletePermissionType_args()
    args.domainId = domainId
    args.permissionTypeId = permissionTypeId
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_deletePermissionType(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = deletePermissionType_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.sre is not None:
      raise result.sre
    raise TApplicationException(TApplicationException.MISSING_RESULT, "deletePermissionType failed: unknown result")

  def getPermissionType(self, domainId, permissionTypeId):
    """
    <p>API method to get permission type</p>

    Parameters:
     - domainId
     - permissionTypeId
    """
    self.send_getPermissionType(domainId, permissionTypeId)
    return self.recv_getPermissionType()

  def send_getPermissionType(self, domainId, permissionTypeId):
    self._oprot.writeMessageBegin('getPermissionType', TMessageType.CALL, self._seqid)
    args = getPermissionType_args()
    args.domainId = domainId
    args.permissionTypeId = permissionTypeId
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_getPermissionType(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = getPermissionType_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.sre is not None:
      raise result.sre
    raise TApplicationException(TApplicationException.MISSING_RESULT, "getPermissionType failed: unknown result")

  def getPermissionTypes(self, domainId, offset, limit):
    """
    <p>API method to get list of permission types in a given domainId.</p>

    Parameters:
     - domainId
     - offset
     - limit
    """
    self.send_getPermissionTypes(domainId, offset, limit)
    return self.recv_getPermissionTypes()

  def send_getPermissionTypes(self, domainId, offset, limit):
    self._oprot.writeMessageBegin('getPermissionTypes', TMessageType.CALL, self._seqid)
    args = getPermissionTypes_args()
    args.domainId = domainId
    args.offset = offset
    args.limit = limit
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_getPermissionTypes(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = getPermissionTypes_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.sre is not None:
      raise result.sre
    raise TApplicationException(TApplicationException.MISSING_RESULT, "getPermissionTypes failed: unknown result")

  def shareEntityWithUsers(self, domainId, entityId, userList, perssionTypeId, cascadePermission):
    """
    <p>API method to share an entity with users</p>

    Parameters:
     - domainId
     - entityId
     - userList
     - perssionTypeId
     - cascadePermission
    """
    self.send_shareEntityWithUsers(domainId, entityId, userList, perssionTypeId, cascadePermission)
    return self.recv_shareEntityWithUsers()

  def send_shareEntityWithUsers(self, domainId, entityId, userList, perssionTypeId, cascadePermission):
    self._oprot.writeMessageBegin('shareEntityWithUsers', TMessageType.CALL, self._seqid)
    args = shareEntityWithUsers_args()
    args.domainId = domainId
    args.entityId = entityId
    args.userList = userList
    args.perssionTypeId = perssionTypeId
    args.cascadePermission = cascadePermission
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_shareEntityWithUsers(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = shareEntityWithUsers_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.sre is not None:
      raise result.sre
    raise TApplicationException(TApplicationException.MISSING_RESULT, "shareEntityWithUsers failed: unknown result")

  def revokeEntitySharingFromUsers(self, domainId, entityId, userList, perssionTypeId):
    """
    <p>API method to revoke sharing from a list of users</p>

    Parameters:
     - domainId
     - entityId
     - userList
     - perssionTypeId
    """
    self.send_revokeEntitySharingFromUsers(domainId, entityId, userList, perssionTypeId)
    return self.recv_revokeEntitySharingFromUsers()

  def send_revokeEntitySharingFromUsers(self, domainId, entityId, userList, perssionTypeId):
    self._oprot.writeMessageBegin('revokeEntitySharingFromUsers', TMessageType.CALL, self._seqid)
    args = revokeEntitySharingFromUsers_args()
    args.domainId = domainId
    args.entityId = entityId
    args.userList = userList
    args.perssionTypeId = perssionTypeId
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_revokeEntitySharingFromUsers(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = revokeEntitySharingFromUsers_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.sre is not None:
      raise result.sre
    raise TApplicationException(TApplicationException.MISSING_RESULT, "revokeEntitySharingFromUsers failed: unknown result")

  def shareEntityWithGroups(self, domainId, entityId, groupList, perssionTypeId, cascadePermission):
    """
    <p>API method to share an entity with list of groups</p>

    Parameters:
     - domainId
     - entityId
     - groupList
     - perssionTypeId
     - cascadePermission
    """
    self.send_shareEntityWithGroups(domainId, entityId, groupList, perssionTypeId, cascadePermission)
    return self.recv_shareEntityWithGroups()

  def send_shareEntityWithGroups(self, domainId, entityId, groupList, perssionTypeId, cascadePermission):
    self._oprot.writeMessageBegin('shareEntityWithGroups', TMessageType.CALL, self._seqid)
    args = shareEntityWithGroups_args()
    args.domainId = domainId
    args.entityId = entityId
    args.groupList = groupList
    args.perssionTypeId = perssionTypeId
    args.cascadePermission = cascadePermission
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_shareEntityWithGroups(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = shareEntityWithGroups_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.sre is not None:
      raise result.sre
    raise TApplicationException(TApplicationException.MISSING_RESULT, "shareEntityWithGroups failed: unknown result")

  def revokeEntitySharingFromGroups(self, domainId, entityId, groupList, perssionTypeId):
    """
    <p>API method to revoke sharing from list of users</p>

    Parameters:
     - domainId
     - entityId
     - groupList
     - perssionTypeId
    """
    self.send_revokeEntitySharingFromGroups(domainId, entityId, groupList, perssionTypeId)
    return self.recv_revokeEntitySharingFromGroups()

  def send_revokeEntitySharingFromGroups(self, domainId, entityId, groupList, perssionTypeId):
    self._oprot.writeMessageBegin('revokeEntitySharingFromGroups', TMessageType.CALL, self._seqid)
    args = revokeEntitySharingFromGroups_args()
    args.domainId = domainId
    args.entityId = entityId
    args.groupList = groupList
    args.perssionTypeId = perssionTypeId
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_revokeEntitySharingFromGroups(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = revokeEntitySharingFromGroups_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.sre is not None:
      raise result.sre
    raise TApplicationException(TApplicationException.MISSING_RESULT, "revokeEntitySharingFromGroups failed: unknown result")

  def userHasAccess(self, domainId, userId, entityId, permissionTypeId):
    """
    <p>API method to check whether a user has access to a specific entity</p>

    Parameters:
     - domainId
     - userId
     - entityId
     - permissionTypeId
    """
    self.send_userHasAccess(domainId, userId, entityId, permissionTypeId)
    return self.recv_userHasAccess()

  def send_userHasAccess(self, domainId, userId, entityId, permissionTypeId):
    self._oprot.writeMessageBegin('userHasAccess', TMessageType.CALL, self._seqid)
    args = userHasAccess_args()
    args.domainId = domainId
    args.userId = userId
    args.entityId = entityId
    args.permissionTypeId = permissionTypeId
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_userHasAccess(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = userHasAccess_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.sre is not None:
      raise result.sre
    raise TApplicationException(TApplicationException.MISSING_RESULT, "userHasAccess failed: unknown result")


class Processor(Iface, TProcessor):
  def __init__(self, handler):
    self._handler = handler
    self._processMap = {}
    self._processMap["createDomain"] = Processor.process_createDomain
    self._processMap["updateDomain"] = Processor.process_updateDomain
    self._processMap["isDomainExists"] = Processor.process_isDomainExists
    self._processMap["deleteDomain"] = Processor.process_deleteDomain
    self._processMap["getDomain"] = Processor.process_getDomain
    self._processMap["getDomains"] = Processor.process_getDomains
    self._processMap["createUser"] = Processor.process_createUser
    self._processMap["updatedUser"] = Processor.process_updatedUser
    self._processMap["isUserExists"] = Processor.process_isUserExists
    self._processMap["deleteUser"] = Processor.process_deleteUser
    self._processMap["getUser"] = Processor.process_getUser
    self._processMap["getUsers"] = Processor.process_getUsers
    self._processMap["createGroup"] = Processor.process_createGroup
    self._processMap["updateGroup"] = Processor.process_updateGroup
    self._processMap["isGroupExists"] = Processor.process_isGroupExists
    self._processMap["deleteGroup"] = Processor.process_deleteGroup
    self._processMap["getGroup"] = Processor.process_getGroup
    self._processMap["getGroups"] = Processor.process_getGroups
    self._processMap["addUsersToGroup"] = Processor.process_addUsersToGroup
    self._processMap["removeUsersFromGroup"] = Processor.process_removeUsersFromGroup
    self._processMap["getGroupMembersOfTypeUser"] = Processor.process_getGroupMembersOfTypeUser
    self._processMap["getGroupMembersOfTypeGroup"] = Processor.process_getGroupMembersOfTypeGroup
    self._processMap["addChildGroupsToParentGroup"] = Processor.process_addChildGroupsToParentGroup
    self._processMap["removeChildGroupFromParentGroup"] = Processor.process_removeChildGroupFromParentGroup
    self._processMap["getAllMemberGroupsForUser"] = Processor.process_getAllMemberGroupsForUser
    self._processMap["createEntityType"] = Processor.process_createEntityType
    self._processMap["updateEntityType"] = Processor.process_updateEntityType
    self._processMap["isEntityTypeExists"] = Processor.process_isEntityTypeExists
    self._processMap["deleteEntityType"] = Processor.process_deleteEntityType
    self._processMap["getEntityType"] = Processor.process_getEntityType
    self._processMap["getEntityTypes"] = Processor.process_getEntityTypes
    self._processMap["createEntity"] = Processor.process_createEntity
    self._processMap["updateEntity"] = Processor.process_updateEntity
    self._processMap["isEntityExists"] = Processor.process_isEntityExists
    self._processMap["deleteEntity"] = Processor.process_deleteEntity
    self._processMap["getEntity"] = Processor.process_getEntity
    self._processMap["searchEntities"] = Processor.process_searchEntities
    self._processMap["getListOfSharedUsers"] = Processor.process_getListOfSharedUsers
    self._processMap["getListOfSharedGroups"] = Processor.process_getListOfSharedGroups
    self._processMap["createPermissionType"] = Processor.process_createPermissionType
    self._processMap["updatePermissionType"] = Processor.process_updatePermissionType
    self._processMap["isPermissionExists"] = Processor.process_isPermissionExists
    self._processMap["deletePermissionType"] = Processor.process_deletePermissionType
    self._processMap["getPermissionType"] = Processor.process_getPermissionType
    self._processMap["getPermissionTypes"] = Processor.process_getPermissionTypes
    self._processMap["shareEntityWithUsers"] = Processor.process_shareEntityWithUsers
    self._processMap["revokeEntitySharingFromUsers"] = Processor.process_revokeEntitySharingFromUsers
    self._processMap["shareEntityWithGroups"] = Processor.process_shareEntityWithGroups
    self._processMap["revokeEntitySharingFromGroups"] = Processor.process_revokeEntitySharingFromGroups
    self._processMap["userHasAccess"] = Processor.process_userHasAccess

  def process(self, iprot, oprot):
    (name, type, seqid) = iprot.readMessageBegin()
    if name not in self._processMap:
      iprot.skip(TType.STRUCT)
      iprot.readMessageEnd()
      x = TApplicationException(TApplicationException.UNKNOWN_METHOD, 'Unknown function %s' % (name))
      oprot.writeMessageBegin(name, TMessageType.EXCEPTION, seqid)
      x.write(oprot)
      oprot.writeMessageEnd()
      oprot.trans.flush()
      return
    else:
      self._processMap[name](self, seqid, iprot, oprot)
    return True

  def process_createDomain(self, seqid, iprot, oprot):
    args = createDomain_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = createDomain_result()
    try:
      result.success = self._handler.createDomain(args.domain)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except apache.airavata.model.sharing.ttypes.SharingRegistryException as sre:
      msg_type = TMessageType.REPLY
      result.sre = sre
    except apache.airavata.model.sharing.ttypes.DuplicateEntryException as dee:
      msg_type = TMessageType.REPLY
      result.dee = dee
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("createDomain", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_updateDomain(self, seqid, iprot, oprot):
    args = updateDomain_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = updateDomain_result()
    try:
      result.success = self._handler.updateDomain(args.domain)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except apache.airavata.model.sharing.ttypes.SharingRegistryException as sre:
      msg_type = TMessageType.REPLY
      result.sre = sre
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("updateDomain", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_isDomainExists(self, seqid, iprot, oprot):
    args = isDomainExists_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = isDomainExists_result()
    try:
      result.success = self._handler.isDomainExists(args.domainId)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except apache.airavata.model.sharing.ttypes.SharingRegistryException as sre:
      msg_type = TMessageType.REPLY
      result.sre = sre
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("isDomainExists", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_deleteDomain(self, seqid, iprot, oprot):
    args = deleteDomain_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = deleteDomain_result()
    try:
      result.success = self._handler.deleteDomain(args.domainId)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except apache.airavata.model.sharing.ttypes.SharingRegistryException as sre:
      msg_type = TMessageType.REPLY
      result.sre = sre
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("deleteDomain", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_getDomain(self, seqid, iprot, oprot):
    args = getDomain_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = getDomain_result()
    try:
      result.success = self._handler.getDomain(args.domainId)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except apache.airavata.model.sharing.ttypes.SharingRegistryException as sre:
      msg_type = TMessageType.REPLY
      result.sre = sre
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("getDomain", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_getDomains(self, seqid, iprot, oprot):
    args = getDomains_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = getDomains_result()
    try:
      result.success = self._handler.getDomains(args.offset, args.limit)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except apache.airavata.model.sharing.ttypes.SharingRegistryException as sre:
      msg_type = TMessageType.REPLY
      result.sre = sre
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("getDomains", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_createUser(self, seqid, iprot, oprot):
    args = createUser_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = createUser_result()
    try:
      result.success = self._handler.createUser(args.user)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except apache.airavata.model.sharing.ttypes.SharingRegistryException as sre:
      msg_type = TMessageType.REPLY
      result.sre = sre
    except apache.airavata.model.sharing.ttypes.DuplicateEntryException as dee:
      msg_type = TMessageType.REPLY
      result.dee = dee
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("createUser", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_updatedUser(self, seqid, iprot, oprot):
    args = updatedUser_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = updatedUser_result()
    try:
      result.success = self._handler.updatedUser(args.user)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except apache.airavata.model.sharing.ttypes.SharingRegistryException as sre:
      msg_type = TMessageType.REPLY
      result.sre = sre
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("updatedUser", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_isUserExists(self, seqid, iprot, oprot):
    args = isUserExists_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = isUserExists_result()
    try:
      result.success = self._handler.isUserExists(args.domainId, args.userId)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except apache.airavata.model.sharing.ttypes.SharingRegistryException as sre:
      msg_type = TMessageType.REPLY
      result.sre = sre
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("isUserExists", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_deleteUser(self, seqid, iprot, oprot):
    args = deleteUser_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = deleteUser_result()
    try:
      result.success = self._handler.deleteUser(args.domainId, args.userId)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except apache.airavata.model.sharing.ttypes.SharingRegistryException as sre:
      msg_type = TMessageType.REPLY
      result.sre = sre
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("deleteUser", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_getUser(self, seqid, iprot, oprot):
    args = getUser_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = getUser_result()
    try:
      result.success = self._handler.getUser(args.domainId, args.userId)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except apache.airavata.model.sharing.ttypes.SharingRegistryException as sre:
      msg_type = TMessageType.REPLY
      result.sre = sre
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("getUser", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_getUsers(self, seqid, iprot, oprot):
    args = getUsers_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = getUsers_result()
    try:
      result.success = self._handler.getUsers(args.domainId, args.offset, args.limit)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except apache.airavata.model.sharing.ttypes.SharingRegistryException as sre:
      msg_type = TMessageType.REPLY
      result.sre = sre
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("getUsers", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_createGroup(self, seqid, iprot, oprot):
    args = createGroup_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = createGroup_result()
    try:
      result.success = self._handler.createGroup(args.group)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except apache.airavata.model.sharing.ttypes.SharingRegistryException as sre:
      msg_type = TMessageType.REPLY
      result.sre = sre
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("createGroup", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_updateGroup(self, seqid, iprot, oprot):
    args = updateGroup_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = updateGroup_result()
    try:
      result.success = self._handler.updateGroup(args.group)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except apache.airavata.model.sharing.ttypes.SharingRegistryException as sre:
      msg_type = TMessageType.REPLY
      result.sre = sre
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("updateGroup", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_isGroupExists(self, seqid, iprot, oprot):
    args = isGroupExists_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = isGroupExists_result()
    try:
      result.success = self._handler.isGroupExists(args.domainId, args.groupId)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except apache.airavata.model.sharing.ttypes.SharingRegistryException as sre:
      msg_type = TMessageType.REPLY
      result.sre = sre
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("isGroupExists", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_deleteGroup(self, seqid, iprot, oprot):
    args = deleteGroup_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = deleteGroup_result()
    try:
      result.success = self._handler.deleteGroup(args.domainId, args.groupId)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except apache.airavata.model.sharing.ttypes.SharingRegistryException as sre:
      msg_type = TMessageType.REPLY
      result.sre = sre
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("deleteGroup", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_getGroup(self, seqid, iprot, oprot):
    args = getGroup_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = getGroup_result()
    try:
      result.success = self._handler.getGroup(args.domainId, args.groupId)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except apache.airavata.model.sharing.ttypes.SharingRegistryException as sre:
      msg_type = TMessageType.REPLY
      result.sre = sre
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("getGroup", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_getGroups(self, seqid, iprot, oprot):
    args = getGroups_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = getGroups_result()
    try:
      result.success = self._handler.getGroups(args.domainId, args.offset, args.limit)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("getGroups", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_addUsersToGroup(self, seqid, iprot, oprot):
    args = addUsersToGroup_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = addUsersToGroup_result()
    try:
      result.success = self._handler.addUsersToGroup(args.domainId, args.userIds, args.groupId)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except apache.airavata.model.sharing.ttypes.SharingRegistryException as sre:
      msg_type = TMessageType.REPLY
      result.sre = sre
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("addUsersToGroup", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_removeUsersFromGroup(self, seqid, iprot, oprot):
    args = removeUsersFromGroup_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = removeUsersFromGroup_result()
    try:
      result.success = self._handler.removeUsersFromGroup(args.domainId, args.userIds, args.groupId)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except apache.airavata.model.sharing.ttypes.SharingRegistryException as sre:
      msg_type = TMessageType.REPLY
      result.sre = sre
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("removeUsersFromGroup", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_getGroupMembersOfTypeUser(self, seqid, iprot, oprot):
    args = getGroupMembersOfTypeUser_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = getGroupMembersOfTypeUser_result()
    try:
      result.success = self._handler.getGroupMembersOfTypeUser(args.domainId, args.groupId, args.offset, args.limit)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except apache.airavata.model.sharing.ttypes.SharingRegistryException as sre:
      msg_type = TMessageType.REPLY
      result.sre = sre
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("getGroupMembersOfTypeUser", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_getGroupMembersOfTypeGroup(self, seqid, iprot, oprot):
    args = getGroupMembersOfTypeGroup_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = getGroupMembersOfTypeGroup_result()
    try:
      result.success = self._handler.getGroupMembersOfTypeGroup(args.domainId, args.groupId, args.offset, args.limit)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except apache.airavata.model.sharing.ttypes.SharingRegistryException as sre:
      msg_type = TMessageType.REPLY
      result.sre = sre
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("getGroupMembersOfTypeGroup", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_addChildGroupsToParentGroup(self, seqid, iprot, oprot):
    args = addChildGroupsToParentGroup_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = addChildGroupsToParentGroup_result()
    try:
      result.success = self._handler.addChildGroupsToParentGroup(args.domainId, args.childIds, args.groupId)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except apache.airavata.model.sharing.ttypes.SharingRegistryException as sre:
      msg_type = TMessageType.REPLY
      result.sre = sre
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("addChildGroupsToParentGroup", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_removeChildGroupFromParentGroup(self, seqid, iprot, oprot):
    args = removeChildGroupFromParentGroup_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = removeChildGroupFromParentGroup_result()
    try:
      result.success = self._handler.removeChildGroupFromParentGroup(args.domainId, args.childId, args.groupId)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except apache.airavata.model.sharing.ttypes.SharingRegistryException as sre:
      msg_type = TMessageType.REPLY
      result.sre = sre
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("removeChildGroupFromParentGroup", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_getAllMemberGroupsForUser(self, seqid, iprot, oprot):
    args = getAllMemberGroupsForUser_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = getAllMemberGroupsForUser_result()
    try:
      result.success = self._handler.getAllMemberGroupsForUser(args.domainId, args.userId)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except apache.airavata.model.sharing.ttypes.SharingRegistryException as sre:
      msg_type = TMessageType.REPLY
      result.sre = sre
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("getAllMemberGroupsForUser", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_createEntityType(self, seqid, iprot, oprot):
    args = createEntityType_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = createEntityType_result()
    try:
      result.success = self._handler.createEntityType(args.entityType)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except apache.airavata.model.sharing.ttypes.SharingRegistryException as sre:
      msg_type = TMessageType.REPLY
      result.sre = sre
    except apache.airavata.model.sharing.ttypes.DuplicateEntryException as dee:
      msg_type = TMessageType.REPLY
      result.dee = dee
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("createEntityType", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_updateEntityType(self, seqid, iprot, oprot):
    args = updateEntityType_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = updateEntityType_result()
    try:
      result.success = self._handler.updateEntityType(args.entityType)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except apache.airavata.model.sharing.ttypes.SharingRegistryException as sre:
      msg_type = TMessageType.REPLY
      result.sre = sre
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("updateEntityType", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_isEntityTypeExists(self, seqid, iprot, oprot):
    args = isEntityTypeExists_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = isEntityTypeExists_result()
    try:
      result.success = self._handler.isEntityTypeExists(args.domainId, args.entityTypeId)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except apache.airavata.model.sharing.ttypes.SharingRegistryException as sre:
      msg_type = TMessageType.REPLY
      result.sre = sre
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("isEntityTypeExists", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_deleteEntityType(self, seqid, iprot, oprot):
    args = deleteEntityType_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = deleteEntityType_result()
    try:
      result.success = self._handler.deleteEntityType(args.domainId, args.entityTypeId)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except apache.airavata.model.sharing.ttypes.SharingRegistryException as sre:
      msg_type = TMessageType.REPLY
      result.sre = sre
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("deleteEntityType", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_getEntityType(self, seqid, iprot, oprot):
    args = getEntityType_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = getEntityType_result()
    try:
      result.success = self._handler.getEntityType(args.domainId, args.entityTypeId)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except apache.airavata.model.sharing.ttypes.SharingRegistryException as sre:
      msg_type = TMessageType.REPLY
      result.sre = sre
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("getEntityType", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_getEntityTypes(self, seqid, iprot, oprot):
    args = getEntityTypes_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = getEntityTypes_result()
    try:
      result.success = self._handler.getEntityTypes(args.domainId, args.offset, args.limit)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except apache.airavata.model.sharing.ttypes.SharingRegistryException as sre:
      msg_type = TMessageType.REPLY
      result.sre = sre
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("getEntityTypes", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_createEntity(self, seqid, iprot, oprot):
    args = createEntity_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = createEntity_result()
    try:
      result.success = self._handler.createEntity(args.entity)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except apache.airavata.model.sharing.ttypes.SharingRegistryException as sre:
      msg_type = TMessageType.REPLY
      result.sre = sre
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("createEntity", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_updateEntity(self, seqid, iprot, oprot):
    args = updateEntity_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = updateEntity_result()
    try:
      result.success = self._handler.updateEntity(args.entity)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except apache.airavata.model.sharing.ttypes.SharingRegistryException as sre:
      msg_type = TMessageType.REPLY
      result.sre = sre
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("updateEntity", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_isEntityExists(self, seqid, iprot, oprot):
    args = isEntityExists_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = isEntityExists_result()
    try:
      result.success = self._handler.isEntityExists(args.domainId, args.entityId)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except apache.airavata.model.sharing.ttypes.SharingRegistryException as sre:
      msg_type = TMessageType.REPLY
      result.sre = sre
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("isEntityExists", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_deleteEntity(self, seqid, iprot, oprot):
    args = deleteEntity_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = deleteEntity_result()
    try:
      result.success = self._handler.deleteEntity(args.domainId, args.entityId)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except apache.airavata.model.sharing.ttypes.SharingRegistryException as sre:
      msg_type = TMessageType.REPLY
      result.sre = sre
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("deleteEntity", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_getEntity(self, seqid, iprot, oprot):
    args = getEntity_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = getEntity_result()
    try:
      result.success = self._handler.getEntity(args.domainId, args.entityId)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except apache.airavata.model.sharing.ttypes.SharingRegistryException as sre:
      msg_type = TMessageType.REPLY
      result.sre = sre
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("getEntity", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_searchEntities(self, seqid, iprot, oprot):
    args = searchEntities_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = searchEntities_result()
    try:
      result.success = self._handler.searchEntities(args.domainId, args.userId, args.filters, args.offset, args.limit)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except apache.airavata.model.sharing.ttypes.SharingRegistryException as sre:
      msg_type = TMessageType.REPLY
      result.sre = sre
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("searchEntities", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_getListOfSharedUsers(self, seqid, iprot, oprot):
    args = getListOfSharedUsers_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = getListOfSharedUsers_result()
    try:
      result.success = self._handler.getListOfSharedUsers(args.domainId, args.entityId, args.permissionTypeId)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except apache.airavata.model.sharing.ttypes.SharingRegistryException as sre:
      msg_type = TMessageType.REPLY
      result.sre = sre
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("getListOfSharedUsers", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_getListOfSharedGroups(self, seqid, iprot, oprot):
    args = getListOfSharedGroups_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = getListOfSharedGroups_result()
    try:
      result.success = self._handler.getListOfSharedGroups(args.domainId, args.entityId, args.permissionTypeId)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except apache.airavata.model.sharing.ttypes.SharingRegistryException as sre:
      msg_type = TMessageType.REPLY
      result.sre = sre
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("getListOfSharedGroups", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_createPermissionType(self, seqid, iprot, oprot):
    args = createPermissionType_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = createPermissionType_result()
    try:
      result.success = self._handler.createPermissionType(args.permissionType)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except apache.airavata.model.sharing.ttypes.SharingRegistryException as sre:
      msg_type = TMessageType.REPLY
      result.sre = sre
    except apache.airavata.model.sharing.ttypes.DuplicateEntryException as dee:
      msg_type = TMessageType.REPLY
      result.dee = dee
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("createPermissionType", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_updatePermissionType(self, seqid, iprot, oprot):
    args = updatePermissionType_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = updatePermissionType_result()
    try:
      result.success = self._handler.updatePermissionType(args.permissionType)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except apache.airavata.model.sharing.ttypes.SharingRegistryException as sre:
      msg_type = TMessageType.REPLY
      result.sre = sre
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("updatePermissionType", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_isPermissionExists(self, seqid, iprot, oprot):
    args = isPermissionExists_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = isPermissionExists_result()
    try:
      result.success = self._handler.isPermissionExists(args.dimainId, args.permissionId)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except apache.airavata.model.sharing.ttypes.SharingRegistryException as sre:
      msg_type = TMessageType.REPLY
      result.sre = sre
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("isPermissionExists", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_deletePermissionType(self, seqid, iprot, oprot):
    args = deletePermissionType_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = deletePermissionType_result()
    try:
      result.success = self._handler.deletePermissionType(args.domainId, args.permissionTypeId)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except apache.airavata.model.sharing.ttypes.SharingRegistryException as sre:
      msg_type = TMessageType.REPLY
      result.sre = sre
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("deletePermissionType", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_getPermissionType(self, seqid, iprot, oprot):
    args = getPermissionType_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = getPermissionType_result()
    try:
      result.success = self._handler.getPermissionType(args.domainId, args.permissionTypeId)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except apache.airavata.model.sharing.ttypes.SharingRegistryException as sre:
      msg_type = TMessageType.REPLY
      result.sre = sre
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("getPermissionType", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_getPermissionTypes(self, seqid, iprot, oprot):
    args = getPermissionTypes_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = getPermissionTypes_result()
    try:
      result.success = self._handler.getPermissionTypes(args.domainId, args.offset, args.limit)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except apache.airavata.model.sharing.ttypes.SharingRegistryException as sre:
      msg_type = TMessageType.REPLY
      result.sre = sre
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("getPermissionTypes", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_shareEntityWithUsers(self, seqid, iprot, oprot):
    args = shareEntityWithUsers_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = shareEntityWithUsers_result()
    try:
      result.success = self._handler.shareEntityWithUsers(args.domainId, args.entityId, args.userList, args.perssionTypeId, args.cascadePermission)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except apache.airavata.model.sharing.ttypes.SharingRegistryException as sre:
      msg_type = TMessageType.REPLY
      result.sre = sre
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("shareEntityWithUsers", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_revokeEntitySharingFromUsers(self, seqid, iprot, oprot):
    args = revokeEntitySharingFromUsers_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = revokeEntitySharingFromUsers_result()
    try:
      result.success = self._handler.revokeEntitySharingFromUsers(args.domainId, args.entityId, args.userList, args.perssionTypeId)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except apache.airavata.model.sharing.ttypes.SharingRegistryException as sre:
      msg_type = TMessageType.REPLY
      result.sre = sre
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("revokeEntitySharingFromUsers", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_shareEntityWithGroups(self, seqid, iprot, oprot):
    args = shareEntityWithGroups_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = shareEntityWithGroups_result()
    try:
      result.success = self._handler.shareEntityWithGroups(args.domainId, args.entityId, args.groupList, args.perssionTypeId, args.cascadePermission)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except apache.airavata.model.sharing.ttypes.SharingRegistryException as sre:
      msg_type = TMessageType.REPLY
      result.sre = sre
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("shareEntityWithGroups", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_revokeEntitySharingFromGroups(self, seqid, iprot, oprot):
    args = revokeEntitySharingFromGroups_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = revokeEntitySharingFromGroups_result()
    try:
      result.success = self._handler.revokeEntitySharingFromGroups(args.domainId, args.entityId, args.groupList, args.perssionTypeId)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except apache.airavata.model.sharing.ttypes.SharingRegistryException as sre:
      msg_type = TMessageType.REPLY
      result.sre = sre
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("revokeEntitySharingFromGroups", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_userHasAccess(self, seqid, iprot, oprot):
    args = userHasAccess_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = userHasAccess_result()
    try:
      result.success = self._handler.userHasAccess(args.domainId, args.userId, args.entityId, args.permissionTypeId)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except apache.airavata.model.sharing.ttypes.SharingRegistryException as sre:
      msg_type = TMessageType.REPLY
      result.sre = sre
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("userHasAccess", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()


# HELPER FUNCTIONS AND STRUCTURES

class createDomain_args:
  """
  Attributes:
   - domain
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'domain', (apache.airavata.model.sharing.ttypes.Domain, apache.airavata.model.sharing.ttypes.Domain.thrift_spec), None, ), # 1
  )

  def __init__(self, domain=None,):
    self.domain = domain

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.domain = apache.airavata.model.sharing.ttypes.Domain()
          self.domain.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('createDomain_args')
    if self.domain is not None:
      oprot.writeFieldBegin('domain', TType.STRUCT, 1)
      self.domain.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.domain is None:
      raise TProtocol.TProtocolException(message='Required field domain is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.domain)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class createDomain_result:
  """
  Attributes:
   - success
   - sre
   - dee
  """

  thrift_spec = (
    (0, TType.STRING, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'sre', (apache.airavata.model.sharing.ttypes.SharingRegistryException, apache.airavata.model.sharing.ttypes.SharingRegistryException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'dee', (apache.airavata.model.sharing.ttypes.DuplicateEntryException, apache.airavata.model.sharing.ttypes.DuplicateEntryException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, sre=None, dee=None,):
    self.success = success
    self.sre = sre
    self.dee = dee

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRING:
          self.success = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.sre = apache.airavata.model.sharing.ttypes.SharingRegistryException()
          self.sre.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.dee = apache.airavata.model.sharing.ttypes.DuplicateEntryException()
          self.dee.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('createDomain_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRING, 0)
      oprot.writeString(self.success)
      oprot.writeFieldEnd()
    if self.sre is not None:
      oprot.writeFieldBegin('sre', TType.STRUCT, 1)
      self.sre.write(oprot)
      oprot.writeFieldEnd()
    if self.dee is not None:
      oprot.writeFieldBegin('dee', TType.STRUCT, 2)
      self.dee.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.sre)
    value = (value * 31) ^ hash(self.dee)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class updateDomain_args:
  """
  Attributes:
   - domain
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'domain', (apache.airavata.model.sharing.ttypes.Domain, apache.airavata.model.sharing.ttypes.Domain.thrift_spec), None, ), # 1
  )

  def __init__(self, domain=None,):
    self.domain = domain

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.domain = apache.airavata.model.sharing.ttypes.Domain()
          self.domain.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('updateDomain_args')
    if self.domain is not None:
      oprot.writeFieldBegin('domain', TType.STRUCT, 1)
      self.domain.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.domain is None:
      raise TProtocol.TProtocolException(message='Required field domain is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.domain)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class updateDomain_result:
  """
  Attributes:
   - success
   - sre
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'sre', (apache.airavata.model.sharing.ttypes.SharingRegistryException, apache.airavata.model.sharing.ttypes.SharingRegistryException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, sre=None,):
    self.success = success
    self.sre = sre

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.sre = apache.airavata.model.sharing.ttypes.SharingRegistryException()
          self.sre.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('updateDomain_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    if self.sre is not None:
      oprot.writeFieldBegin('sre', TType.STRUCT, 1)
      self.sre.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.sre)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class isDomainExists_args:
  """
  Attributes:
   - domainId
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'domainId', None, None, ), # 1
  )

  def __init__(self, domainId=None,):
    self.domainId = domainId

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.domainId = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('isDomainExists_args')
    if self.domainId is not None:
      oprot.writeFieldBegin('domainId', TType.STRING, 1)
      oprot.writeString(self.domainId)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.domainId is None:
      raise TProtocol.TProtocolException(message='Required field domainId is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.domainId)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class isDomainExists_result:
  """
  Attributes:
   - success
   - sre
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'sre', (apache.airavata.model.sharing.ttypes.SharingRegistryException, apache.airavata.model.sharing.ttypes.SharingRegistryException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, sre=None,):
    self.success = success
    self.sre = sre

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.sre = apache.airavata.model.sharing.ttypes.SharingRegistryException()
          self.sre.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('isDomainExists_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    if self.sre is not None:
      oprot.writeFieldBegin('sre', TType.STRUCT, 1)
      self.sre.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.sre)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class deleteDomain_args:
  """
  Attributes:
   - domainId
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'domainId', None, None, ), # 1
  )

  def __init__(self, domainId=None,):
    self.domainId = domainId

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.domainId = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('deleteDomain_args')
    if self.domainId is not None:
      oprot.writeFieldBegin('domainId', TType.STRING, 1)
      oprot.writeString(self.domainId)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.domainId is None:
      raise TProtocol.TProtocolException(message='Required field domainId is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.domainId)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class deleteDomain_result:
  """
  Attributes:
   - success
   - sre
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'sre', (apache.airavata.model.sharing.ttypes.SharingRegistryException, apache.airavata.model.sharing.ttypes.SharingRegistryException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, sre=None,):
    self.success = success
    self.sre = sre

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.sre = apache.airavata.model.sharing.ttypes.SharingRegistryException()
          self.sre.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('deleteDomain_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    if self.sre is not None:
      oprot.writeFieldBegin('sre', TType.STRUCT, 1)
      self.sre.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.sre)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getDomain_args:
  """
  Attributes:
   - domainId
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'domainId', None, None, ), # 1
  )

  def __init__(self, domainId=None,):
    self.domainId = domainId

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.domainId = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getDomain_args')
    if self.domainId is not None:
      oprot.writeFieldBegin('domainId', TType.STRING, 1)
      oprot.writeString(self.domainId)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.domainId is None:
      raise TProtocol.TProtocolException(message='Required field domainId is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.domainId)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getDomain_result:
  """
  Attributes:
   - success
   - sre
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (apache.airavata.model.sharing.ttypes.Domain, apache.airavata.model.sharing.ttypes.Domain.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'sre', (apache.airavata.model.sharing.ttypes.SharingRegistryException, apache.airavata.model.sharing.ttypes.SharingRegistryException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, sre=None,):
    self.success = success
    self.sre = sre

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = apache.airavata.model.sharing.ttypes.Domain()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.sre = apache.airavata.model.sharing.ttypes.SharingRegistryException()
          self.sre.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getDomain_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.sre is not None:
      oprot.writeFieldBegin('sre', TType.STRUCT, 1)
      self.sre.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.sre)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getDomains_args:
  """
  Attributes:
   - offset
   - limit
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'offset', None, None, ), # 1
    (2, TType.I32, 'limit', None, None, ), # 2
  )

  def __init__(self, offset=None, limit=None,):
    self.offset = offset
    self.limit = limit

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.offset = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.limit = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getDomains_args')
    if self.offset is not None:
      oprot.writeFieldBegin('offset', TType.I32, 1)
      oprot.writeI32(self.offset)
      oprot.writeFieldEnd()
    if self.limit is not None:
      oprot.writeFieldBegin('limit', TType.I32, 2)
      oprot.writeI32(self.limit)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.offset is None:
      raise TProtocol.TProtocolException(message='Required field offset is unset!')
    if self.limit is None:
      raise TProtocol.TProtocolException(message='Required field limit is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.offset)
    value = (value * 31) ^ hash(self.limit)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getDomains_result:
  """
  Attributes:
   - success
   - sre
  """

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT,(apache.airavata.model.sharing.ttypes.Domain, apache.airavata.model.sharing.ttypes.Domain.thrift_spec)), None, ), # 0
    (1, TType.STRUCT, 'sre', (apache.airavata.model.sharing.ttypes.SharingRegistryException, apache.airavata.model.sharing.ttypes.SharingRegistryException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, sre=None,):
    self.success = success
    self.sre = sre

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype3, _size0) = iprot.readListBegin()
          for _i4 in xrange(_size0):
            _elem5 = apache.airavata.model.sharing.ttypes.Domain()
            _elem5.read(iprot)
            self.success.append(_elem5)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.sre = apache.airavata.model.sharing.ttypes.SharingRegistryException()
          self.sre.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getDomains_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.STRUCT, len(self.success))
      for iter6 in self.success:
        iter6.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.sre is not None:
      oprot.writeFieldBegin('sre', TType.STRUCT, 1)
      self.sre.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.sre)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class createUser_args:
  """
  Attributes:
   - user
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'user', (apache.airavata.model.sharing.ttypes.User, apache.airavata.model.sharing.ttypes.User.thrift_spec), None, ), # 1
  )

  def __init__(self, user=None,):
    self.user = user

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.user = apache.airavata.model.sharing.ttypes.User()
          self.user.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('createUser_args')
    if self.user is not None:
      oprot.writeFieldBegin('user', TType.STRUCT, 1)
      self.user.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.user is None:
      raise TProtocol.TProtocolException(message='Required field user is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.user)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class createUser_result:
  """
  Attributes:
   - success
   - sre
   - dee
  """

  thrift_spec = (
    (0, TType.STRING, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'sre', (apache.airavata.model.sharing.ttypes.SharingRegistryException, apache.airavata.model.sharing.ttypes.SharingRegistryException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'dee', (apache.airavata.model.sharing.ttypes.DuplicateEntryException, apache.airavata.model.sharing.ttypes.DuplicateEntryException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, sre=None, dee=None,):
    self.success = success
    self.sre = sre
    self.dee = dee

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRING:
          self.success = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.sre = apache.airavata.model.sharing.ttypes.SharingRegistryException()
          self.sre.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.dee = apache.airavata.model.sharing.ttypes.DuplicateEntryException()
          self.dee.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('createUser_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRING, 0)
      oprot.writeString(self.success)
      oprot.writeFieldEnd()
    if self.sre is not None:
      oprot.writeFieldBegin('sre', TType.STRUCT, 1)
      self.sre.write(oprot)
      oprot.writeFieldEnd()
    if self.dee is not None:
      oprot.writeFieldBegin('dee', TType.STRUCT, 2)
      self.dee.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.sre)
    value = (value * 31) ^ hash(self.dee)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class updatedUser_args:
  """
  Attributes:
   - user
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'user', (apache.airavata.model.sharing.ttypes.User, apache.airavata.model.sharing.ttypes.User.thrift_spec), None, ), # 1
  )

  def __init__(self, user=None,):
    self.user = user

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.user = apache.airavata.model.sharing.ttypes.User()
          self.user.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('updatedUser_args')
    if self.user is not None:
      oprot.writeFieldBegin('user', TType.STRUCT, 1)
      self.user.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.user is None:
      raise TProtocol.TProtocolException(message='Required field user is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.user)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class updatedUser_result:
  """
  Attributes:
   - success
   - sre
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'sre', (apache.airavata.model.sharing.ttypes.SharingRegistryException, apache.airavata.model.sharing.ttypes.SharingRegistryException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, sre=None,):
    self.success = success
    self.sre = sre

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.sre = apache.airavata.model.sharing.ttypes.SharingRegistryException()
          self.sre.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('updatedUser_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    if self.sre is not None:
      oprot.writeFieldBegin('sre', TType.STRUCT, 1)
      self.sre.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.sre)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class isUserExists_args:
  """
  Attributes:
   - domainId
   - userId
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'domainId', None, None, ), # 1
    (2, TType.STRING, 'userId', None, None, ), # 2
  )

  def __init__(self, domainId=None, userId=None,):
    self.domainId = domainId
    self.userId = userId

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.domainId = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.userId = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('isUserExists_args')
    if self.domainId is not None:
      oprot.writeFieldBegin('domainId', TType.STRING, 1)
      oprot.writeString(self.domainId)
      oprot.writeFieldEnd()
    if self.userId is not None:
      oprot.writeFieldBegin('userId', TType.STRING, 2)
      oprot.writeString(self.userId)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.domainId is None:
      raise TProtocol.TProtocolException(message='Required field domainId is unset!')
    if self.userId is None:
      raise TProtocol.TProtocolException(message='Required field userId is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.domainId)
    value = (value * 31) ^ hash(self.userId)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class isUserExists_result:
  """
  Attributes:
   - success
   - sre
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'sre', (apache.airavata.model.sharing.ttypes.SharingRegistryException, apache.airavata.model.sharing.ttypes.SharingRegistryException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, sre=None,):
    self.success = success
    self.sre = sre

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.sre = apache.airavata.model.sharing.ttypes.SharingRegistryException()
          self.sre.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('isUserExists_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    if self.sre is not None:
      oprot.writeFieldBegin('sre', TType.STRUCT, 1)
      self.sre.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.sre)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class deleteUser_args:
  """
  Attributes:
   - domainId
   - userId
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'domainId', None, None, ), # 1
    (2, TType.STRING, 'userId', None, None, ), # 2
  )

  def __init__(self, domainId=None, userId=None,):
    self.domainId = domainId
    self.userId = userId

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.domainId = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.userId = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('deleteUser_args')
    if self.domainId is not None:
      oprot.writeFieldBegin('domainId', TType.STRING, 1)
      oprot.writeString(self.domainId)
      oprot.writeFieldEnd()
    if self.userId is not None:
      oprot.writeFieldBegin('userId', TType.STRING, 2)
      oprot.writeString(self.userId)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.domainId is None:
      raise TProtocol.TProtocolException(message='Required field domainId is unset!')
    if self.userId is None:
      raise TProtocol.TProtocolException(message='Required field userId is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.domainId)
    value = (value * 31) ^ hash(self.userId)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class deleteUser_result:
  """
  Attributes:
   - success
   - sre
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'sre', (apache.airavata.model.sharing.ttypes.SharingRegistryException, apache.airavata.model.sharing.ttypes.SharingRegistryException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, sre=None,):
    self.success = success
    self.sre = sre

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.sre = apache.airavata.model.sharing.ttypes.SharingRegistryException()
          self.sre.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('deleteUser_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    if self.sre is not None:
      oprot.writeFieldBegin('sre', TType.STRUCT, 1)
      self.sre.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.sre)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getUser_args:
  """
  Attributes:
   - domainId
   - userId
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'domainId', None, None, ), # 1
    (2, TType.STRING, 'userId', None, None, ), # 2
  )

  def __init__(self, domainId=None, userId=None,):
    self.domainId = domainId
    self.userId = userId

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.domainId = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.userId = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getUser_args')
    if self.domainId is not None:
      oprot.writeFieldBegin('domainId', TType.STRING, 1)
      oprot.writeString(self.domainId)
      oprot.writeFieldEnd()
    if self.userId is not None:
      oprot.writeFieldBegin('userId', TType.STRING, 2)
      oprot.writeString(self.userId)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.domainId is None:
      raise TProtocol.TProtocolException(message='Required field domainId is unset!')
    if self.userId is None:
      raise TProtocol.TProtocolException(message='Required field userId is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.domainId)
    value = (value * 31) ^ hash(self.userId)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getUser_result:
  """
  Attributes:
   - success
   - sre
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (apache.airavata.model.sharing.ttypes.User, apache.airavata.model.sharing.ttypes.User.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'sre', (apache.airavata.model.sharing.ttypes.SharingRegistryException, apache.airavata.model.sharing.ttypes.SharingRegistryException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, sre=None,):
    self.success = success
    self.sre = sre

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = apache.airavata.model.sharing.ttypes.User()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.sre = apache.airavata.model.sharing.ttypes.SharingRegistryException()
          self.sre.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getUser_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.sre is not None:
      oprot.writeFieldBegin('sre', TType.STRUCT, 1)
      self.sre.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.sre)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getUsers_args:
  """
  Attributes:
   - domainId
   - offset
   - limit
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'domainId', None, None, ), # 1
    (2, TType.I32, 'offset', None, None, ), # 2
    (3, TType.I32, 'limit', None, None, ), # 3
  )

  def __init__(self, domainId=None, offset=None, limit=None,):
    self.domainId = domainId
    self.offset = offset
    self.limit = limit

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.domainId = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.offset = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.limit = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getUsers_args')
    if self.domainId is not None:
      oprot.writeFieldBegin('domainId', TType.STRING, 1)
      oprot.writeString(self.domainId)
      oprot.writeFieldEnd()
    if self.offset is not None:
      oprot.writeFieldBegin('offset', TType.I32, 2)
      oprot.writeI32(self.offset)
      oprot.writeFieldEnd()
    if self.limit is not None:
      oprot.writeFieldBegin('limit', TType.I32, 3)
      oprot.writeI32(self.limit)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.domainId is None:
      raise TProtocol.TProtocolException(message='Required field domainId is unset!')
    if self.offset is None:
      raise TProtocol.TProtocolException(message='Required field offset is unset!')
    if self.limit is None:
      raise TProtocol.TProtocolException(message='Required field limit is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.domainId)
    value = (value * 31) ^ hash(self.offset)
    value = (value * 31) ^ hash(self.limit)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getUsers_result:
  """
  Attributes:
   - success
   - sre
  """

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT,(apache.airavata.model.sharing.ttypes.User, apache.airavata.model.sharing.ttypes.User.thrift_spec)), None, ), # 0
    (1, TType.STRUCT, 'sre', (apache.airavata.model.sharing.ttypes.SharingRegistryException, apache.airavata.model.sharing.ttypes.SharingRegistryException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, sre=None,):
    self.success = success
    self.sre = sre

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype10, _size7) = iprot.readListBegin()
          for _i11 in xrange(_size7):
            _elem12 = apache.airavata.model.sharing.ttypes.User()
            _elem12.read(iprot)
            self.success.append(_elem12)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.sre = apache.airavata.model.sharing.ttypes.SharingRegistryException()
          self.sre.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getUsers_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.STRUCT, len(self.success))
      for iter13 in self.success:
        iter13.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.sre is not None:
      oprot.writeFieldBegin('sre', TType.STRUCT, 1)
      self.sre.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.sre)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class createGroup_args:
  """
  Attributes:
   - group
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'group', (apache.airavata.model.sharing.ttypes.UserGroup, apache.airavata.model.sharing.ttypes.UserGroup.thrift_spec), None, ), # 1
  )

  def __init__(self, group=None,):
    self.group = group

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.group = apache.airavata.model.sharing.ttypes.UserGroup()
          self.group.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('createGroup_args')
    if self.group is not None:
      oprot.writeFieldBegin('group', TType.STRUCT, 1)
      self.group.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.group is None:
      raise TProtocol.TProtocolException(message='Required field group is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.group)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class createGroup_result:
  """
  Attributes:
   - success
   - sre
  """

  thrift_spec = (
    (0, TType.STRING, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'sre', (apache.airavata.model.sharing.ttypes.SharingRegistryException, apache.airavata.model.sharing.ttypes.SharingRegistryException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, sre=None,):
    self.success = success
    self.sre = sre

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRING:
          self.success = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.sre = apache.airavata.model.sharing.ttypes.SharingRegistryException()
          self.sre.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('createGroup_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRING, 0)
      oprot.writeString(self.success)
      oprot.writeFieldEnd()
    if self.sre is not None:
      oprot.writeFieldBegin('sre', TType.STRUCT, 1)
      self.sre.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.sre)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class updateGroup_args:
  """
  Attributes:
   - group
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'group', (apache.airavata.model.sharing.ttypes.UserGroup, apache.airavata.model.sharing.ttypes.UserGroup.thrift_spec), None, ), # 1
  )

  def __init__(self, group=None,):
    self.group = group

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.group = apache.airavata.model.sharing.ttypes.UserGroup()
          self.group.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('updateGroup_args')
    if self.group is not None:
      oprot.writeFieldBegin('group', TType.STRUCT, 1)
      self.group.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.group is None:
      raise TProtocol.TProtocolException(message='Required field group is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.group)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class updateGroup_result:
  """
  Attributes:
   - success
   - sre
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'sre', (apache.airavata.model.sharing.ttypes.SharingRegistryException, apache.airavata.model.sharing.ttypes.SharingRegistryException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, sre=None,):
    self.success = success
    self.sre = sre

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.sre = apache.airavata.model.sharing.ttypes.SharingRegistryException()
          self.sre.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('updateGroup_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    if self.sre is not None:
      oprot.writeFieldBegin('sre', TType.STRUCT, 1)
      self.sre.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.sre)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class isGroupExists_args:
  """
  Attributes:
   - domainId
   - groupId
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'domainId', None, None, ), # 1
    (2, TType.STRING, 'groupId', None, None, ), # 2
  )

  def __init__(self, domainId=None, groupId=None,):
    self.domainId = domainId
    self.groupId = groupId

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.domainId = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.groupId = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('isGroupExists_args')
    if self.domainId is not None:
      oprot.writeFieldBegin('domainId', TType.STRING, 1)
      oprot.writeString(self.domainId)
      oprot.writeFieldEnd()
    if self.groupId is not None:
      oprot.writeFieldBegin('groupId', TType.STRING, 2)
      oprot.writeString(self.groupId)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.domainId is None:
      raise TProtocol.TProtocolException(message='Required field domainId is unset!')
    if self.groupId is None:
      raise TProtocol.TProtocolException(message='Required field groupId is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.domainId)
    value = (value * 31) ^ hash(self.groupId)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class isGroupExists_result:
  """
  Attributes:
   - success
   - sre
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'sre', (apache.airavata.model.sharing.ttypes.SharingRegistryException, apache.airavata.model.sharing.ttypes.SharingRegistryException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, sre=None,):
    self.success = success
    self.sre = sre

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.sre = apache.airavata.model.sharing.ttypes.SharingRegistryException()
          self.sre.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('isGroupExists_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    if self.sre is not None:
      oprot.writeFieldBegin('sre', TType.STRUCT, 1)
      self.sre.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.sre)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class deleteGroup_args:
  """
  Attributes:
   - domainId
   - groupId
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'domainId', None, None, ), # 1
    (2, TType.STRING, 'groupId', None, None, ), # 2
  )

  def __init__(self, domainId=None, groupId=None,):
    self.domainId = domainId
    self.groupId = groupId

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.domainId = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.groupId = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('deleteGroup_args')
    if self.domainId is not None:
      oprot.writeFieldBegin('domainId', TType.STRING, 1)
      oprot.writeString(self.domainId)
      oprot.writeFieldEnd()
    if self.groupId is not None:
      oprot.writeFieldBegin('groupId', TType.STRING, 2)
      oprot.writeString(self.groupId)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.domainId is None:
      raise TProtocol.TProtocolException(message='Required field domainId is unset!')
    if self.groupId is None:
      raise TProtocol.TProtocolException(message='Required field groupId is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.domainId)
    value = (value * 31) ^ hash(self.groupId)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class deleteGroup_result:
  """
  Attributes:
   - success
   - sre
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'sre', (apache.airavata.model.sharing.ttypes.SharingRegistryException, apache.airavata.model.sharing.ttypes.SharingRegistryException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, sre=None,):
    self.success = success
    self.sre = sre

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.sre = apache.airavata.model.sharing.ttypes.SharingRegistryException()
          self.sre.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('deleteGroup_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    if self.sre is not None:
      oprot.writeFieldBegin('sre', TType.STRUCT, 1)
      self.sre.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.sre)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getGroup_args:
  """
  Attributes:
   - domainId
   - groupId
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'domainId', None, None, ), # 1
    (2, TType.STRING, 'groupId', None, None, ), # 2
  )

  def __init__(self, domainId=None, groupId=None,):
    self.domainId = domainId
    self.groupId = groupId

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.domainId = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.groupId = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getGroup_args')
    if self.domainId is not None:
      oprot.writeFieldBegin('domainId', TType.STRING, 1)
      oprot.writeString(self.domainId)
      oprot.writeFieldEnd()
    if self.groupId is not None:
      oprot.writeFieldBegin('groupId', TType.STRING, 2)
      oprot.writeString(self.groupId)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.domainId is None:
      raise TProtocol.TProtocolException(message='Required field domainId is unset!')
    if self.groupId is None:
      raise TProtocol.TProtocolException(message='Required field groupId is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.domainId)
    value = (value * 31) ^ hash(self.groupId)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getGroup_result:
  """
  Attributes:
   - success
   - sre
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (apache.airavata.model.sharing.ttypes.UserGroup, apache.airavata.model.sharing.ttypes.UserGroup.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'sre', (apache.airavata.model.sharing.ttypes.SharingRegistryException, apache.airavata.model.sharing.ttypes.SharingRegistryException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, sre=None,):
    self.success = success
    self.sre = sre

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = apache.airavata.model.sharing.ttypes.UserGroup()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.sre = apache.airavata.model.sharing.ttypes.SharingRegistryException()
          self.sre.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getGroup_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.sre is not None:
      oprot.writeFieldBegin('sre', TType.STRUCT, 1)
      self.sre.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.sre)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getGroups_args:
  """
  Attributes:
   - domainId
   - offset
   - limit
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'domainId', None, None, ), # 1
    (2, TType.I32, 'offset', None, None, ), # 2
    (3, TType.I32, 'limit', None, None, ), # 3
  )

  def __init__(self, domainId=None, offset=None, limit=None,):
    self.domainId = domainId
    self.offset = offset
    self.limit = limit

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.domainId = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.offset = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.limit = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getGroups_args')
    if self.domainId is not None:
      oprot.writeFieldBegin('domainId', TType.STRING, 1)
      oprot.writeString(self.domainId)
      oprot.writeFieldEnd()
    if self.offset is not None:
      oprot.writeFieldBegin('offset', TType.I32, 2)
      oprot.writeI32(self.offset)
      oprot.writeFieldEnd()
    if self.limit is not None:
      oprot.writeFieldBegin('limit', TType.I32, 3)
      oprot.writeI32(self.limit)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.domainId is None:
      raise TProtocol.TProtocolException(message='Required field domainId is unset!')
    if self.offset is None:
      raise TProtocol.TProtocolException(message='Required field offset is unset!')
    if self.limit is None:
      raise TProtocol.TProtocolException(message='Required field limit is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.domainId)
    value = (value * 31) ^ hash(self.offset)
    value = (value * 31) ^ hash(self.limit)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getGroups_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT,(apache.airavata.model.sharing.ttypes.UserGroup, apache.airavata.model.sharing.ttypes.UserGroup.thrift_spec)), None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype17, _size14) = iprot.readListBegin()
          for _i18 in xrange(_size14):
            _elem19 = apache.airavata.model.sharing.ttypes.UserGroup()
            _elem19.read(iprot)
            self.success.append(_elem19)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getGroups_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.STRUCT, len(self.success))
      for iter20 in self.success:
        iter20.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class addUsersToGroup_args:
  """
  Attributes:
   - domainId
   - userIds
   - groupId
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'domainId', None, None, ), # 1
    (2, TType.LIST, 'userIds', (TType.STRING,None), None, ), # 2
    (3, TType.STRING, 'groupId', None, None, ), # 3
  )

  def __init__(self, domainId=None, userIds=None, groupId=None,):
    self.domainId = domainId
    self.userIds = userIds
    self.groupId = groupId

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.domainId = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.userIds = []
          (_etype24, _size21) = iprot.readListBegin()
          for _i25 in xrange(_size21):
            _elem26 = iprot.readString()
            self.userIds.append(_elem26)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.groupId = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('addUsersToGroup_args')
    if self.domainId is not None:
      oprot.writeFieldBegin('domainId', TType.STRING, 1)
      oprot.writeString(self.domainId)
      oprot.writeFieldEnd()
    if self.userIds is not None:
      oprot.writeFieldBegin('userIds', TType.LIST, 2)
      oprot.writeListBegin(TType.STRING, len(self.userIds))
      for iter27 in self.userIds:
        oprot.writeString(iter27)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.groupId is not None:
      oprot.writeFieldBegin('groupId', TType.STRING, 3)
      oprot.writeString(self.groupId)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.domainId is None:
      raise TProtocol.TProtocolException(message='Required field domainId is unset!')
    if self.userIds is None:
      raise TProtocol.TProtocolException(message='Required field userIds is unset!')
    if self.groupId is None:
      raise TProtocol.TProtocolException(message='Required field groupId is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.domainId)
    value = (value * 31) ^ hash(self.userIds)
    value = (value * 31) ^ hash(self.groupId)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class addUsersToGroup_result:
  """
  Attributes:
   - success
   - sre
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'sre', (apache.airavata.model.sharing.ttypes.SharingRegistryException, apache.airavata.model.sharing.ttypes.SharingRegistryException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, sre=None,):
    self.success = success
    self.sre = sre

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.sre = apache.airavata.model.sharing.ttypes.SharingRegistryException()
          self.sre.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('addUsersToGroup_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    if self.sre is not None:
      oprot.writeFieldBegin('sre', TType.STRUCT, 1)
      self.sre.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.sre)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class removeUsersFromGroup_args:
  """
  Attributes:
   - domainId
   - userIds
   - groupId
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'domainId', None, None, ), # 1
    (2, TType.LIST, 'userIds', (TType.STRING,None), None, ), # 2
    (3, TType.STRING, 'groupId', None, None, ), # 3
  )

  def __init__(self, domainId=None, userIds=None, groupId=None,):
    self.domainId = domainId
    self.userIds = userIds
    self.groupId = groupId

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.domainId = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.userIds = []
          (_etype31, _size28) = iprot.readListBegin()
          for _i32 in xrange(_size28):
            _elem33 = iprot.readString()
            self.userIds.append(_elem33)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.groupId = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('removeUsersFromGroup_args')
    if self.domainId is not None:
      oprot.writeFieldBegin('domainId', TType.STRING, 1)
      oprot.writeString(self.domainId)
      oprot.writeFieldEnd()
    if self.userIds is not None:
      oprot.writeFieldBegin('userIds', TType.LIST, 2)
      oprot.writeListBegin(TType.STRING, len(self.userIds))
      for iter34 in self.userIds:
        oprot.writeString(iter34)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.groupId is not None:
      oprot.writeFieldBegin('groupId', TType.STRING, 3)
      oprot.writeString(self.groupId)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.domainId is None:
      raise TProtocol.TProtocolException(message='Required field domainId is unset!')
    if self.userIds is None:
      raise TProtocol.TProtocolException(message='Required field userIds is unset!')
    if self.groupId is None:
      raise TProtocol.TProtocolException(message='Required field groupId is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.domainId)
    value = (value * 31) ^ hash(self.userIds)
    value = (value * 31) ^ hash(self.groupId)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class removeUsersFromGroup_result:
  """
  Attributes:
   - success
   - sre
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'sre', (apache.airavata.model.sharing.ttypes.SharingRegistryException, apache.airavata.model.sharing.ttypes.SharingRegistryException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, sre=None,):
    self.success = success
    self.sre = sre

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.sre = apache.airavata.model.sharing.ttypes.SharingRegistryException()
          self.sre.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('removeUsersFromGroup_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    if self.sre is not None:
      oprot.writeFieldBegin('sre', TType.STRUCT, 1)
      self.sre.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.sre)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getGroupMembersOfTypeUser_args:
  """
  Attributes:
   - domainId
   - groupId
   - offset
   - limit
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'domainId', None, None, ), # 1
    (2, TType.STRING, 'groupId', None, None, ), # 2
    (3, TType.I32, 'offset', None, None, ), # 3
    (4, TType.I32, 'limit', None, None, ), # 4
  )

  def __init__(self, domainId=None, groupId=None, offset=None, limit=None,):
    self.domainId = domainId
    self.groupId = groupId
    self.offset = offset
    self.limit = limit

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.domainId = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.groupId = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.offset = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.limit = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getGroupMembersOfTypeUser_args')
    if self.domainId is not None:
      oprot.writeFieldBegin('domainId', TType.STRING, 1)
      oprot.writeString(self.domainId)
      oprot.writeFieldEnd()
    if self.groupId is not None:
      oprot.writeFieldBegin('groupId', TType.STRING, 2)
      oprot.writeString(self.groupId)
      oprot.writeFieldEnd()
    if self.offset is not None:
      oprot.writeFieldBegin('offset', TType.I32, 3)
      oprot.writeI32(self.offset)
      oprot.writeFieldEnd()
    if self.limit is not None:
      oprot.writeFieldBegin('limit', TType.I32, 4)
      oprot.writeI32(self.limit)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.groupId is None:
      raise TProtocol.TProtocolException(message='Required field groupId is unset!')
    if self.offset is None:
      raise TProtocol.TProtocolException(message='Required field offset is unset!')
    if self.limit is None:
      raise TProtocol.TProtocolException(message='Required field limit is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.domainId)
    value = (value * 31) ^ hash(self.groupId)
    value = (value * 31) ^ hash(self.offset)
    value = (value * 31) ^ hash(self.limit)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getGroupMembersOfTypeUser_result:
  """
  Attributes:
   - success
   - sre
  """

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT,(apache.airavata.model.sharing.ttypes.User, apache.airavata.model.sharing.ttypes.User.thrift_spec)), None, ), # 0
    (1, TType.STRUCT, 'sre', (apache.airavata.model.sharing.ttypes.SharingRegistryException, apache.airavata.model.sharing.ttypes.SharingRegistryException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, sre=None,):
    self.success = success
    self.sre = sre

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype38, _size35) = iprot.readListBegin()
          for _i39 in xrange(_size35):
            _elem40 = apache.airavata.model.sharing.ttypes.User()
            _elem40.read(iprot)
            self.success.append(_elem40)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.sre = apache.airavata.model.sharing.ttypes.SharingRegistryException()
          self.sre.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getGroupMembersOfTypeUser_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.STRUCT, len(self.success))
      for iter41 in self.success:
        iter41.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.sre is not None:
      oprot.writeFieldBegin('sre', TType.STRUCT, 1)
      self.sre.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.sre)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getGroupMembersOfTypeGroup_args:
  """
  Attributes:
   - domainId
   - groupId
   - offset
   - limit
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'domainId', None, None, ), # 1
    (2, TType.STRING, 'groupId', None, None, ), # 2
    (3, TType.I32, 'offset', None, None, ), # 3
    (4, TType.I32, 'limit', None, None, ), # 4
  )

  def __init__(self, domainId=None, groupId=None, offset=None, limit=None,):
    self.domainId = domainId
    self.groupId = groupId
    self.offset = offset
    self.limit = limit

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.domainId = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.groupId = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.offset = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.limit = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getGroupMembersOfTypeGroup_args')
    if self.domainId is not None:
      oprot.writeFieldBegin('domainId', TType.STRING, 1)
      oprot.writeString(self.domainId)
      oprot.writeFieldEnd()
    if self.groupId is not None:
      oprot.writeFieldBegin('groupId', TType.STRING, 2)
      oprot.writeString(self.groupId)
      oprot.writeFieldEnd()
    if self.offset is not None:
      oprot.writeFieldBegin('offset', TType.I32, 3)
      oprot.writeI32(self.offset)
      oprot.writeFieldEnd()
    if self.limit is not None:
      oprot.writeFieldBegin('limit', TType.I32, 4)
      oprot.writeI32(self.limit)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.domainId is None:
      raise TProtocol.TProtocolException(message='Required field domainId is unset!')
    if self.groupId is None:
      raise TProtocol.TProtocolException(message='Required field groupId is unset!')
    if self.offset is None:
      raise TProtocol.TProtocolException(message='Required field offset is unset!')
    if self.limit is None:
      raise TProtocol.TProtocolException(message='Required field limit is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.domainId)
    value = (value * 31) ^ hash(self.groupId)
    value = (value * 31) ^ hash(self.offset)
    value = (value * 31) ^ hash(self.limit)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getGroupMembersOfTypeGroup_result:
  """
  Attributes:
   - success
   - sre
  """

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT,(apache.airavata.model.sharing.ttypes.UserGroup, apache.airavata.model.sharing.ttypes.UserGroup.thrift_spec)), None, ), # 0
    (1, TType.STRUCT, 'sre', (apache.airavata.model.sharing.ttypes.SharingRegistryException, apache.airavata.model.sharing.ttypes.SharingRegistryException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, sre=None,):
    self.success = success
    self.sre = sre

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype45, _size42) = iprot.readListBegin()
          for _i46 in xrange(_size42):
            _elem47 = apache.airavata.model.sharing.ttypes.UserGroup()
            _elem47.read(iprot)
            self.success.append(_elem47)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.sre = apache.airavata.model.sharing.ttypes.SharingRegistryException()
          self.sre.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getGroupMembersOfTypeGroup_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.STRUCT, len(self.success))
      for iter48 in self.success:
        iter48.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.sre is not None:
      oprot.writeFieldBegin('sre', TType.STRUCT, 1)
      self.sre.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.sre)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class addChildGroupsToParentGroup_args:
  """
  Attributes:
   - domainId
   - childIds
   - groupId
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'domainId', None, None, ), # 1
    (2, TType.LIST, 'childIds', (TType.STRING,None), None, ), # 2
    (3, TType.STRING, 'groupId', None, None, ), # 3
  )

  def __init__(self, domainId=None, childIds=None, groupId=None,):
    self.domainId = domainId
    self.childIds = childIds
    self.groupId = groupId

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.domainId = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.childIds = []
          (_etype52, _size49) = iprot.readListBegin()
          for _i53 in xrange(_size49):
            _elem54 = iprot.readString()
            self.childIds.append(_elem54)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.groupId = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('addChildGroupsToParentGroup_args')
    if self.domainId is not None:
      oprot.writeFieldBegin('domainId', TType.STRING, 1)
      oprot.writeString(self.domainId)
      oprot.writeFieldEnd()
    if self.childIds is not None:
      oprot.writeFieldBegin('childIds', TType.LIST, 2)
      oprot.writeListBegin(TType.STRING, len(self.childIds))
      for iter55 in self.childIds:
        oprot.writeString(iter55)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.groupId is not None:
      oprot.writeFieldBegin('groupId', TType.STRING, 3)
      oprot.writeString(self.groupId)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.domainId is None:
      raise TProtocol.TProtocolException(message='Required field domainId is unset!')
    if self.childIds is None:
      raise TProtocol.TProtocolException(message='Required field childIds is unset!')
    if self.groupId is None:
      raise TProtocol.TProtocolException(message='Required field groupId is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.domainId)
    value = (value * 31) ^ hash(self.childIds)
    value = (value * 31) ^ hash(self.groupId)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class addChildGroupsToParentGroup_result:
  """
  Attributes:
   - success
   - sre
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'sre', (apache.airavata.model.sharing.ttypes.SharingRegistryException, apache.airavata.model.sharing.ttypes.SharingRegistryException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, sre=None,):
    self.success = success
    self.sre = sre

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.sre = apache.airavata.model.sharing.ttypes.SharingRegistryException()
          self.sre.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('addChildGroupsToParentGroup_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    if self.sre is not None:
      oprot.writeFieldBegin('sre', TType.STRUCT, 1)
      self.sre.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.sre)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class removeChildGroupFromParentGroup_args:
  """
  Attributes:
   - domainId
   - childId
   - groupId
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'domainId', None, None, ), # 1
    (2, TType.STRING, 'childId', None, None, ), # 2
    (3, TType.STRING, 'groupId', None, None, ), # 3
  )

  def __init__(self, domainId=None, childId=None, groupId=None,):
    self.domainId = domainId
    self.childId = childId
    self.groupId = groupId

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.domainId = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.childId = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.groupId = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('removeChildGroupFromParentGroup_args')
    if self.domainId is not None:
      oprot.writeFieldBegin('domainId', TType.STRING, 1)
      oprot.writeString(self.domainId)
      oprot.writeFieldEnd()
    if self.childId is not None:
      oprot.writeFieldBegin('childId', TType.STRING, 2)
      oprot.writeString(self.childId)
      oprot.writeFieldEnd()
    if self.groupId is not None:
      oprot.writeFieldBegin('groupId', TType.STRING, 3)
      oprot.writeString(self.groupId)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.domainId is None:
      raise TProtocol.TProtocolException(message='Required field domainId is unset!')
    if self.childId is None:
      raise TProtocol.TProtocolException(message='Required field childId is unset!')
    if self.groupId is None:
      raise TProtocol.TProtocolException(message='Required field groupId is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.domainId)
    value = (value * 31) ^ hash(self.childId)
    value = (value * 31) ^ hash(self.groupId)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class removeChildGroupFromParentGroup_result:
  """
  Attributes:
   - success
   - sre
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'sre', (apache.airavata.model.sharing.ttypes.SharingRegistryException, apache.airavata.model.sharing.ttypes.SharingRegistryException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, sre=None,):
    self.success = success
    self.sre = sre

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.sre = apache.airavata.model.sharing.ttypes.SharingRegistryException()
          self.sre.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('removeChildGroupFromParentGroup_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    if self.sre is not None:
      oprot.writeFieldBegin('sre', TType.STRUCT, 1)
      self.sre.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.sre)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getAllMemberGroupsForUser_args:
  """
  Attributes:
   - domainId
   - userId
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'domainId', None, None, ), # 1
    (2, TType.STRING, 'userId', None, None, ), # 2
  )

  def __init__(self, domainId=None, userId=None,):
    self.domainId = domainId
    self.userId = userId

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.domainId = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.userId = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getAllMemberGroupsForUser_args')
    if self.domainId is not None:
      oprot.writeFieldBegin('domainId', TType.STRING, 1)
      oprot.writeString(self.domainId)
      oprot.writeFieldEnd()
    if self.userId is not None:
      oprot.writeFieldBegin('userId', TType.STRING, 2)
      oprot.writeString(self.userId)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.domainId is None:
      raise TProtocol.TProtocolException(message='Required field domainId is unset!')
    if self.userId is None:
      raise TProtocol.TProtocolException(message='Required field userId is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.domainId)
    value = (value * 31) ^ hash(self.userId)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getAllMemberGroupsForUser_result:
  """
  Attributes:
   - success
   - sre
  """

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT,(apache.airavata.model.sharing.ttypes.UserGroup, apache.airavata.model.sharing.ttypes.UserGroup.thrift_spec)), None, ), # 0
    (1, TType.STRUCT, 'sre', (apache.airavata.model.sharing.ttypes.SharingRegistryException, apache.airavata.model.sharing.ttypes.SharingRegistryException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, sre=None,):
    self.success = success
    self.sre = sre

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype59, _size56) = iprot.readListBegin()
          for _i60 in xrange(_size56):
            _elem61 = apache.airavata.model.sharing.ttypes.UserGroup()
            _elem61.read(iprot)
            self.success.append(_elem61)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.sre = apache.airavata.model.sharing.ttypes.SharingRegistryException()
          self.sre.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getAllMemberGroupsForUser_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.STRUCT, len(self.success))
      for iter62 in self.success:
        iter62.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.sre is not None:
      oprot.writeFieldBegin('sre', TType.STRUCT, 1)
      self.sre.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.sre)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class createEntityType_args:
  """
  Attributes:
   - entityType
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'entityType', (apache.airavata.model.sharing.ttypes.EntityType, apache.airavata.model.sharing.ttypes.EntityType.thrift_spec), None, ), # 1
  )

  def __init__(self, entityType=None,):
    self.entityType = entityType

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.entityType = apache.airavata.model.sharing.ttypes.EntityType()
          self.entityType.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('createEntityType_args')
    if self.entityType is not None:
      oprot.writeFieldBegin('entityType', TType.STRUCT, 1)
      self.entityType.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.entityType is None:
      raise TProtocol.TProtocolException(message='Required field entityType is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.entityType)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class createEntityType_result:
  """
  Attributes:
   - success
   - sre
   - dee
  """

  thrift_spec = (
    (0, TType.STRING, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'sre', (apache.airavata.model.sharing.ttypes.SharingRegistryException, apache.airavata.model.sharing.ttypes.SharingRegistryException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'dee', (apache.airavata.model.sharing.ttypes.DuplicateEntryException, apache.airavata.model.sharing.ttypes.DuplicateEntryException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, sre=None, dee=None,):
    self.success = success
    self.sre = sre
    self.dee = dee

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRING:
          self.success = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.sre = apache.airavata.model.sharing.ttypes.SharingRegistryException()
          self.sre.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.dee = apache.airavata.model.sharing.ttypes.DuplicateEntryException()
          self.dee.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('createEntityType_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRING, 0)
      oprot.writeString(self.success)
      oprot.writeFieldEnd()
    if self.sre is not None:
      oprot.writeFieldBegin('sre', TType.STRUCT, 1)
      self.sre.write(oprot)
      oprot.writeFieldEnd()
    if self.dee is not None:
      oprot.writeFieldBegin('dee', TType.STRUCT, 2)
      self.dee.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.sre)
    value = (value * 31) ^ hash(self.dee)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class updateEntityType_args:
  """
  Attributes:
   - entityType
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'entityType', (apache.airavata.model.sharing.ttypes.EntityType, apache.airavata.model.sharing.ttypes.EntityType.thrift_spec), None, ), # 1
  )

  def __init__(self, entityType=None,):
    self.entityType = entityType

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.entityType = apache.airavata.model.sharing.ttypes.EntityType()
          self.entityType.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('updateEntityType_args')
    if self.entityType is not None:
      oprot.writeFieldBegin('entityType', TType.STRUCT, 1)
      self.entityType.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.entityType is None:
      raise TProtocol.TProtocolException(message='Required field entityType is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.entityType)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class updateEntityType_result:
  """
  Attributes:
   - success
   - sre
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'sre', (apache.airavata.model.sharing.ttypes.SharingRegistryException, apache.airavata.model.sharing.ttypes.SharingRegistryException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, sre=None,):
    self.success = success
    self.sre = sre

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.sre = apache.airavata.model.sharing.ttypes.SharingRegistryException()
          self.sre.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('updateEntityType_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    if self.sre is not None:
      oprot.writeFieldBegin('sre', TType.STRUCT, 1)
      self.sre.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.sre)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class isEntityTypeExists_args:
  """
  Attributes:
   - domainId
   - entityTypeId
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'domainId', None, None, ), # 1
    (2, TType.STRING, 'entityTypeId', None, None, ), # 2
  )

  def __init__(self, domainId=None, entityTypeId=None,):
    self.domainId = domainId
    self.entityTypeId = entityTypeId

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.domainId = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.entityTypeId = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('isEntityTypeExists_args')
    if self.domainId is not None:
      oprot.writeFieldBegin('domainId', TType.STRING, 1)
      oprot.writeString(self.domainId)
      oprot.writeFieldEnd()
    if self.entityTypeId is not None:
      oprot.writeFieldBegin('entityTypeId', TType.STRING, 2)
      oprot.writeString(self.entityTypeId)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.domainId is None:
      raise TProtocol.TProtocolException(message='Required field domainId is unset!')
    if self.entityTypeId is None:
      raise TProtocol.TProtocolException(message='Required field entityTypeId is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.domainId)
    value = (value * 31) ^ hash(self.entityTypeId)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class isEntityTypeExists_result:
  """
  Attributes:
   - success
   - sre
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'sre', (apache.airavata.model.sharing.ttypes.SharingRegistryException, apache.airavata.model.sharing.ttypes.SharingRegistryException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, sre=None,):
    self.success = success
    self.sre = sre

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.sre = apache.airavata.model.sharing.ttypes.SharingRegistryException()
          self.sre.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('isEntityTypeExists_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    if self.sre is not None:
      oprot.writeFieldBegin('sre', TType.STRUCT, 1)
      self.sre.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.sre)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class deleteEntityType_args:
  """
  Attributes:
   - domainId
   - entityTypeId
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'domainId', None, None, ), # 1
    (2, TType.STRING, 'entityTypeId', None, None, ), # 2
  )

  def __init__(self, domainId=None, entityTypeId=None,):
    self.domainId = domainId
    self.entityTypeId = entityTypeId

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.domainId = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.entityTypeId = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('deleteEntityType_args')
    if self.domainId is not None:
      oprot.writeFieldBegin('domainId', TType.STRING, 1)
      oprot.writeString(self.domainId)
      oprot.writeFieldEnd()
    if self.entityTypeId is not None:
      oprot.writeFieldBegin('entityTypeId', TType.STRING, 2)
      oprot.writeString(self.entityTypeId)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.domainId is None:
      raise TProtocol.TProtocolException(message='Required field domainId is unset!')
    if self.entityTypeId is None:
      raise TProtocol.TProtocolException(message='Required field entityTypeId is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.domainId)
    value = (value * 31) ^ hash(self.entityTypeId)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class deleteEntityType_result:
  """
  Attributes:
   - success
   - sre
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'sre', (apache.airavata.model.sharing.ttypes.SharingRegistryException, apache.airavata.model.sharing.ttypes.SharingRegistryException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, sre=None,):
    self.success = success
    self.sre = sre

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.sre = apache.airavata.model.sharing.ttypes.SharingRegistryException()
          self.sre.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('deleteEntityType_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    if self.sre is not None:
      oprot.writeFieldBegin('sre', TType.STRUCT, 1)
      self.sre.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.sre)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getEntityType_args:
  """
  Attributes:
   - domainId
   - entityTypeId
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'domainId', None, None, ), # 1
    (2, TType.STRING, 'entityTypeId', None, None, ), # 2
  )

  def __init__(self, domainId=None, entityTypeId=None,):
    self.domainId = domainId
    self.entityTypeId = entityTypeId

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.domainId = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.entityTypeId = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getEntityType_args')
    if self.domainId is not None:
      oprot.writeFieldBegin('domainId', TType.STRING, 1)
      oprot.writeString(self.domainId)
      oprot.writeFieldEnd()
    if self.entityTypeId is not None:
      oprot.writeFieldBegin('entityTypeId', TType.STRING, 2)
      oprot.writeString(self.entityTypeId)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.domainId is None:
      raise TProtocol.TProtocolException(message='Required field domainId is unset!')
    if self.entityTypeId is None:
      raise TProtocol.TProtocolException(message='Required field entityTypeId is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.domainId)
    value = (value * 31) ^ hash(self.entityTypeId)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getEntityType_result:
  """
  Attributes:
   - success
   - sre
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (apache.airavata.model.sharing.ttypes.EntityType, apache.airavata.model.sharing.ttypes.EntityType.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'sre', (apache.airavata.model.sharing.ttypes.SharingRegistryException, apache.airavata.model.sharing.ttypes.SharingRegistryException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, sre=None,):
    self.success = success
    self.sre = sre

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = apache.airavata.model.sharing.ttypes.EntityType()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.sre = apache.airavata.model.sharing.ttypes.SharingRegistryException()
          self.sre.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getEntityType_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.sre is not None:
      oprot.writeFieldBegin('sre', TType.STRUCT, 1)
      self.sre.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.sre)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getEntityTypes_args:
  """
  Attributes:
   - domainId
   - offset
   - limit
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'domainId', None, None, ), # 1
    (2, TType.I32, 'offset', None, None, ), # 2
    (3, TType.I32, 'limit', None, None, ), # 3
  )

  def __init__(self, domainId=None, offset=None, limit=None,):
    self.domainId = domainId
    self.offset = offset
    self.limit = limit

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.domainId = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.offset = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.limit = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getEntityTypes_args')
    if self.domainId is not None:
      oprot.writeFieldBegin('domainId', TType.STRING, 1)
      oprot.writeString(self.domainId)
      oprot.writeFieldEnd()
    if self.offset is not None:
      oprot.writeFieldBegin('offset', TType.I32, 2)
      oprot.writeI32(self.offset)
      oprot.writeFieldEnd()
    if self.limit is not None:
      oprot.writeFieldBegin('limit', TType.I32, 3)
      oprot.writeI32(self.limit)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.domainId is None:
      raise TProtocol.TProtocolException(message='Required field domainId is unset!')
    if self.offset is None:
      raise TProtocol.TProtocolException(message='Required field offset is unset!')
    if self.limit is None:
      raise TProtocol.TProtocolException(message='Required field limit is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.domainId)
    value = (value * 31) ^ hash(self.offset)
    value = (value * 31) ^ hash(self.limit)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getEntityTypes_result:
  """
  Attributes:
   - success
   - sre
  """

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT,(apache.airavata.model.sharing.ttypes.EntityType, apache.airavata.model.sharing.ttypes.EntityType.thrift_spec)), None, ), # 0
    (1, TType.STRUCT, 'sre', (apache.airavata.model.sharing.ttypes.SharingRegistryException, apache.airavata.model.sharing.ttypes.SharingRegistryException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, sre=None,):
    self.success = success
    self.sre = sre

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype66, _size63) = iprot.readListBegin()
          for _i67 in xrange(_size63):
            _elem68 = apache.airavata.model.sharing.ttypes.EntityType()
            _elem68.read(iprot)
            self.success.append(_elem68)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.sre = apache.airavata.model.sharing.ttypes.SharingRegistryException()
          self.sre.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getEntityTypes_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.STRUCT, len(self.success))
      for iter69 in self.success:
        iter69.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.sre is not None:
      oprot.writeFieldBegin('sre', TType.STRUCT, 1)
      self.sre.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.sre)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class createEntity_args:
  """
  Attributes:
   - entity
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'entity', (apache.airavata.model.sharing.ttypes.Entity, apache.airavata.model.sharing.ttypes.Entity.thrift_spec), None, ), # 1
  )

  def __init__(self, entity=None,):
    self.entity = entity

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.entity = apache.airavata.model.sharing.ttypes.Entity()
          self.entity.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('createEntity_args')
    if self.entity is not None:
      oprot.writeFieldBegin('entity', TType.STRUCT, 1)
      self.entity.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.entity is None:
      raise TProtocol.TProtocolException(message='Required field entity is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.entity)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class createEntity_result:
  """
  Attributes:
   - success
   - sre
  """

  thrift_spec = (
    (0, TType.STRING, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'sre', (apache.airavata.model.sharing.ttypes.SharingRegistryException, apache.airavata.model.sharing.ttypes.SharingRegistryException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, sre=None,):
    self.success = success
    self.sre = sre

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRING:
          self.success = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.sre = apache.airavata.model.sharing.ttypes.SharingRegistryException()
          self.sre.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('createEntity_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRING, 0)
      oprot.writeString(self.success)
      oprot.writeFieldEnd()
    if self.sre is not None:
      oprot.writeFieldBegin('sre', TType.STRUCT, 1)
      self.sre.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.sre)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class updateEntity_args:
  """
  Attributes:
   - entity
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'entity', (apache.airavata.model.sharing.ttypes.Entity, apache.airavata.model.sharing.ttypes.Entity.thrift_spec), None, ), # 1
  )

  def __init__(self, entity=None,):
    self.entity = entity

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.entity = apache.airavata.model.sharing.ttypes.Entity()
          self.entity.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('updateEntity_args')
    if self.entity is not None:
      oprot.writeFieldBegin('entity', TType.STRUCT, 1)
      self.entity.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.entity is None:
      raise TProtocol.TProtocolException(message='Required field entity is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.entity)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class updateEntity_result:
  """
  Attributes:
   - success
   - sre
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'sre', (apache.airavata.model.sharing.ttypes.SharingRegistryException, apache.airavata.model.sharing.ttypes.SharingRegistryException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, sre=None,):
    self.success = success
    self.sre = sre

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.sre = apache.airavata.model.sharing.ttypes.SharingRegistryException()
          self.sre.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('updateEntity_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    if self.sre is not None:
      oprot.writeFieldBegin('sre', TType.STRUCT, 1)
      self.sre.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.sre)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class isEntityExists_args:
  """
  Attributes:
   - domainId
   - entityId
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'domainId', None, None, ), # 1
    (2, TType.STRING, 'entityId', None, None, ), # 2
  )

  def __init__(self, domainId=None, entityId=None,):
    self.domainId = domainId
    self.entityId = entityId

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.domainId = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.entityId = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('isEntityExists_args')
    if self.domainId is not None:
      oprot.writeFieldBegin('domainId', TType.STRING, 1)
      oprot.writeString(self.domainId)
      oprot.writeFieldEnd()
    if self.entityId is not None:
      oprot.writeFieldBegin('entityId', TType.STRING, 2)
      oprot.writeString(self.entityId)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.domainId is None:
      raise TProtocol.TProtocolException(message='Required field domainId is unset!')
    if self.entityId is None:
      raise TProtocol.TProtocolException(message='Required field entityId is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.domainId)
    value = (value * 31) ^ hash(self.entityId)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class isEntityExists_result:
  """
  Attributes:
   - success
   - sre
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'sre', (apache.airavata.model.sharing.ttypes.SharingRegistryException, apache.airavata.model.sharing.ttypes.SharingRegistryException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, sre=None,):
    self.success = success
    self.sre = sre

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.sre = apache.airavata.model.sharing.ttypes.SharingRegistryException()
          self.sre.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('isEntityExists_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    if self.sre is not None:
      oprot.writeFieldBegin('sre', TType.STRUCT, 1)
      self.sre.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.sre)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class deleteEntity_args:
  """
  Attributes:
   - domainId
   - entityId
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'domainId', None, None, ), # 1
    (2, TType.STRING, 'entityId', None, None, ), # 2
  )

  def __init__(self, domainId=None, entityId=None,):
    self.domainId = domainId
    self.entityId = entityId

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.domainId = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.entityId = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('deleteEntity_args')
    if self.domainId is not None:
      oprot.writeFieldBegin('domainId', TType.STRING, 1)
      oprot.writeString(self.domainId)
      oprot.writeFieldEnd()
    if self.entityId is not None:
      oprot.writeFieldBegin('entityId', TType.STRING, 2)
      oprot.writeString(self.entityId)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.domainId is None:
      raise TProtocol.TProtocolException(message='Required field domainId is unset!')
    if self.entityId is None:
      raise TProtocol.TProtocolException(message='Required field entityId is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.domainId)
    value = (value * 31) ^ hash(self.entityId)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class deleteEntity_result:
  """
  Attributes:
   - success
   - sre
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'sre', (apache.airavata.model.sharing.ttypes.SharingRegistryException, apache.airavata.model.sharing.ttypes.SharingRegistryException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, sre=None,):
    self.success = success
    self.sre = sre

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.sre = apache.airavata.model.sharing.ttypes.SharingRegistryException()
          self.sre.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('deleteEntity_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    if self.sre is not None:
      oprot.writeFieldBegin('sre', TType.STRUCT, 1)
      self.sre.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.sre)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getEntity_args:
  """
  Attributes:
   - domainId
   - entityId
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'domainId', None, None, ), # 1
    (2, TType.STRING, 'entityId', None, None, ), # 2
  )

  def __init__(self, domainId=None, entityId=None,):
    self.domainId = domainId
    self.entityId = entityId

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.domainId = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.entityId = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getEntity_args')
    if self.domainId is not None:
      oprot.writeFieldBegin('domainId', TType.STRING, 1)
      oprot.writeString(self.domainId)
      oprot.writeFieldEnd()
    if self.entityId is not None:
      oprot.writeFieldBegin('entityId', TType.STRING, 2)
      oprot.writeString(self.entityId)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.domainId is None:
      raise TProtocol.TProtocolException(message='Required field domainId is unset!')
    if self.entityId is None:
      raise TProtocol.TProtocolException(message='Required field entityId is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.domainId)
    value = (value * 31) ^ hash(self.entityId)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getEntity_result:
  """
  Attributes:
   - success
   - sre
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (apache.airavata.model.sharing.ttypes.Entity, apache.airavata.model.sharing.ttypes.Entity.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'sre', (apache.airavata.model.sharing.ttypes.SharingRegistryException, apache.airavata.model.sharing.ttypes.SharingRegistryException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, sre=None,):
    self.success = success
    self.sre = sre

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = apache.airavata.model.sharing.ttypes.Entity()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.sre = apache.airavata.model.sharing.ttypes.SharingRegistryException()
          self.sre.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getEntity_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.sre is not None:
      oprot.writeFieldBegin('sre', TType.STRUCT, 1)
      self.sre.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.sre)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class searchEntities_args:
  """
  Attributes:
   - domainId
   - userId
   - filters
   - offset
   - limit
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'domainId', None, None, ), # 1
    (2, TType.STRING, 'userId', None, None, ), # 2
    (3, TType.LIST, 'filters', (TType.STRUCT,(apache.airavata.model.sharing.ttypes.SearchCriteria, apache.airavata.model.sharing.ttypes.SearchCriteria.thrift_spec)), None, ), # 3
    (4, TType.I32, 'offset', None, None, ), # 4
    (5, TType.I32, 'limit', None, None, ), # 5
  )

  def __init__(self, domainId=None, userId=None, filters=None, offset=None, limit=None,):
    self.domainId = domainId
    self.userId = userId
    self.filters = filters
    self.offset = offset
    self.limit = limit

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.domainId = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.userId = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.filters = []
          (_etype73, _size70) = iprot.readListBegin()
          for _i74 in xrange(_size70):
            _elem75 = apache.airavata.model.sharing.ttypes.SearchCriteria()
            _elem75.read(iprot)
            self.filters.append(_elem75)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.offset = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.I32:
          self.limit = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('searchEntities_args')
    if self.domainId is not None:
      oprot.writeFieldBegin('domainId', TType.STRING, 1)
      oprot.writeString(self.domainId)
      oprot.writeFieldEnd()
    if self.userId is not None:
      oprot.writeFieldBegin('userId', TType.STRING, 2)
      oprot.writeString(self.userId)
      oprot.writeFieldEnd()
    if self.filters is not None:
      oprot.writeFieldBegin('filters', TType.LIST, 3)
      oprot.writeListBegin(TType.STRUCT, len(self.filters))
      for iter76 in self.filters:
        iter76.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.offset is not None:
      oprot.writeFieldBegin('offset', TType.I32, 4)
      oprot.writeI32(self.offset)
      oprot.writeFieldEnd()
    if self.limit is not None:
      oprot.writeFieldBegin('limit', TType.I32, 5)
      oprot.writeI32(self.limit)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.domainId is None:
      raise TProtocol.TProtocolException(message='Required field domainId is unset!')
    if self.userId is None:
      raise TProtocol.TProtocolException(message='Required field userId is unset!')
    if self.filters is None:
      raise TProtocol.TProtocolException(message='Required field filters is unset!')
    if self.offset is None:
      raise TProtocol.TProtocolException(message='Required field offset is unset!')
    if self.limit is None:
      raise TProtocol.TProtocolException(message='Required field limit is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.domainId)
    value = (value * 31) ^ hash(self.userId)
    value = (value * 31) ^ hash(self.filters)
    value = (value * 31) ^ hash(self.offset)
    value = (value * 31) ^ hash(self.limit)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class searchEntities_result:
  """
  Attributes:
   - success
   - sre
  """

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT,(apache.airavata.model.sharing.ttypes.Entity, apache.airavata.model.sharing.ttypes.Entity.thrift_spec)), None, ), # 0
    (1, TType.STRUCT, 'sre', (apache.airavata.model.sharing.ttypes.SharingRegistryException, apache.airavata.model.sharing.ttypes.SharingRegistryException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, sre=None,):
    self.success = success
    self.sre = sre

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype80, _size77) = iprot.readListBegin()
          for _i81 in xrange(_size77):
            _elem82 = apache.airavata.model.sharing.ttypes.Entity()
            _elem82.read(iprot)
            self.success.append(_elem82)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.sre = apache.airavata.model.sharing.ttypes.SharingRegistryException()
          self.sre.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('searchEntities_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.STRUCT, len(self.success))
      for iter83 in self.success:
        iter83.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.sre is not None:
      oprot.writeFieldBegin('sre', TType.STRUCT, 1)
      self.sre.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.sre)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getListOfSharedUsers_args:
  """
  Attributes:
   - domainId
   - entityId
   - permissionTypeId
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'domainId', None, None, ), # 1
    (2, TType.STRING, 'entityId', None, None, ), # 2
    (3, TType.STRING, 'permissionTypeId', None, None, ), # 3
  )

  def __init__(self, domainId=None, entityId=None, permissionTypeId=None,):
    self.domainId = domainId
    self.entityId = entityId
    self.permissionTypeId = permissionTypeId

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.domainId = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.entityId = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.permissionTypeId = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getListOfSharedUsers_args')
    if self.domainId is not None:
      oprot.writeFieldBegin('domainId', TType.STRING, 1)
      oprot.writeString(self.domainId)
      oprot.writeFieldEnd()
    if self.entityId is not None:
      oprot.writeFieldBegin('entityId', TType.STRING, 2)
      oprot.writeString(self.entityId)
      oprot.writeFieldEnd()
    if self.permissionTypeId is not None:
      oprot.writeFieldBegin('permissionTypeId', TType.STRING, 3)
      oprot.writeString(self.permissionTypeId)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.domainId is None:
      raise TProtocol.TProtocolException(message='Required field domainId is unset!')
    if self.entityId is None:
      raise TProtocol.TProtocolException(message='Required field entityId is unset!')
    if self.permissionTypeId is None:
      raise TProtocol.TProtocolException(message='Required field permissionTypeId is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.domainId)
    value = (value * 31) ^ hash(self.entityId)
    value = (value * 31) ^ hash(self.permissionTypeId)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getListOfSharedUsers_result:
  """
  Attributes:
   - success
   - sre
  """

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT,(apache.airavata.model.sharing.ttypes.User, apache.airavata.model.sharing.ttypes.User.thrift_spec)), None, ), # 0
    (1, TType.STRUCT, 'sre', (apache.airavata.model.sharing.ttypes.SharingRegistryException, apache.airavata.model.sharing.ttypes.SharingRegistryException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, sre=None,):
    self.success = success
    self.sre = sre

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype87, _size84) = iprot.readListBegin()
          for _i88 in xrange(_size84):
            _elem89 = apache.airavata.model.sharing.ttypes.User()
            _elem89.read(iprot)
            self.success.append(_elem89)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.sre = apache.airavata.model.sharing.ttypes.SharingRegistryException()
          self.sre.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getListOfSharedUsers_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.STRUCT, len(self.success))
      for iter90 in self.success:
        iter90.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.sre is not None:
      oprot.writeFieldBegin('sre', TType.STRUCT, 1)
      self.sre.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.sre)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getListOfSharedGroups_args:
  """
  Attributes:
   - domainId
   - entityId
   - permissionTypeId
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'domainId', None, None, ), # 1
    (2, TType.STRING, 'entityId', None, None, ), # 2
    (3, TType.STRING, 'permissionTypeId', None, None, ), # 3
  )

  def __init__(self, domainId=None, entityId=None, permissionTypeId=None,):
    self.domainId = domainId
    self.entityId = entityId
    self.permissionTypeId = permissionTypeId

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.domainId = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.entityId = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.permissionTypeId = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getListOfSharedGroups_args')
    if self.domainId is not None:
      oprot.writeFieldBegin('domainId', TType.STRING, 1)
      oprot.writeString(self.domainId)
      oprot.writeFieldEnd()
    if self.entityId is not None:
      oprot.writeFieldBegin('entityId', TType.STRING, 2)
      oprot.writeString(self.entityId)
      oprot.writeFieldEnd()
    if self.permissionTypeId is not None:
      oprot.writeFieldBegin('permissionTypeId', TType.STRING, 3)
      oprot.writeString(self.permissionTypeId)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.domainId is None:
      raise TProtocol.TProtocolException(message='Required field domainId is unset!')
    if self.entityId is None:
      raise TProtocol.TProtocolException(message='Required field entityId is unset!')
    if self.permissionTypeId is None:
      raise TProtocol.TProtocolException(message='Required field permissionTypeId is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.domainId)
    value = (value * 31) ^ hash(self.entityId)
    value = (value * 31) ^ hash(self.permissionTypeId)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getListOfSharedGroups_result:
  """
  Attributes:
   - success
   - sre
  """

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT,(apache.airavata.model.sharing.ttypes.UserGroup, apache.airavata.model.sharing.ttypes.UserGroup.thrift_spec)), None, ), # 0
    (1, TType.STRUCT, 'sre', (apache.airavata.model.sharing.ttypes.SharingRegistryException, apache.airavata.model.sharing.ttypes.SharingRegistryException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, sre=None,):
    self.success = success
    self.sre = sre

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype94, _size91) = iprot.readListBegin()
          for _i95 in xrange(_size91):
            _elem96 = apache.airavata.model.sharing.ttypes.UserGroup()
            _elem96.read(iprot)
            self.success.append(_elem96)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.sre = apache.airavata.model.sharing.ttypes.SharingRegistryException()
          self.sre.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getListOfSharedGroups_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.STRUCT, len(self.success))
      for iter97 in self.success:
        iter97.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.sre is not None:
      oprot.writeFieldBegin('sre', TType.STRUCT, 1)
      self.sre.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.sre)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class createPermissionType_args:
  """
  Attributes:
   - permissionType
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'permissionType', (apache.airavata.model.sharing.ttypes.PermissionType, apache.airavata.model.sharing.ttypes.PermissionType.thrift_spec), None, ), # 1
  )

  def __init__(self, permissionType=None,):
    self.permissionType = permissionType

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.permissionType = apache.airavata.model.sharing.ttypes.PermissionType()
          self.permissionType.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('createPermissionType_args')
    if self.permissionType is not None:
      oprot.writeFieldBegin('permissionType', TType.STRUCT, 1)
      self.permissionType.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.permissionType is None:
      raise TProtocol.TProtocolException(message='Required field permissionType is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.permissionType)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class createPermissionType_result:
  """
  Attributes:
   - success
   - sre
   - dee
  """

  thrift_spec = (
    (0, TType.STRING, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'sre', (apache.airavata.model.sharing.ttypes.SharingRegistryException, apache.airavata.model.sharing.ttypes.SharingRegistryException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'dee', (apache.airavata.model.sharing.ttypes.DuplicateEntryException, apache.airavata.model.sharing.ttypes.DuplicateEntryException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, sre=None, dee=None,):
    self.success = success
    self.sre = sre
    self.dee = dee

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRING:
          self.success = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.sre = apache.airavata.model.sharing.ttypes.SharingRegistryException()
          self.sre.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.dee = apache.airavata.model.sharing.ttypes.DuplicateEntryException()
          self.dee.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('createPermissionType_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRING, 0)
      oprot.writeString(self.success)
      oprot.writeFieldEnd()
    if self.sre is not None:
      oprot.writeFieldBegin('sre', TType.STRUCT, 1)
      self.sre.write(oprot)
      oprot.writeFieldEnd()
    if self.dee is not None:
      oprot.writeFieldBegin('dee', TType.STRUCT, 2)
      self.dee.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.sre)
    value = (value * 31) ^ hash(self.dee)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class updatePermissionType_args:
  """
  Attributes:
   - permissionType
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'permissionType', (apache.airavata.model.sharing.ttypes.PermissionType, apache.airavata.model.sharing.ttypes.PermissionType.thrift_spec), None, ), # 1
  )

  def __init__(self, permissionType=None,):
    self.permissionType = permissionType

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.permissionType = apache.airavata.model.sharing.ttypes.PermissionType()
          self.permissionType.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('updatePermissionType_args')
    if self.permissionType is not None:
      oprot.writeFieldBegin('permissionType', TType.STRUCT, 1)
      self.permissionType.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.permissionType is None:
      raise TProtocol.TProtocolException(message='Required field permissionType is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.permissionType)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class updatePermissionType_result:
  """
  Attributes:
   - success
   - sre
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'sre', (apache.airavata.model.sharing.ttypes.SharingRegistryException, apache.airavata.model.sharing.ttypes.SharingRegistryException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, sre=None,):
    self.success = success
    self.sre = sre

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.sre = apache.airavata.model.sharing.ttypes.SharingRegistryException()
          self.sre.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('updatePermissionType_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    if self.sre is not None:
      oprot.writeFieldBegin('sre', TType.STRUCT, 1)
      self.sre.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.sre)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class isPermissionExists_args:
  """
  Attributes:
   - dimainId
   - permissionId
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'dimainId', None, None, ), # 1
    (2, TType.STRING, 'permissionId', None, None, ), # 2
  )

  def __init__(self, dimainId=None, permissionId=None,):
    self.dimainId = dimainId
    self.permissionId = permissionId

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.dimainId = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.permissionId = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('isPermissionExists_args')
    if self.dimainId is not None:
      oprot.writeFieldBegin('dimainId', TType.STRING, 1)
      oprot.writeString(self.dimainId)
      oprot.writeFieldEnd()
    if self.permissionId is not None:
      oprot.writeFieldBegin('permissionId', TType.STRING, 2)
      oprot.writeString(self.permissionId)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.dimainId is None:
      raise TProtocol.TProtocolException(message='Required field dimainId is unset!')
    if self.permissionId is None:
      raise TProtocol.TProtocolException(message='Required field permissionId is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.dimainId)
    value = (value * 31) ^ hash(self.permissionId)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class isPermissionExists_result:
  """
  Attributes:
   - success
   - sre
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'sre', (apache.airavata.model.sharing.ttypes.SharingRegistryException, apache.airavata.model.sharing.ttypes.SharingRegistryException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, sre=None,):
    self.success = success
    self.sre = sre

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.sre = apache.airavata.model.sharing.ttypes.SharingRegistryException()
          self.sre.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('isPermissionExists_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    if self.sre is not None:
      oprot.writeFieldBegin('sre', TType.STRUCT, 1)
      self.sre.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.sre)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class deletePermissionType_args:
  """
  Attributes:
   - domainId
   - permissionTypeId
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'domainId', None, None, ), # 1
    (2, TType.STRING, 'permissionTypeId', None, None, ), # 2
  )

  def __init__(self, domainId=None, permissionTypeId=None,):
    self.domainId = domainId
    self.permissionTypeId = permissionTypeId

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.domainId = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.permissionTypeId = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('deletePermissionType_args')
    if self.domainId is not None:
      oprot.writeFieldBegin('domainId', TType.STRING, 1)
      oprot.writeString(self.domainId)
      oprot.writeFieldEnd()
    if self.permissionTypeId is not None:
      oprot.writeFieldBegin('permissionTypeId', TType.STRING, 2)
      oprot.writeString(self.permissionTypeId)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.domainId is None:
      raise TProtocol.TProtocolException(message='Required field domainId is unset!')
    if self.permissionTypeId is None:
      raise TProtocol.TProtocolException(message='Required field permissionTypeId is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.domainId)
    value = (value * 31) ^ hash(self.permissionTypeId)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class deletePermissionType_result:
  """
  Attributes:
   - success
   - sre
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'sre', (apache.airavata.model.sharing.ttypes.SharingRegistryException, apache.airavata.model.sharing.ttypes.SharingRegistryException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, sre=None,):
    self.success = success
    self.sre = sre

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.sre = apache.airavata.model.sharing.ttypes.SharingRegistryException()
          self.sre.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('deletePermissionType_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    if self.sre is not None:
      oprot.writeFieldBegin('sre', TType.STRUCT, 1)
      self.sre.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.sre)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getPermissionType_args:
  """
  Attributes:
   - domainId
   - permissionTypeId
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'domainId', None, None, ), # 1
    (2, TType.STRING, 'permissionTypeId', None, None, ), # 2
  )

  def __init__(self, domainId=None, permissionTypeId=None,):
    self.domainId = domainId
    self.permissionTypeId = permissionTypeId

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.domainId = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.permissionTypeId = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getPermissionType_args')
    if self.domainId is not None:
      oprot.writeFieldBegin('domainId', TType.STRING, 1)
      oprot.writeString(self.domainId)
      oprot.writeFieldEnd()
    if self.permissionTypeId is not None:
      oprot.writeFieldBegin('permissionTypeId', TType.STRING, 2)
      oprot.writeString(self.permissionTypeId)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.domainId is None:
      raise TProtocol.TProtocolException(message='Required field domainId is unset!')
    if self.permissionTypeId is None:
      raise TProtocol.TProtocolException(message='Required field permissionTypeId is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.domainId)
    value = (value * 31) ^ hash(self.permissionTypeId)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getPermissionType_result:
  """
  Attributes:
   - success
   - sre
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (apache.airavata.model.sharing.ttypes.PermissionType, apache.airavata.model.sharing.ttypes.PermissionType.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'sre', (apache.airavata.model.sharing.ttypes.SharingRegistryException, apache.airavata.model.sharing.ttypes.SharingRegistryException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, sre=None,):
    self.success = success
    self.sre = sre

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = apache.airavata.model.sharing.ttypes.PermissionType()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.sre = apache.airavata.model.sharing.ttypes.SharingRegistryException()
          self.sre.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getPermissionType_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.sre is not None:
      oprot.writeFieldBegin('sre', TType.STRUCT, 1)
      self.sre.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.sre)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getPermissionTypes_args:
  """
  Attributes:
   - domainId
   - offset
   - limit
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'domainId', None, None, ), # 1
    (2, TType.I32, 'offset', None, None, ), # 2
    (3, TType.I32, 'limit', None, None, ), # 3
  )

  def __init__(self, domainId=None, offset=None, limit=None,):
    self.domainId = domainId
    self.offset = offset
    self.limit = limit

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.domainId = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.offset = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.limit = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getPermissionTypes_args')
    if self.domainId is not None:
      oprot.writeFieldBegin('domainId', TType.STRING, 1)
      oprot.writeString(self.domainId)
      oprot.writeFieldEnd()
    if self.offset is not None:
      oprot.writeFieldBegin('offset', TType.I32, 2)
      oprot.writeI32(self.offset)
      oprot.writeFieldEnd()
    if self.limit is not None:
      oprot.writeFieldBegin('limit', TType.I32, 3)
      oprot.writeI32(self.limit)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.domainId is None:
      raise TProtocol.TProtocolException(message='Required field domainId is unset!')
    if self.offset is None:
      raise TProtocol.TProtocolException(message='Required field offset is unset!')
    if self.limit is None:
      raise TProtocol.TProtocolException(message='Required field limit is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.domainId)
    value = (value * 31) ^ hash(self.offset)
    value = (value * 31) ^ hash(self.limit)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getPermissionTypes_result:
  """
  Attributes:
   - success
   - sre
  """

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT,(apache.airavata.model.sharing.ttypes.PermissionType, apache.airavata.model.sharing.ttypes.PermissionType.thrift_spec)), None, ), # 0
    (1, TType.STRUCT, 'sre', (apache.airavata.model.sharing.ttypes.SharingRegistryException, apache.airavata.model.sharing.ttypes.SharingRegistryException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, sre=None,):
    self.success = success
    self.sre = sre

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype101, _size98) = iprot.readListBegin()
          for _i102 in xrange(_size98):
            _elem103 = apache.airavata.model.sharing.ttypes.PermissionType()
            _elem103.read(iprot)
            self.success.append(_elem103)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.sre = apache.airavata.model.sharing.ttypes.SharingRegistryException()
          self.sre.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getPermissionTypes_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.STRUCT, len(self.success))
      for iter104 in self.success:
        iter104.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.sre is not None:
      oprot.writeFieldBegin('sre', TType.STRUCT, 1)
      self.sre.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.sre)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class shareEntityWithUsers_args:
  """
  Attributes:
   - domainId
   - entityId
   - userList
   - perssionTypeId
   - cascadePermission
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'domainId', None, None, ), # 1
    (2, TType.STRING, 'entityId', None, None, ), # 2
    (3, TType.LIST, 'userList', (TType.STRING,None), None, ), # 3
    (4, TType.STRING, 'perssionTypeId', None, None, ), # 4
    (5, TType.BOOL, 'cascadePermission', None, None, ), # 5
  )

  def __init__(self, domainId=None, entityId=None, userList=None, perssionTypeId=None, cascadePermission=None,):
    self.domainId = domainId
    self.entityId = entityId
    self.userList = userList
    self.perssionTypeId = perssionTypeId
    self.cascadePermission = cascadePermission

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.domainId = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.entityId = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.userList = []
          (_etype108, _size105) = iprot.readListBegin()
          for _i109 in xrange(_size105):
            _elem110 = iprot.readString()
            self.userList.append(_elem110)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.perssionTypeId = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.BOOL:
          self.cascadePermission = iprot.readBool()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('shareEntityWithUsers_args')
    if self.domainId is not None:
      oprot.writeFieldBegin('domainId', TType.STRING, 1)
      oprot.writeString(self.domainId)
      oprot.writeFieldEnd()
    if self.entityId is not None:
      oprot.writeFieldBegin('entityId', TType.STRING, 2)
      oprot.writeString(self.entityId)
      oprot.writeFieldEnd()
    if self.userList is not None:
      oprot.writeFieldBegin('userList', TType.LIST, 3)
      oprot.writeListBegin(TType.STRING, len(self.userList))
      for iter111 in self.userList:
        oprot.writeString(iter111)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.perssionTypeId is not None:
      oprot.writeFieldBegin('perssionTypeId', TType.STRING, 4)
      oprot.writeString(self.perssionTypeId)
      oprot.writeFieldEnd()
    if self.cascadePermission is not None:
      oprot.writeFieldBegin('cascadePermission', TType.BOOL, 5)
      oprot.writeBool(self.cascadePermission)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.domainId is None:
      raise TProtocol.TProtocolException(message='Required field domainId is unset!')
    if self.entityId is None:
      raise TProtocol.TProtocolException(message='Required field entityId is unset!')
    if self.userList is None:
      raise TProtocol.TProtocolException(message='Required field userList is unset!')
    if self.perssionTypeId is None:
      raise TProtocol.TProtocolException(message='Required field perssionTypeId is unset!')
    if self.cascadePermission is None:
      raise TProtocol.TProtocolException(message='Required field cascadePermission is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.domainId)
    value = (value * 31) ^ hash(self.entityId)
    value = (value * 31) ^ hash(self.userList)
    value = (value * 31) ^ hash(self.perssionTypeId)
    value = (value * 31) ^ hash(self.cascadePermission)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class shareEntityWithUsers_result:
  """
  Attributes:
   - success
   - sre
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'sre', (apache.airavata.model.sharing.ttypes.SharingRegistryException, apache.airavata.model.sharing.ttypes.SharingRegistryException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, sre=None,):
    self.success = success
    self.sre = sre

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.sre = apache.airavata.model.sharing.ttypes.SharingRegistryException()
          self.sre.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('shareEntityWithUsers_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    if self.sre is not None:
      oprot.writeFieldBegin('sre', TType.STRUCT, 1)
      self.sre.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.sre)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class revokeEntitySharingFromUsers_args:
  """
  Attributes:
   - domainId
   - entityId
   - userList
   - perssionTypeId
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'domainId', None, None, ), # 1
    (2, TType.STRING, 'entityId', None, None, ), # 2
    (3, TType.LIST, 'userList', (TType.STRING,None), None, ), # 3
    (4, TType.STRING, 'perssionTypeId', None, None, ), # 4
  )

  def __init__(self, domainId=None, entityId=None, userList=None, perssionTypeId=None,):
    self.domainId = domainId
    self.entityId = entityId
    self.userList = userList
    self.perssionTypeId = perssionTypeId

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.domainId = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.entityId = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.userList = []
          (_etype115, _size112) = iprot.readListBegin()
          for _i116 in xrange(_size112):
            _elem117 = iprot.readString()
            self.userList.append(_elem117)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.perssionTypeId = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('revokeEntitySharingFromUsers_args')
    if self.domainId is not None:
      oprot.writeFieldBegin('domainId', TType.STRING, 1)
      oprot.writeString(self.domainId)
      oprot.writeFieldEnd()
    if self.entityId is not None:
      oprot.writeFieldBegin('entityId', TType.STRING, 2)
      oprot.writeString(self.entityId)
      oprot.writeFieldEnd()
    if self.userList is not None:
      oprot.writeFieldBegin('userList', TType.LIST, 3)
      oprot.writeListBegin(TType.STRING, len(self.userList))
      for iter118 in self.userList:
        oprot.writeString(iter118)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.perssionTypeId is not None:
      oprot.writeFieldBegin('perssionTypeId', TType.STRING, 4)
      oprot.writeString(self.perssionTypeId)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.domainId is None:
      raise TProtocol.TProtocolException(message='Required field domainId is unset!')
    if self.entityId is None:
      raise TProtocol.TProtocolException(message='Required field entityId is unset!')
    if self.userList is None:
      raise TProtocol.TProtocolException(message='Required field userList is unset!')
    if self.perssionTypeId is None:
      raise TProtocol.TProtocolException(message='Required field perssionTypeId is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.domainId)
    value = (value * 31) ^ hash(self.entityId)
    value = (value * 31) ^ hash(self.userList)
    value = (value * 31) ^ hash(self.perssionTypeId)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class revokeEntitySharingFromUsers_result:
  """
  Attributes:
   - success
   - sre
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'sre', (apache.airavata.model.sharing.ttypes.SharingRegistryException, apache.airavata.model.sharing.ttypes.SharingRegistryException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, sre=None,):
    self.success = success
    self.sre = sre

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.sre = apache.airavata.model.sharing.ttypes.SharingRegistryException()
          self.sre.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('revokeEntitySharingFromUsers_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    if self.sre is not None:
      oprot.writeFieldBegin('sre', TType.STRUCT, 1)
      self.sre.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.sre)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class shareEntityWithGroups_args:
  """
  Attributes:
   - domainId
   - entityId
   - groupList
   - perssionTypeId
   - cascadePermission
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'domainId', None, None, ), # 1
    (2, TType.STRING, 'entityId', None, None, ), # 2
    (3, TType.LIST, 'groupList', (TType.STRING,None), None, ), # 3
    (4, TType.STRING, 'perssionTypeId', None, None, ), # 4
    (5, TType.BOOL, 'cascadePermission', None, None, ), # 5
  )

  def __init__(self, domainId=None, entityId=None, groupList=None, perssionTypeId=None, cascadePermission=None,):
    self.domainId = domainId
    self.entityId = entityId
    self.groupList = groupList
    self.perssionTypeId = perssionTypeId
    self.cascadePermission = cascadePermission

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.domainId = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.entityId = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.groupList = []
          (_etype122, _size119) = iprot.readListBegin()
          for _i123 in xrange(_size119):
            _elem124 = iprot.readString()
            self.groupList.append(_elem124)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.perssionTypeId = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.BOOL:
          self.cascadePermission = iprot.readBool()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('shareEntityWithGroups_args')
    if self.domainId is not None:
      oprot.writeFieldBegin('domainId', TType.STRING, 1)
      oprot.writeString(self.domainId)
      oprot.writeFieldEnd()
    if self.entityId is not None:
      oprot.writeFieldBegin('entityId', TType.STRING, 2)
      oprot.writeString(self.entityId)
      oprot.writeFieldEnd()
    if self.groupList is not None:
      oprot.writeFieldBegin('groupList', TType.LIST, 3)
      oprot.writeListBegin(TType.STRING, len(self.groupList))
      for iter125 in self.groupList:
        oprot.writeString(iter125)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.perssionTypeId is not None:
      oprot.writeFieldBegin('perssionTypeId', TType.STRING, 4)
      oprot.writeString(self.perssionTypeId)
      oprot.writeFieldEnd()
    if self.cascadePermission is not None:
      oprot.writeFieldBegin('cascadePermission', TType.BOOL, 5)
      oprot.writeBool(self.cascadePermission)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.domainId is None:
      raise TProtocol.TProtocolException(message='Required field domainId is unset!')
    if self.entityId is None:
      raise TProtocol.TProtocolException(message='Required field entityId is unset!')
    if self.groupList is None:
      raise TProtocol.TProtocolException(message='Required field groupList is unset!')
    if self.perssionTypeId is None:
      raise TProtocol.TProtocolException(message='Required field perssionTypeId is unset!')
    if self.cascadePermission is None:
      raise TProtocol.TProtocolException(message='Required field cascadePermission is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.domainId)
    value = (value * 31) ^ hash(self.entityId)
    value = (value * 31) ^ hash(self.groupList)
    value = (value * 31) ^ hash(self.perssionTypeId)
    value = (value * 31) ^ hash(self.cascadePermission)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class shareEntityWithGroups_result:
  """
  Attributes:
   - success
   - sre
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'sre', (apache.airavata.model.sharing.ttypes.SharingRegistryException, apache.airavata.model.sharing.ttypes.SharingRegistryException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, sre=None,):
    self.success = success
    self.sre = sre

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.sre = apache.airavata.model.sharing.ttypes.SharingRegistryException()
          self.sre.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('shareEntityWithGroups_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    if self.sre is not None:
      oprot.writeFieldBegin('sre', TType.STRUCT, 1)
      self.sre.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.sre)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class revokeEntitySharingFromGroups_args:
  """
  Attributes:
   - domainId
   - entityId
   - groupList
   - perssionTypeId
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'domainId', None, None, ), # 1
    (2, TType.STRING, 'entityId', None, None, ), # 2
    (3, TType.LIST, 'groupList', (TType.STRING,None), None, ), # 3
    (4, TType.STRING, 'perssionTypeId', None, None, ), # 4
  )

  def __init__(self, domainId=None, entityId=None, groupList=None, perssionTypeId=None,):
    self.domainId = domainId
    self.entityId = entityId
    self.groupList = groupList
    self.perssionTypeId = perssionTypeId

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.domainId = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.entityId = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.groupList = []
          (_etype129, _size126) = iprot.readListBegin()
          for _i130 in xrange(_size126):
            _elem131 = iprot.readString()
            self.groupList.append(_elem131)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.perssionTypeId = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('revokeEntitySharingFromGroups_args')
    if self.domainId is not None:
      oprot.writeFieldBegin('domainId', TType.STRING, 1)
      oprot.writeString(self.domainId)
      oprot.writeFieldEnd()
    if self.entityId is not None:
      oprot.writeFieldBegin('entityId', TType.STRING, 2)
      oprot.writeString(self.entityId)
      oprot.writeFieldEnd()
    if self.groupList is not None:
      oprot.writeFieldBegin('groupList', TType.LIST, 3)
      oprot.writeListBegin(TType.STRING, len(self.groupList))
      for iter132 in self.groupList:
        oprot.writeString(iter132)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.perssionTypeId is not None:
      oprot.writeFieldBegin('perssionTypeId', TType.STRING, 4)
      oprot.writeString(self.perssionTypeId)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.domainId is None:
      raise TProtocol.TProtocolException(message='Required field domainId is unset!')
    if self.entityId is None:
      raise TProtocol.TProtocolException(message='Required field entityId is unset!')
    if self.groupList is None:
      raise TProtocol.TProtocolException(message='Required field groupList is unset!')
    if self.perssionTypeId is None:
      raise TProtocol.TProtocolException(message='Required field perssionTypeId is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.domainId)
    value = (value * 31) ^ hash(self.entityId)
    value = (value * 31) ^ hash(self.groupList)
    value = (value * 31) ^ hash(self.perssionTypeId)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class revokeEntitySharingFromGroups_result:
  """
  Attributes:
   - success
   - sre
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'sre', (apache.airavata.model.sharing.ttypes.SharingRegistryException, apache.airavata.model.sharing.ttypes.SharingRegistryException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, sre=None,):
    self.success = success
    self.sre = sre

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.sre = apache.airavata.model.sharing.ttypes.SharingRegistryException()
          self.sre.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('revokeEntitySharingFromGroups_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    if self.sre is not None:
      oprot.writeFieldBegin('sre', TType.STRUCT, 1)
      self.sre.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.sre)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class userHasAccess_args:
  """
  Attributes:
   - domainId
   - userId
   - entityId
   - permissionTypeId
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'domainId', None, None, ), # 1
    (2, TType.STRING, 'userId', None, None, ), # 2
    (3, TType.STRING, 'entityId', None, None, ), # 3
    (4, TType.STRING, 'permissionTypeId', None, None, ), # 4
  )

  def __init__(self, domainId=None, userId=None, entityId=None, permissionTypeId=None,):
    self.domainId = domainId
    self.userId = userId
    self.entityId = entityId
    self.permissionTypeId = permissionTypeId

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.domainId = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.userId = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.entityId = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.permissionTypeId = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('userHasAccess_args')
    if self.domainId is not None:
      oprot.writeFieldBegin('domainId', TType.STRING, 1)
      oprot.writeString(self.domainId)
      oprot.writeFieldEnd()
    if self.userId is not None:
      oprot.writeFieldBegin('userId', TType.STRING, 2)
      oprot.writeString(self.userId)
      oprot.writeFieldEnd()
    if self.entityId is not None:
      oprot.writeFieldBegin('entityId', TType.STRING, 3)
      oprot.writeString(self.entityId)
      oprot.writeFieldEnd()
    if self.permissionTypeId is not None:
      oprot.writeFieldBegin('permissionTypeId', TType.STRING, 4)
      oprot.writeString(self.permissionTypeId)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.domainId is None:
      raise TProtocol.TProtocolException(message='Required field domainId is unset!')
    if self.userId is None:
      raise TProtocol.TProtocolException(message='Required field userId is unset!')
    if self.entityId is None:
      raise TProtocol.TProtocolException(message='Required field entityId is unset!')
    if self.permissionTypeId is None:
      raise TProtocol.TProtocolException(message='Required field permissionTypeId is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.domainId)
    value = (value * 31) ^ hash(self.userId)
    value = (value * 31) ^ hash(self.entityId)
    value = (value * 31) ^ hash(self.permissionTypeId)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class userHasAccess_result:
  """
  Attributes:
   - success
   - sre
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'sre', (apache.airavata.model.sharing.ttypes.SharingRegistryException, apache.airavata.model.sharing.ttypes.SharingRegistryException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, sre=None,):
    self.success = success
    self.sre = sre

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.sre = apache.airavata.model.sharing.ttypes.SharingRegistryException()
          self.sre.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('userHasAccess_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    if self.sre is not None:
      oprot.writeFieldBegin('sre', TType.STRUCT, 1)
      self.sre.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.sre)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)
