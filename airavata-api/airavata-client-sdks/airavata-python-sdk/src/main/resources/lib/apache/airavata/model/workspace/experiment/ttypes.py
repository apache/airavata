#
# Autogenerated by Thrift Compiler (0.9.2)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
#  options string: py
#

from thrift.Thrift import TType, TMessageType, TException, TApplicationException
import apache.airavata.model.appcatalog.computeresource.ttypes
import apache.airavata.model.appcatalog.appinterface.ttypes


from thrift.transport import TTransport
from thrift.protocol import TBinaryProtocol, TProtocol
try:
  from thrift.protocol import fastbinary
except:
  fastbinary = None


class ExperimentState:
  CREATED = 0
  VALIDATED = 1
  SCHEDULED = 2
  LAUNCHED = 3
  EXECUTING = 4
  CANCELING = 5
  CANCELED = 6
  SUSPENDED = 7
  COMPLETED = 8
  FAILED = 9
  UNKNOWN = 10

  _VALUES_TO_NAMES = {
    0: "CREATED",
    1: "VALIDATED",
    2: "SCHEDULED",
    3: "LAUNCHED",
    4: "EXECUTING",
    5: "CANCELING",
    6: "CANCELED",
    7: "SUSPENDED",
    8: "COMPLETED",
    9: "FAILED",
    10: "UNKNOWN",
  }

  _NAMES_TO_VALUES = {
    "CREATED": 0,
    "VALIDATED": 1,
    "SCHEDULED": 2,
    "LAUNCHED": 3,
    "EXECUTING": 4,
    "CANCELING": 5,
    "CANCELED": 6,
    "SUSPENDED": 7,
    "COMPLETED": 8,
    "FAILED": 9,
    "UNKNOWN": 10,
  }

class ExperimentSearchFields:
  EXPERIMENT_NAME = 0
  EXPERIMENT_DESC = 1
  APPLICATION_ID = 2
  FROM_DATE = 3
  TO_DATE = 4
  STATUS = 5

  _VALUES_TO_NAMES = {
    0: "EXPERIMENT_NAME",
    1: "EXPERIMENT_DESC",
    2: "APPLICATION_ID",
    3: "FROM_DATE",
    4: "TO_DATE",
    5: "STATUS",
  }

  _NAMES_TO_VALUES = {
    "EXPERIMENT_NAME": 0,
    "EXPERIMENT_DESC": 1,
    "APPLICATION_ID": 2,
    "FROM_DATE": 3,
    "TO_DATE": 4,
    "STATUS": 5,
  }

class WorkflowNodeState:
  INVOKED = 0
  EXECUTING = 1
  CANCELING = 2
  CANCELED = 3
  SUSPENDED = 4
  COMPLETED = 5
  FAILED = 6
  UNKNOWN = 7

  _VALUES_TO_NAMES = {
    0: "INVOKED",
    1: "EXECUTING",
    2: "CANCELING",
    3: "CANCELED",
    4: "SUSPENDED",
    5: "COMPLETED",
    6: "FAILED",
    7: "UNKNOWN",
  }

  _NAMES_TO_VALUES = {
    "INVOKED": 0,
    "EXECUTING": 1,
    "CANCELING": 2,
    "CANCELED": 3,
    "SUSPENDED": 4,
    "COMPLETED": 5,
    "FAILED": 6,
    "UNKNOWN": 7,
  }

class TaskState:
  WAITING = 0
  STARTED = 1
  PRE_PROCESSING = 2
  CONFIGURING_WORKSPACE = 3
  INPUT_DATA_STAGING = 4
  OUTPUT_DATA_STAGING = 5
  POST_PROCESSING = 6
  EXECUTING = 7
  CANCELING = 8
  CANCELED = 9
  COMPLETED = 10
  FAILED = 11
  UNKNOWN = 12

  _VALUES_TO_NAMES = {
    0: "WAITING",
    1: "STARTED",
    2: "PRE_PROCESSING",
    3: "CONFIGURING_WORKSPACE",
    4: "INPUT_DATA_STAGING",
    5: "OUTPUT_DATA_STAGING",
    6: "POST_PROCESSING",
    7: "EXECUTING",
    8: "CANCELING",
    9: "CANCELED",
    10: "COMPLETED",
    11: "FAILED",
    12: "UNKNOWN",
  }

  _NAMES_TO_VALUES = {
    "WAITING": 0,
    "STARTED": 1,
    "PRE_PROCESSING": 2,
    "CONFIGURING_WORKSPACE": 3,
    "INPUT_DATA_STAGING": 4,
    "OUTPUT_DATA_STAGING": 5,
    "POST_PROCESSING": 6,
    "EXECUTING": 7,
    "CANCELING": 8,
    "CANCELED": 9,
    "COMPLETED": 10,
    "FAILED": 11,
    "UNKNOWN": 12,
  }

class JobState:
  SUBMITTED = 0
  UN_SUBMITTED = 1
  SETUP = 2
  QUEUED = 3
  ACTIVE = 4
  COMPLETE = 5
  CANCELING = 6
  CANCELED = 7
  FAILED = 8
  HELD = 9
  SUSPENDED = 10
  UNKNOWN = 11

  _VALUES_TO_NAMES = {
    0: "SUBMITTED",
    1: "UN_SUBMITTED",
    2: "SETUP",
    3: "QUEUED",
    4: "ACTIVE",
    5: "COMPLETE",
    6: "CANCELING",
    7: "CANCELED",
    8: "FAILED",
    9: "HELD",
    10: "SUSPENDED",
    11: "UNKNOWN",
  }

  _NAMES_TO_VALUES = {
    "SUBMITTED": 0,
    "UN_SUBMITTED": 1,
    "SETUP": 2,
    "QUEUED": 3,
    "ACTIVE": 4,
    "COMPLETE": 5,
    "CANCELING": 6,
    "CANCELED": 7,
    "FAILED": 8,
    "HELD": 9,
    "SUSPENDED": 10,
    "UNKNOWN": 11,
  }

class TransferState:
  DIRECTORY_SETUP = 0
  UPLOAD = 1
  DOWNLOAD = 2
  ACTIVE = 3
  COMPLETE = 4
  STDOUT_DOWNLOAD = 5
  STDERROR_DOWNLOAD = 6
  CANCELING = 7
  CANCELED = 8
  FAILED = 9
  HELD = 10
  SUSPENDED = 11
  UNKNOWN = 12

  _VALUES_TO_NAMES = {
    0: "DIRECTORY_SETUP",
    1: "UPLOAD",
    2: "DOWNLOAD",
    3: "ACTIVE",
    4: "COMPLETE",
    5: "STDOUT_DOWNLOAD",
    6: "STDERROR_DOWNLOAD",
    7: "CANCELING",
    8: "CANCELED",
    9: "FAILED",
    10: "HELD",
    11: "SUSPENDED",
    12: "UNKNOWN",
  }

  _NAMES_TO_VALUES = {
    "DIRECTORY_SETUP": 0,
    "UPLOAD": 1,
    "DOWNLOAD": 2,
    "ACTIVE": 3,
    "COMPLETE": 4,
    "STDOUT_DOWNLOAD": 5,
    "STDERROR_DOWNLOAD": 6,
    "CANCELING": 7,
    "CANCELED": 8,
    "FAILED": 9,
    "HELD": 10,
    "SUSPENDED": 11,
    "UNKNOWN": 12,
  }

class ActionableGroup:
  RESOURCE_ADMINS = 0
  AIRAVATA_ADMINS = 1
  GATEWAYS_ADMINS = 2
  USER = 3
  CANNOT_BE_DETERMINED = 4

  _VALUES_TO_NAMES = {
    0: "RESOURCE_ADMINS",
    1: "AIRAVATA_ADMINS",
    2: "GATEWAYS_ADMINS",
    3: "USER",
    4: "CANNOT_BE_DETERMINED",
  }

  _NAMES_TO_VALUES = {
    "RESOURCE_ADMINS": 0,
    "AIRAVATA_ADMINS": 1,
    "GATEWAYS_ADMINS": 2,
    "USER": 3,
    "CANNOT_BE_DETERMINED": 4,
  }

class ErrorCategory:
  FILE_SYSTEM_FAILURE = 0
  APPLICATION_FAILURE = 1
  RESOURCE_NODE_FAILURE = 2
  DISK_FULL = 3
  INSUFFICIENT_ALLOCATION = 4
  SYSTEM_MAINTENANCE = 5
  AIRAVATA_INTERNAL_ERROR = 6
  CANNOT_BE_DETERMINED = 7

  _VALUES_TO_NAMES = {
    0: "FILE_SYSTEM_FAILURE",
    1: "APPLICATION_FAILURE",
    2: "RESOURCE_NODE_FAILURE",
    3: "DISK_FULL",
    4: "INSUFFICIENT_ALLOCATION",
    5: "SYSTEM_MAINTENANCE",
    6: "AIRAVATA_INTERNAL_ERROR",
    7: "CANNOT_BE_DETERMINED",
  }

  _NAMES_TO_VALUES = {
    "FILE_SYSTEM_FAILURE": 0,
    "APPLICATION_FAILURE": 1,
    "RESOURCE_NODE_FAILURE": 2,
    "DISK_FULL": 3,
    "INSUFFICIENT_ALLOCATION": 4,
    "SYSTEM_MAINTENANCE": 5,
    "AIRAVATA_INTERNAL_ERROR": 6,
    "CANNOT_BE_DETERMINED": 7,
  }

class CorrectiveAction:
  RETRY_SUBMISSION = 0
  CONTACT_SUPPORT = 1
  CANNOT_BE_DETERMINED = 2

  _VALUES_TO_NAMES = {
    0: "RETRY_SUBMISSION",
    1: "CONTACT_SUPPORT",
    2: "CANNOT_BE_DETERMINED",
  }

  _NAMES_TO_VALUES = {
    "RETRY_SUBMISSION": 0,
    "CONTACT_SUPPORT": 1,
    "CANNOT_BE_DETERMINED": 2,
  }

class ExecutionUnit:
  INPUT = 0
  APPLICATION = 1
  OUTPUT = 2
  OTHER = 3

  _VALUES_TO_NAMES = {
    0: "INPUT",
    1: "APPLICATION",
    2: "OUTPUT",
    3: "OTHER",
  }

  _NAMES_TO_VALUES = {
    "INPUT": 0,
    "APPLICATION": 1,
    "OUTPUT": 2,
    "OTHER": 3,
  }


class ExperimentStatus:
  """
  Attributes:
   - experimentState
   - timeOfStateChange
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'experimentState', None, None, ), # 1
    (2, TType.I64, 'timeOfStateChange', None, None, ), # 2
  )

  def __init__(self, experimentState=None, timeOfStateChange=None,):
    self.experimentState = experimentState
    self.timeOfStateChange = timeOfStateChange

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.experimentState = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.timeOfStateChange = iprot.readI64();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('ExperimentStatus')
    if self.experimentState is not None:
      oprot.writeFieldBegin('experimentState', TType.I32, 1)
      oprot.writeI32(self.experimentState)
      oprot.writeFieldEnd()
    if self.timeOfStateChange is not None:
      oprot.writeFieldBegin('timeOfStateChange', TType.I64, 2)
      oprot.writeI64(self.timeOfStateChange)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.experimentState is None:
      raise TProtocol.TProtocolException(message='Required field experimentState is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.experimentState)
    value = (value * 31) ^ hash(self.timeOfStateChange)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class WorkflowNodeStatus:
  """
  Attributes:
   - workflowNodeState
   - timeOfStateChange
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'workflowNodeState', None, None, ), # 1
    (2, TType.I64, 'timeOfStateChange', None, None, ), # 2
  )

  def __init__(self, workflowNodeState=None, timeOfStateChange=None,):
    self.workflowNodeState = workflowNodeState
    self.timeOfStateChange = timeOfStateChange

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.workflowNodeState = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.timeOfStateChange = iprot.readI64();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('WorkflowNodeStatus')
    if self.workflowNodeState is not None:
      oprot.writeFieldBegin('workflowNodeState', TType.I32, 1)
      oprot.writeI32(self.workflowNodeState)
      oprot.writeFieldEnd()
    if self.timeOfStateChange is not None:
      oprot.writeFieldBegin('timeOfStateChange', TType.I64, 2)
      oprot.writeI64(self.timeOfStateChange)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.workflowNodeState is None:
      raise TProtocol.TProtocolException(message='Required field workflowNodeState is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.workflowNodeState)
    value = (value * 31) ^ hash(self.timeOfStateChange)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TaskStatus:
  """
  Attributes:
   - executionState
   - timeOfStateChange
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'executionState', None, None, ), # 1
    (2, TType.I64, 'timeOfStateChange', None, None, ), # 2
  )

  def __init__(self, executionState=None, timeOfStateChange=None,):
    self.executionState = executionState
    self.timeOfStateChange = timeOfStateChange

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.executionState = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.timeOfStateChange = iprot.readI64();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TaskStatus')
    if self.executionState is not None:
      oprot.writeFieldBegin('executionState', TType.I32, 1)
      oprot.writeI32(self.executionState)
      oprot.writeFieldEnd()
    if self.timeOfStateChange is not None:
      oprot.writeFieldBegin('timeOfStateChange', TType.I64, 2)
      oprot.writeI64(self.timeOfStateChange)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.executionState is None:
      raise TProtocol.TProtocolException(message='Required field executionState is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.executionState)
    value = (value * 31) ^ hash(self.timeOfStateChange)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class JobStatus:
  """
  Attributes:
   - jobState
   - timeOfStateChange
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'jobState', None, None, ), # 1
    (2, TType.I64, 'timeOfStateChange', None, None, ), # 2
  )

  def __init__(self, jobState=None, timeOfStateChange=None,):
    self.jobState = jobState
    self.timeOfStateChange = timeOfStateChange

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.jobState = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.timeOfStateChange = iprot.readI64();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('JobStatus')
    if self.jobState is not None:
      oprot.writeFieldBegin('jobState', TType.I32, 1)
      oprot.writeI32(self.jobState)
      oprot.writeFieldEnd()
    if self.timeOfStateChange is not None:
      oprot.writeFieldBegin('timeOfStateChange', TType.I64, 2)
      oprot.writeI64(self.timeOfStateChange)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.jobState is None:
      raise TProtocol.TProtocolException(message='Required field jobState is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.jobState)
    value = (value * 31) ^ hash(self.timeOfStateChange)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TransferStatus:
  """
  Attributes:
   - transferState
   - timeOfStateChange
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'transferState', None, None, ), # 1
    (2, TType.I64, 'timeOfStateChange', None, None, ), # 2
  )

  def __init__(self, transferState=None, timeOfStateChange=None,):
    self.transferState = transferState
    self.timeOfStateChange = timeOfStateChange

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.transferState = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.timeOfStateChange = iprot.readI64();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TransferStatus')
    if self.transferState is not None:
      oprot.writeFieldBegin('transferState', TType.I32, 1)
      oprot.writeI32(self.transferState)
      oprot.writeFieldEnd()
    if self.timeOfStateChange is not None:
      oprot.writeFieldBegin('timeOfStateChange', TType.I64, 2)
      oprot.writeI64(self.timeOfStateChange)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.transferState is None:
      raise TProtocol.TProtocolException(message='Required field transferState is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.transferState)
    value = (value * 31) ^ hash(self.timeOfStateChange)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class ApplicationStatus:
  """
  Attributes:
   - applicationState
   - timeOfStateChange
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'applicationState', None, None, ), # 1
    (2, TType.I64, 'timeOfStateChange', None, None, ), # 2
  )

  def __init__(self, applicationState=None, timeOfStateChange=None,):
    self.applicationState = applicationState
    self.timeOfStateChange = timeOfStateChange

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.applicationState = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.timeOfStateChange = iprot.readI64();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('ApplicationStatus')
    if self.applicationState is not None:
      oprot.writeFieldBegin('applicationState', TType.STRING, 1)
      oprot.writeString(self.applicationState)
      oprot.writeFieldEnd()
    if self.timeOfStateChange is not None:
      oprot.writeFieldBegin('timeOfStateChange', TType.I64, 2)
      oprot.writeI64(self.timeOfStateChange)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.applicationState is None:
      raise TProtocol.TProtocolException(message='Required field applicationState is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.applicationState)
    value = (value * 31) ^ hash(self.timeOfStateChange)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class ComputationalResourceScheduling:
  """
  A structure holding the Computational Resource Scheduling.


  Attributes:
   - resourceHostId
   - totalCPUCount
   - nodeCount
   - numberOfThreads
   - queueName
   - wallTimeLimit
   - jobStartTime
   - totalPhysicalMemory
   - computationalProjectAccount
   - chassisName
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'resourceHostId', None, None, ), # 1
    (2, TType.I32, 'totalCPUCount', None, None, ), # 2
    (3, TType.I32, 'nodeCount', None, None, ), # 3
    (4, TType.I32, 'numberOfThreads', None, None, ), # 4
    (5, TType.STRING, 'queueName', None, None, ), # 5
    (6, TType.I32, 'wallTimeLimit', None, None, ), # 6
    (7, TType.I32, 'jobStartTime', None, None, ), # 7
    (8, TType.I32, 'totalPhysicalMemory', None, None, ), # 8
    (9, TType.STRING, 'computationalProjectAccount', None, None, ), # 9
    (10, TType.STRING, 'chassisName', None, None, ), # 10
  )

  def __init__(self, resourceHostId=None, totalCPUCount=None, nodeCount=None, numberOfThreads=None, queueName=None, wallTimeLimit=None, jobStartTime=None, totalPhysicalMemory=None, computationalProjectAccount=None, chassisName=None,):
    self.resourceHostId = resourceHostId
    self.totalCPUCount = totalCPUCount
    self.nodeCount = nodeCount
    self.numberOfThreads = numberOfThreads
    self.queueName = queueName
    self.wallTimeLimit = wallTimeLimit
    self.jobStartTime = jobStartTime
    self.totalPhysicalMemory = totalPhysicalMemory
    self.computationalProjectAccount = computationalProjectAccount
    self.chassisName = chassisName

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.resourceHostId = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.totalCPUCount = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.nodeCount = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.numberOfThreads = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.queueName = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.I32:
          self.wallTimeLimit = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.I32:
          self.jobStartTime = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.I32:
          self.totalPhysicalMemory = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 9:
        if ftype == TType.STRING:
          self.computationalProjectAccount = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 10:
        if ftype == TType.STRING:
          self.chassisName = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('ComputationalResourceScheduling')
    if self.resourceHostId is not None:
      oprot.writeFieldBegin('resourceHostId', TType.STRING, 1)
      oprot.writeString(self.resourceHostId)
      oprot.writeFieldEnd()
    if self.totalCPUCount is not None:
      oprot.writeFieldBegin('totalCPUCount', TType.I32, 2)
      oprot.writeI32(self.totalCPUCount)
      oprot.writeFieldEnd()
    if self.nodeCount is not None:
      oprot.writeFieldBegin('nodeCount', TType.I32, 3)
      oprot.writeI32(self.nodeCount)
      oprot.writeFieldEnd()
    if self.numberOfThreads is not None:
      oprot.writeFieldBegin('numberOfThreads', TType.I32, 4)
      oprot.writeI32(self.numberOfThreads)
      oprot.writeFieldEnd()
    if self.queueName is not None:
      oprot.writeFieldBegin('queueName', TType.STRING, 5)
      oprot.writeString(self.queueName)
      oprot.writeFieldEnd()
    if self.wallTimeLimit is not None:
      oprot.writeFieldBegin('wallTimeLimit', TType.I32, 6)
      oprot.writeI32(self.wallTimeLimit)
      oprot.writeFieldEnd()
    if self.jobStartTime is not None:
      oprot.writeFieldBegin('jobStartTime', TType.I32, 7)
      oprot.writeI32(self.jobStartTime)
      oprot.writeFieldEnd()
    if self.totalPhysicalMemory is not None:
      oprot.writeFieldBegin('totalPhysicalMemory', TType.I32, 8)
      oprot.writeI32(self.totalPhysicalMemory)
      oprot.writeFieldEnd()
    if self.computationalProjectAccount is not None:
      oprot.writeFieldBegin('computationalProjectAccount', TType.STRING, 9)
      oprot.writeString(self.computationalProjectAccount)
      oprot.writeFieldEnd()
    if self.chassisName is not None:
      oprot.writeFieldBegin('chassisName', TType.STRING, 10)
      oprot.writeString(self.chassisName)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.resourceHostId)
    value = (value * 31) ^ hash(self.totalCPUCount)
    value = (value * 31) ^ hash(self.nodeCount)
    value = (value * 31) ^ hash(self.numberOfThreads)
    value = (value * 31) ^ hash(self.queueName)
    value = (value * 31) ^ hash(self.wallTimeLimit)
    value = (value * 31) ^ hash(self.jobStartTime)
    value = (value * 31) ^ hash(self.totalPhysicalMemory)
    value = (value * 31) ^ hash(self.computationalProjectAccount)
    value = (value * 31) ^ hash(self.chassisName)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class AdvancedInputDataHandling:
  """
  A structure holding specified input data handling.


  Attributes:
   - stageInputFilesToWorkingDir
   - parentWorkingDirectory
   - uniqueWorkingDirectory
   - cleanUpWorkingDirAfterJob
  """

  thrift_spec = (
    None, # 0
    (1, TType.BOOL, 'stageInputFilesToWorkingDir', None, False, ), # 1
    (2, TType.STRING, 'parentWorkingDirectory', None, None, ), # 2
    (3, TType.STRING, 'uniqueWorkingDirectory', None, None, ), # 3
    (4, TType.BOOL, 'cleanUpWorkingDirAfterJob', None, False, ), # 4
  )

  def __init__(self, stageInputFilesToWorkingDir=thrift_spec[1][4], parentWorkingDirectory=None, uniqueWorkingDirectory=None, cleanUpWorkingDirAfterJob=thrift_spec[4][4],):
    self.stageInputFilesToWorkingDir = stageInputFilesToWorkingDir
    self.parentWorkingDirectory = parentWorkingDirectory
    self.uniqueWorkingDirectory = uniqueWorkingDirectory
    self.cleanUpWorkingDirAfterJob = cleanUpWorkingDirAfterJob

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.BOOL:
          self.stageInputFilesToWorkingDir = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.parentWorkingDirectory = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.uniqueWorkingDirectory = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.BOOL:
          self.cleanUpWorkingDirAfterJob = iprot.readBool();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('AdvancedInputDataHandling')
    if self.stageInputFilesToWorkingDir is not None:
      oprot.writeFieldBegin('stageInputFilesToWorkingDir', TType.BOOL, 1)
      oprot.writeBool(self.stageInputFilesToWorkingDir)
      oprot.writeFieldEnd()
    if self.parentWorkingDirectory is not None:
      oprot.writeFieldBegin('parentWorkingDirectory', TType.STRING, 2)
      oprot.writeString(self.parentWorkingDirectory)
      oprot.writeFieldEnd()
    if self.uniqueWorkingDirectory is not None:
      oprot.writeFieldBegin('uniqueWorkingDirectory', TType.STRING, 3)
      oprot.writeString(self.uniqueWorkingDirectory)
      oprot.writeFieldEnd()
    if self.cleanUpWorkingDirAfterJob is not None:
      oprot.writeFieldBegin('cleanUpWorkingDirAfterJob', TType.BOOL, 4)
      oprot.writeBool(self.cleanUpWorkingDirAfterJob)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.stageInputFilesToWorkingDir)
    value = (value * 31) ^ hash(self.parentWorkingDirectory)
    value = (value * 31) ^ hash(self.uniqueWorkingDirectory)
    value = (value * 31) ^ hash(self.cleanUpWorkingDirAfterJob)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class AdvancedOutputDataHandling:
  """
  A structure holding specified output data handling.


  Attributes:
   - outputDataDir
   - dataRegistryURL
   - persistOutputData
  """

  thrift_spec = (
    None, # 0
    None, # 1
    (2, TType.STRING, 'outputDataDir', None, None, ), # 2
    (3, TType.STRING, 'dataRegistryURL', None, None, ), # 3
    (4, TType.BOOL, 'persistOutputData', None, True, ), # 4
  )

  def __init__(self, outputDataDir=None, dataRegistryURL=None, persistOutputData=thrift_spec[4][4],):
    self.outputDataDir = outputDataDir
    self.dataRegistryURL = dataRegistryURL
    self.persistOutputData = persistOutputData

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 2:
        if ftype == TType.STRING:
          self.outputDataDir = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.dataRegistryURL = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.BOOL:
          self.persistOutputData = iprot.readBool();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('AdvancedOutputDataHandling')
    if self.outputDataDir is not None:
      oprot.writeFieldBegin('outputDataDir', TType.STRING, 2)
      oprot.writeString(self.outputDataDir)
      oprot.writeFieldEnd()
    if self.dataRegistryURL is not None:
      oprot.writeFieldBegin('dataRegistryURL', TType.STRING, 3)
      oprot.writeString(self.dataRegistryURL)
      oprot.writeFieldEnd()
    if self.persistOutputData is not None:
      oprot.writeFieldBegin('persistOutputData', TType.BOOL, 4)
      oprot.writeBool(self.persistOutputData)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.outputDataDir)
    value = (value * 31) ^ hash(self.dataRegistryURL)
    value = (value * 31) ^ hash(self.persistOutputData)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class QualityOfServiceParams:
  """
  A structure holding Quality of Service Parameters.


  Attributes:
   - startExecutionAt
   - executeBefore
   - numberofRetries
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'startExecutionAt', None, None, ), # 1
    (2, TType.STRING, 'executeBefore', None, None, ), # 2
    (3, TType.I32, 'numberofRetries', None, None, ), # 3
  )

  def __init__(self, startExecutionAt=None, executeBefore=None, numberofRetries=None,):
    self.startExecutionAt = startExecutionAt
    self.executeBefore = executeBefore
    self.numberofRetries = numberofRetries

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.startExecutionAt = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.executeBefore = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.numberofRetries = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('QualityOfServiceParams')
    if self.startExecutionAt is not None:
      oprot.writeFieldBegin('startExecutionAt', TType.STRING, 1)
      oprot.writeString(self.startExecutionAt)
      oprot.writeFieldEnd()
    if self.executeBefore is not None:
      oprot.writeFieldBegin('executeBefore', TType.STRING, 2)
      oprot.writeString(self.executeBefore)
      oprot.writeFieldEnd()
    if self.numberofRetries is not None:
      oprot.writeFieldBegin('numberofRetries', TType.I32, 3)
      oprot.writeI32(self.numberofRetries)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.startExecutionAt)
    value = (value * 31) ^ hash(self.executeBefore)
    value = (value * 31) ^ hash(self.numberofRetries)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class UserConfigurationData:
  """
  A structure holding the experiment configuration.



  Attributes:
   - airavataAutoSchedule
   - overrideManualScheduledParams
   - shareExperimentPublicly
   - computationalResourceScheduling
   - advanceInputDataHandling
   - advanceOutputDataHandling
   - qosParams
   - throttleResources
   - userDN
   - generateCert
  """

  thrift_spec = (
    None, # 0
    (1, TType.BOOL, 'airavataAutoSchedule', None, False, ), # 1
    (2, TType.BOOL, 'overrideManualScheduledParams', None, False, ), # 2
    (3, TType.BOOL, 'shareExperimentPublicly', None, False, ), # 3
    (4, TType.STRUCT, 'computationalResourceScheduling', (ComputationalResourceScheduling, ComputationalResourceScheduling.thrift_spec), None, ), # 4
    (5, TType.STRUCT, 'advanceInputDataHandling', (AdvancedInputDataHandling, AdvancedInputDataHandling.thrift_spec), None, ), # 5
    (6, TType.STRUCT, 'advanceOutputDataHandling', (AdvancedOutputDataHandling, AdvancedOutputDataHandling.thrift_spec), None, ), # 6
    (7, TType.STRUCT, 'qosParams', (QualityOfServiceParams, QualityOfServiceParams.thrift_spec), None, ), # 7
    (8, TType.BOOL, 'throttleResources', None, False, ), # 8
    (9, TType.STRING, 'userDN', None, None, ), # 9
    (10, TType.BOOL, 'generateCert', None, False, ), # 10
  )

  def __init__(self, airavataAutoSchedule=thrift_spec[1][4], overrideManualScheduledParams=thrift_spec[2][4], shareExperimentPublicly=thrift_spec[3][4], computationalResourceScheduling=None, advanceInputDataHandling=None, advanceOutputDataHandling=None, qosParams=None, throttleResources=thrift_spec[8][4], userDN=None, generateCert=thrift_spec[10][4],):
    self.airavataAutoSchedule = airavataAutoSchedule
    self.overrideManualScheduledParams = overrideManualScheduledParams
    self.shareExperimentPublicly = shareExperimentPublicly
    self.computationalResourceScheduling = computationalResourceScheduling
    self.advanceInputDataHandling = advanceInputDataHandling
    self.advanceOutputDataHandling = advanceOutputDataHandling
    self.qosParams = qosParams
    self.throttleResources = throttleResources
    self.userDN = userDN
    self.generateCert = generateCert

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.BOOL:
          self.airavataAutoSchedule = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BOOL:
          self.overrideManualScheduledParams = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.BOOL:
          self.shareExperimentPublicly = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.computationalResourceScheduling = ComputationalResourceScheduling()
          self.computationalResourceScheduling.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.advanceInputDataHandling = AdvancedInputDataHandling()
          self.advanceInputDataHandling.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRUCT:
          self.advanceOutputDataHandling = AdvancedOutputDataHandling()
          self.advanceOutputDataHandling.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.STRUCT:
          self.qosParams = QualityOfServiceParams()
          self.qosParams.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.BOOL:
          self.throttleResources = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 9:
        if ftype == TType.STRING:
          self.userDN = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 10:
        if ftype == TType.BOOL:
          self.generateCert = iprot.readBool();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('UserConfigurationData')
    if self.airavataAutoSchedule is not None:
      oprot.writeFieldBegin('airavataAutoSchedule', TType.BOOL, 1)
      oprot.writeBool(self.airavataAutoSchedule)
      oprot.writeFieldEnd()
    if self.overrideManualScheduledParams is not None:
      oprot.writeFieldBegin('overrideManualScheduledParams', TType.BOOL, 2)
      oprot.writeBool(self.overrideManualScheduledParams)
      oprot.writeFieldEnd()
    if self.shareExperimentPublicly is not None:
      oprot.writeFieldBegin('shareExperimentPublicly', TType.BOOL, 3)
      oprot.writeBool(self.shareExperimentPublicly)
      oprot.writeFieldEnd()
    if self.computationalResourceScheduling is not None:
      oprot.writeFieldBegin('computationalResourceScheduling', TType.STRUCT, 4)
      self.computationalResourceScheduling.write(oprot)
      oprot.writeFieldEnd()
    if self.advanceInputDataHandling is not None:
      oprot.writeFieldBegin('advanceInputDataHandling', TType.STRUCT, 5)
      self.advanceInputDataHandling.write(oprot)
      oprot.writeFieldEnd()
    if self.advanceOutputDataHandling is not None:
      oprot.writeFieldBegin('advanceOutputDataHandling', TType.STRUCT, 6)
      self.advanceOutputDataHandling.write(oprot)
      oprot.writeFieldEnd()
    if self.qosParams is not None:
      oprot.writeFieldBegin('qosParams', TType.STRUCT, 7)
      self.qosParams.write(oprot)
      oprot.writeFieldEnd()
    if self.throttleResources is not None:
      oprot.writeFieldBegin('throttleResources', TType.BOOL, 8)
      oprot.writeBool(self.throttleResources)
      oprot.writeFieldEnd()
    if self.userDN is not None:
      oprot.writeFieldBegin('userDN', TType.STRING, 9)
      oprot.writeString(self.userDN)
      oprot.writeFieldEnd()
    if self.generateCert is not None:
      oprot.writeFieldBegin('generateCert', TType.BOOL, 10)
      oprot.writeBool(self.generateCert)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.airavataAutoSchedule is None:
      raise TProtocol.TProtocolException(message='Required field airavataAutoSchedule is unset!')
    if self.overrideManualScheduledParams is None:
      raise TProtocol.TProtocolException(message='Required field overrideManualScheduledParams is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.airavataAutoSchedule)
    value = (value * 31) ^ hash(self.overrideManualScheduledParams)
    value = (value * 31) ^ hash(self.shareExperimentPublicly)
    value = (value * 31) ^ hash(self.computationalResourceScheduling)
    value = (value * 31) ^ hash(self.advanceInputDataHandling)
    value = (value * 31) ^ hash(self.advanceOutputDataHandling)
    value = (value * 31) ^ hash(self.qosParams)
    value = (value * 31) ^ hash(self.throttleResources)
    value = (value * 31) ^ hash(self.userDN)
    value = (value * 31) ^ hash(self.generateCert)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class ErrorDetails:
  """
  Attributes:
   - errorID
   - creationTime
   - actualErrorMessage
   - userFriendlyMessage
   - errorCategory
   - transientOrPersistent
   - correctiveAction
   - actionableGroup
   - rootCauseErrorIdList
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'errorID', None, "DO_NOT_SET_AT_CLIENTS", ), # 1
    (2, TType.I64, 'creationTime', None, None, ), # 2
    (3, TType.STRING, 'actualErrorMessage', None, None, ), # 3
    (4, TType.STRING, 'userFriendlyMessage', None, None, ), # 4
    (5, TType.I32, 'errorCategory', None, None, ), # 5
    (6, TType.BOOL, 'transientOrPersistent', None, False, ), # 6
    (7, TType.I32, 'correctiveAction', None, None, ), # 7
    (8, TType.I32, 'actionableGroup', None, None, ), # 8
    (9, TType.LIST, 'rootCauseErrorIdList', (TType.STRING,None), None, ), # 9
  )

  def __init__(self, errorID=thrift_spec[1][4], creationTime=None, actualErrorMessage=None, userFriendlyMessage=None, errorCategory=None, transientOrPersistent=thrift_spec[6][4], correctiveAction=None, actionableGroup=None, rootCauseErrorIdList=None,):
    self.errorID = errorID
    self.creationTime = creationTime
    self.actualErrorMessage = actualErrorMessage
    self.userFriendlyMessage = userFriendlyMessage
    self.errorCategory = errorCategory
    self.transientOrPersistent = transientOrPersistent
    self.correctiveAction = correctiveAction
    self.actionableGroup = actionableGroup
    self.rootCauseErrorIdList = rootCauseErrorIdList

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.errorID = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.creationTime = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.actualErrorMessage = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.userFriendlyMessage = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.I32:
          self.errorCategory = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.BOOL:
          self.transientOrPersistent = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.I32:
          self.correctiveAction = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.I32:
          self.actionableGroup = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 9:
        if ftype == TType.LIST:
          self.rootCauseErrorIdList = []
          (_etype3, _size0) = iprot.readListBegin()
          for _i4 in xrange(_size0):
            _elem5 = iprot.readString();
            self.rootCauseErrorIdList.append(_elem5)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('ErrorDetails')
    if self.errorID is not None:
      oprot.writeFieldBegin('errorID', TType.STRING, 1)
      oprot.writeString(self.errorID)
      oprot.writeFieldEnd()
    if self.creationTime is not None:
      oprot.writeFieldBegin('creationTime', TType.I64, 2)
      oprot.writeI64(self.creationTime)
      oprot.writeFieldEnd()
    if self.actualErrorMessage is not None:
      oprot.writeFieldBegin('actualErrorMessage', TType.STRING, 3)
      oprot.writeString(self.actualErrorMessage)
      oprot.writeFieldEnd()
    if self.userFriendlyMessage is not None:
      oprot.writeFieldBegin('userFriendlyMessage', TType.STRING, 4)
      oprot.writeString(self.userFriendlyMessage)
      oprot.writeFieldEnd()
    if self.errorCategory is not None:
      oprot.writeFieldBegin('errorCategory', TType.I32, 5)
      oprot.writeI32(self.errorCategory)
      oprot.writeFieldEnd()
    if self.transientOrPersistent is not None:
      oprot.writeFieldBegin('transientOrPersistent', TType.BOOL, 6)
      oprot.writeBool(self.transientOrPersistent)
      oprot.writeFieldEnd()
    if self.correctiveAction is not None:
      oprot.writeFieldBegin('correctiveAction', TType.I32, 7)
      oprot.writeI32(self.correctiveAction)
      oprot.writeFieldEnd()
    if self.actionableGroup is not None:
      oprot.writeFieldBegin('actionableGroup', TType.I32, 8)
      oprot.writeI32(self.actionableGroup)
      oprot.writeFieldEnd()
    if self.rootCauseErrorIdList is not None:
      oprot.writeFieldBegin('rootCauseErrorIdList', TType.LIST, 9)
      oprot.writeListBegin(TType.STRING, len(self.rootCauseErrorIdList))
      for iter6 in self.rootCauseErrorIdList:
        oprot.writeString(iter6)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.errorID is None:
      raise TProtocol.TProtocolException(message='Required field errorID is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.errorID)
    value = (value * 31) ^ hash(self.creationTime)
    value = (value * 31) ^ hash(self.actualErrorMessage)
    value = (value * 31) ^ hash(self.userFriendlyMessage)
    value = (value * 31) ^ hash(self.errorCategory)
    value = (value * 31) ^ hash(self.transientOrPersistent)
    value = (value * 31) ^ hash(self.correctiveAction)
    value = (value * 31) ^ hash(self.actionableGroup)
    value = (value * 31) ^ hash(self.rootCauseErrorIdList)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class JobDetails:
  """
  Attributes:
   - jobID
   - jobDescription
   - creationTime
   - jobStatus
   - applicationStatus
   - errors
   - computeResourceConsumed
   - jobName
   - workingDir
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'jobID', None, "DO_NOT_SET_AT_CLIENTS", ), # 1
    (2, TType.STRING, 'jobDescription', None, None, ), # 2
    (3, TType.I64, 'creationTime', None, None, ), # 3
    (4, TType.STRUCT, 'jobStatus', (JobStatus, JobStatus.thrift_spec), None, ), # 4
    (5, TType.STRUCT, 'applicationStatus', (ApplicationStatus, ApplicationStatus.thrift_spec), None, ), # 5
    (6, TType.LIST, 'errors', (TType.STRUCT,(ErrorDetails, ErrorDetails.thrift_spec)), None, ), # 6
    (7, TType.STRING, 'computeResourceConsumed', None, None, ), # 7
    (8, TType.STRING, 'jobName', None, None, ), # 8
    (9, TType.STRING, 'workingDir', None, None, ), # 9
  )

  def __init__(self, jobID=thrift_spec[1][4], jobDescription=None, creationTime=None, jobStatus=None, applicationStatus=None, errors=None, computeResourceConsumed=None, jobName=None, workingDir=None,):
    self.jobID = jobID
    self.jobDescription = jobDescription
    self.creationTime = creationTime
    self.jobStatus = jobStatus
    self.applicationStatus = applicationStatus
    self.errors = errors
    self.computeResourceConsumed = computeResourceConsumed
    self.jobName = jobName
    self.workingDir = workingDir

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.jobID = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.jobDescription = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I64:
          self.creationTime = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.jobStatus = JobStatus()
          self.jobStatus.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.applicationStatus = ApplicationStatus()
          self.applicationStatus.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.LIST:
          self.errors = []
          (_etype10, _size7) = iprot.readListBegin()
          for _i11 in xrange(_size7):
            _elem12 = ErrorDetails()
            _elem12.read(iprot)
            self.errors.append(_elem12)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.STRING:
          self.computeResourceConsumed = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.STRING:
          self.jobName = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 9:
        if ftype == TType.STRING:
          self.workingDir = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('JobDetails')
    if self.jobID is not None:
      oprot.writeFieldBegin('jobID', TType.STRING, 1)
      oprot.writeString(self.jobID)
      oprot.writeFieldEnd()
    if self.jobDescription is not None:
      oprot.writeFieldBegin('jobDescription', TType.STRING, 2)
      oprot.writeString(self.jobDescription)
      oprot.writeFieldEnd()
    if self.creationTime is not None:
      oprot.writeFieldBegin('creationTime', TType.I64, 3)
      oprot.writeI64(self.creationTime)
      oprot.writeFieldEnd()
    if self.jobStatus is not None:
      oprot.writeFieldBegin('jobStatus', TType.STRUCT, 4)
      self.jobStatus.write(oprot)
      oprot.writeFieldEnd()
    if self.applicationStatus is not None:
      oprot.writeFieldBegin('applicationStatus', TType.STRUCT, 5)
      self.applicationStatus.write(oprot)
      oprot.writeFieldEnd()
    if self.errors is not None:
      oprot.writeFieldBegin('errors', TType.LIST, 6)
      oprot.writeListBegin(TType.STRUCT, len(self.errors))
      for iter13 in self.errors:
        iter13.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.computeResourceConsumed is not None:
      oprot.writeFieldBegin('computeResourceConsumed', TType.STRING, 7)
      oprot.writeString(self.computeResourceConsumed)
      oprot.writeFieldEnd()
    if self.jobName is not None:
      oprot.writeFieldBegin('jobName', TType.STRING, 8)
      oprot.writeString(self.jobName)
      oprot.writeFieldEnd()
    if self.workingDir is not None:
      oprot.writeFieldBegin('workingDir', TType.STRING, 9)
      oprot.writeString(self.workingDir)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.jobID is None:
      raise TProtocol.TProtocolException(message='Required field jobID is unset!')
    if self.jobDescription is None:
      raise TProtocol.TProtocolException(message='Required field jobDescription is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.jobID)
    value = (value * 31) ^ hash(self.jobDescription)
    value = (value * 31) ^ hash(self.creationTime)
    value = (value * 31) ^ hash(self.jobStatus)
    value = (value * 31) ^ hash(self.applicationStatus)
    value = (value * 31) ^ hash(self.errors)
    value = (value * 31) ^ hash(self.computeResourceConsumed)
    value = (value * 31) ^ hash(self.jobName)
    value = (value * 31) ^ hash(self.workingDir)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class DataTransferDetails:
  """
  Attributes:
   - transferID
   - creationTime
   - transferDescription
   - transferStatus
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'transferID', None, "DO_NOT_SET_AT_CLIENTS", ), # 1
    (2, TType.I64, 'creationTime', None, None, ), # 2
    (3, TType.STRING, 'transferDescription', None, None, ), # 3
    (4, TType.STRUCT, 'transferStatus', (TransferStatus, TransferStatus.thrift_spec), None, ), # 4
  )

  def __init__(self, transferID=thrift_spec[1][4], creationTime=None, transferDescription=None, transferStatus=None,):
    self.transferID = transferID
    self.creationTime = creationTime
    self.transferDescription = transferDescription
    self.transferStatus = transferStatus

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.transferID = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.creationTime = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.transferDescription = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.transferStatus = TransferStatus()
          self.transferStatus.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('DataTransferDetails')
    if self.transferID is not None:
      oprot.writeFieldBegin('transferID', TType.STRING, 1)
      oprot.writeString(self.transferID)
      oprot.writeFieldEnd()
    if self.creationTime is not None:
      oprot.writeFieldBegin('creationTime', TType.I64, 2)
      oprot.writeI64(self.creationTime)
      oprot.writeFieldEnd()
    if self.transferDescription is not None:
      oprot.writeFieldBegin('transferDescription', TType.STRING, 3)
      oprot.writeString(self.transferDescription)
      oprot.writeFieldEnd()
    if self.transferStatus is not None:
      oprot.writeFieldBegin('transferStatus', TType.STRUCT, 4)
      self.transferStatus.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.transferID is None:
      raise TProtocol.TProtocolException(message='Required field transferID is unset!')
    if self.transferDescription is None:
      raise TProtocol.TProtocolException(message='Required field transferDescription is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.transferID)
    value = (value * 31) ^ hash(self.creationTime)
    value = (value * 31) ^ hash(self.transferDescription)
    value = (value * 31) ^ hash(self.transferStatus)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TaskDetails:
  """
  A structure holding the actual execution context decided based on user provided configuration data or system inferred
    information from scheduling and QoS parameters. One experiment can have multiple tasks. Each tasks results in
    data transfers and jobs


  Attributes:
   - taskID
   - creationTime
   - applicationId
   - applicationVersion
   - applicationDeploymentId
   - applicationInputs
   - applicationOutputs
   - taskScheduling
   - advancedInputDataHandling
   - advancedOutputDataHandling
   - taskStatus
   - jobDetailsList
   - dataTransferDetailsList
   - errors
   - enableEmailNotification
   - emailAddresses
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'taskID', None, "DO_NOT_SET_AT_CLIENTS", ), # 1
    (2, TType.I64, 'creationTime', None, None, ), # 2
    (3, TType.STRING, 'applicationId', None, None, ), # 3
    (4, TType.STRING, 'applicationVersion', None, None, ), # 4
    (5, TType.STRING, 'applicationDeploymentId', None, None, ), # 5
    (6, TType.LIST, 'applicationInputs', (TType.STRUCT,(apache.airavata.model.appcatalog.appinterface.ttypes.InputDataObjectType, apache.airavata.model.appcatalog.appinterface.ttypes.InputDataObjectType.thrift_spec)), None, ), # 6
    (7, TType.LIST, 'applicationOutputs', (TType.STRUCT,(apache.airavata.model.appcatalog.appinterface.ttypes.OutputDataObjectType, apache.airavata.model.appcatalog.appinterface.ttypes.OutputDataObjectType.thrift_spec)), None, ), # 7
    (8, TType.STRUCT, 'taskScheduling', (ComputationalResourceScheduling, ComputationalResourceScheduling.thrift_spec), None, ), # 8
    (9, TType.STRUCT, 'advancedInputDataHandling', (AdvancedInputDataHandling, AdvancedInputDataHandling.thrift_spec), None, ), # 9
    (10, TType.STRUCT, 'advancedOutputDataHandling', (AdvancedOutputDataHandling, AdvancedOutputDataHandling.thrift_spec), None, ), # 10
    (11, TType.STRUCT, 'taskStatus', (TaskStatus, TaskStatus.thrift_spec), None, ), # 11
    (12, TType.LIST, 'jobDetailsList', (TType.STRUCT,(JobDetails, JobDetails.thrift_spec)), None, ), # 12
    (13, TType.LIST, 'dataTransferDetailsList', (TType.STRUCT,(DataTransferDetails, DataTransferDetails.thrift_spec)), None, ), # 13
    (14, TType.LIST, 'errors', (TType.STRUCT,(ErrorDetails, ErrorDetails.thrift_spec)), None, ), # 14
    (15, TType.BOOL, 'enableEmailNotification', None, None, ), # 15
    (16, TType.LIST, 'emailAddresses', (TType.STRING,None), None, ), # 16
  )

  def __init__(self, taskID=thrift_spec[1][4], creationTime=None, applicationId=None, applicationVersion=None, applicationDeploymentId=None, applicationInputs=None, applicationOutputs=None, taskScheduling=None, advancedInputDataHandling=None, advancedOutputDataHandling=None, taskStatus=None, jobDetailsList=None, dataTransferDetailsList=None, errors=None, enableEmailNotification=None, emailAddresses=None,):
    self.taskID = taskID
    self.creationTime = creationTime
    self.applicationId = applicationId
    self.applicationVersion = applicationVersion
    self.applicationDeploymentId = applicationDeploymentId
    self.applicationInputs = applicationInputs
    self.applicationOutputs = applicationOutputs
    self.taskScheduling = taskScheduling
    self.advancedInputDataHandling = advancedInputDataHandling
    self.advancedOutputDataHandling = advancedOutputDataHandling
    self.taskStatus = taskStatus
    self.jobDetailsList = jobDetailsList
    self.dataTransferDetailsList = dataTransferDetailsList
    self.errors = errors
    self.enableEmailNotification = enableEmailNotification
    self.emailAddresses = emailAddresses

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.taskID = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.creationTime = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.applicationId = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.applicationVersion = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.applicationDeploymentId = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.LIST:
          self.applicationInputs = []
          (_etype17, _size14) = iprot.readListBegin()
          for _i18 in xrange(_size14):
            _elem19 = apache.airavata.model.appcatalog.appinterface.ttypes.InputDataObjectType()
            _elem19.read(iprot)
            self.applicationInputs.append(_elem19)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.LIST:
          self.applicationOutputs = []
          (_etype23, _size20) = iprot.readListBegin()
          for _i24 in xrange(_size20):
            _elem25 = apache.airavata.model.appcatalog.appinterface.ttypes.OutputDataObjectType()
            _elem25.read(iprot)
            self.applicationOutputs.append(_elem25)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.STRUCT:
          self.taskScheduling = ComputationalResourceScheduling()
          self.taskScheduling.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 9:
        if ftype == TType.STRUCT:
          self.advancedInputDataHandling = AdvancedInputDataHandling()
          self.advancedInputDataHandling.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 10:
        if ftype == TType.STRUCT:
          self.advancedOutputDataHandling = AdvancedOutputDataHandling()
          self.advancedOutputDataHandling.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 11:
        if ftype == TType.STRUCT:
          self.taskStatus = TaskStatus()
          self.taskStatus.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 12:
        if ftype == TType.LIST:
          self.jobDetailsList = []
          (_etype29, _size26) = iprot.readListBegin()
          for _i30 in xrange(_size26):
            _elem31 = JobDetails()
            _elem31.read(iprot)
            self.jobDetailsList.append(_elem31)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 13:
        if ftype == TType.LIST:
          self.dataTransferDetailsList = []
          (_etype35, _size32) = iprot.readListBegin()
          for _i36 in xrange(_size32):
            _elem37 = DataTransferDetails()
            _elem37.read(iprot)
            self.dataTransferDetailsList.append(_elem37)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 14:
        if ftype == TType.LIST:
          self.errors = []
          (_etype41, _size38) = iprot.readListBegin()
          for _i42 in xrange(_size38):
            _elem43 = ErrorDetails()
            _elem43.read(iprot)
            self.errors.append(_elem43)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 15:
        if ftype == TType.BOOL:
          self.enableEmailNotification = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 16:
        if ftype == TType.LIST:
          self.emailAddresses = []
          (_etype47, _size44) = iprot.readListBegin()
          for _i48 in xrange(_size44):
            _elem49 = iprot.readString();
            self.emailAddresses.append(_elem49)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TaskDetails')
    if self.taskID is not None:
      oprot.writeFieldBegin('taskID', TType.STRING, 1)
      oprot.writeString(self.taskID)
      oprot.writeFieldEnd()
    if self.creationTime is not None:
      oprot.writeFieldBegin('creationTime', TType.I64, 2)
      oprot.writeI64(self.creationTime)
      oprot.writeFieldEnd()
    if self.applicationId is not None:
      oprot.writeFieldBegin('applicationId', TType.STRING, 3)
      oprot.writeString(self.applicationId)
      oprot.writeFieldEnd()
    if self.applicationVersion is not None:
      oprot.writeFieldBegin('applicationVersion', TType.STRING, 4)
      oprot.writeString(self.applicationVersion)
      oprot.writeFieldEnd()
    if self.applicationDeploymentId is not None:
      oprot.writeFieldBegin('applicationDeploymentId', TType.STRING, 5)
      oprot.writeString(self.applicationDeploymentId)
      oprot.writeFieldEnd()
    if self.applicationInputs is not None:
      oprot.writeFieldBegin('applicationInputs', TType.LIST, 6)
      oprot.writeListBegin(TType.STRUCT, len(self.applicationInputs))
      for iter50 in self.applicationInputs:
        iter50.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.applicationOutputs is not None:
      oprot.writeFieldBegin('applicationOutputs', TType.LIST, 7)
      oprot.writeListBegin(TType.STRUCT, len(self.applicationOutputs))
      for iter51 in self.applicationOutputs:
        iter51.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.taskScheduling is not None:
      oprot.writeFieldBegin('taskScheduling', TType.STRUCT, 8)
      self.taskScheduling.write(oprot)
      oprot.writeFieldEnd()
    if self.advancedInputDataHandling is not None:
      oprot.writeFieldBegin('advancedInputDataHandling', TType.STRUCT, 9)
      self.advancedInputDataHandling.write(oprot)
      oprot.writeFieldEnd()
    if self.advancedOutputDataHandling is not None:
      oprot.writeFieldBegin('advancedOutputDataHandling', TType.STRUCT, 10)
      self.advancedOutputDataHandling.write(oprot)
      oprot.writeFieldEnd()
    if self.taskStatus is not None:
      oprot.writeFieldBegin('taskStatus', TType.STRUCT, 11)
      self.taskStatus.write(oprot)
      oprot.writeFieldEnd()
    if self.jobDetailsList is not None:
      oprot.writeFieldBegin('jobDetailsList', TType.LIST, 12)
      oprot.writeListBegin(TType.STRUCT, len(self.jobDetailsList))
      for iter52 in self.jobDetailsList:
        iter52.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.dataTransferDetailsList is not None:
      oprot.writeFieldBegin('dataTransferDetailsList', TType.LIST, 13)
      oprot.writeListBegin(TType.STRUCT, len(self.dataTransferDetailsList))
      for iter53 in self.dataTransferDetailsList:
        iter53.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.errors is not None:
      oprot.writeFieldBegin('errors', TType.LIST, 14)
      oprot.writeListBegin(TType.STRUCT, len(self.errors))
      for iter54 in self.errors:
        iter54.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.enableEmailNotification is not None:
      oprot.writeFieldBegin('enableEmailNotification', TType.BOOL, 15)
      oprot.writeBool(self.enableEmailNotification)
      oprot.writeFieldEnd()
    if self.emailAddresses is not None:
      oprot.writeFieldBegin('emailAddresses', TType.LIST, 16)
      oprot.writeListBegin(TType.STRING, len(self.emailAddresses))
      for iter55 in self.emailAddresses:
        oprot.writeString(iter55)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.taskID is None:
      raise TProtocol.TProtocolException(message='Required field taskID is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.taskID)
    value = (value * 31) ^ hash(self.creationTime)
    value = (value * 31) ^ hash(self.applicationId)
    value = (value * 31) ^ hash(self.applicationVersion)
    value = (value * 31) ^ hash(self.applicationDeploymentId)
    value = (value * 31) ^ hash(self.applicationInputs)
    value = (value * 31) ^ hash(self.applicationOutputs)
    value = (value * 31) ^ hash(self.taskScheduling)
    value = (value * 31) ^ hash(self.advancedInputDataHandling)
    value = (value * 31) ^ hash(self.advancedOutputDataHandling)
    value = (value * 31) ^ hash(self.taskStatus)
    value = (value * 31) ^ hash(self.jobDetailsList)
    value = (value * 31) ^ hash(self.dataTransferDetailsList)
    value = (value * 31) ^ hash(self.errors)
    value = (value * 31) ^ hash(self.enableEmailNotification)
    value = (value * 31) ^ hash(self.emailAddresses)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class WorkflowNodeDetails:
  """
  A structure holding the node data.
  nodeInstanceId - unique node identifier for each run

  Attributes:
   - nodeInstanceId
   - creationTime
   - nodeName
   - executionUnit
   - executionUnitData
   - nodeInputs
   - nodeOutputs
   - workflowNodeStatus
   - taskDetailsList
   - errors
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'nodeInstanceId', None, "DO_NOT_SET_AT_CLIENTS", ), # 1
    (2, TType.I64, 'creationTime', None, None, ), # 2
    (3, TType.STRING, 'nodeName', None, "SINGLE_APP_NODE", ), # 3
    (4, TType.I32, 'executionUnit', None,     1, ), # 4
    (5, TType.STRING, 'executionUnitData', None, None, ), # 5
    (6, TType.LIST, 'nodeInputs', (TType.STRUCT,(apache.airavata.model.appcatalog.appinterface.ttypes.InputDataObjectType, apache.airavata.model.appcatalog.appinterface.ttypes.InputDataObjectType.thrift_spec)), None, ), # 6
    (7, TType.LIST, 'nodeOutputs', (TType.STRUCT,(apache.airavata.model.appcatalog.appinterface.ttypes.OutputDataObjectType, apache.airavata.model.appcatalog.appinterface.ttypes.OutputDataObjectType.thrift_spec)), None, ), # 7
    (8, TType.STRUCT, 'workflowNodeStatus', (WorkflowNodeStatus, WorkflowNodeStatus.thrift_spec), None, ), # 8
    (9, TType.LIST, 'taskDetailsList', (TType.STRUCT,(TaskDetails, TaskDetails.thrift_spec)), None, ), # 9
    (10, TType.LIST, 'errors', (TType.STRUCT,(ErrorDetails, ErrorDetails.thrift_spec)), None, ), # 10
  )

  def __init__(self, nodeInstanceId=thrift_spec[1][4], creationTime=None, nodeName=thrift_spec[3][4], executionUnit=thrift_spec[4][4], executionUnitData=None, nodeInputs=None, nodeOutputs=None, workflowNodeStatus=None, taskDetailsList=None, errors=None,):
    self.nodeInstanceId = nodeInstanceId
    self.creationTime = creationTime
    self.nodeName = nodeName
    self.executionUnit = executionUnit
    self.executionUnitData = executionUnitData
    self.nodeInputs = nodeInputs
    self.nodeOutputs = nodeOutputs
    self.workflowNodeStatus = workflowNodeStatus
    self.taskDetailsList = taskDetailsList
    self.errors = errors

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.nodeInstanceId = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.creationTime = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.nodeName = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.executionUnit = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.executionUnitData = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.LIST:
          self.nodeInputs = []
          (_etype59, _size56) = iprot.readListBegin()
          for _i60 in xrange(_size56):
            _elem61 = apache.airavata.model.appcatalog.appinterface.ttypes.InputDataObjectType()
            _elem61.read(iprot)
            self.nodeInputs.append(_elem61)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.LIST:
          self.nodeOutputs = []
          (_etype65, _size62) = iprot.readListBegin()
          for _i66 in xrange(_size62):
            _elem67 = apache.airavata.model.appcatalog.appinterface.ttypes.OutputDataObjectType()
            _elem67.read(iprot)
            self.nodeOutputs.append(_elem67)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.STRUCT:
          self.workflowNodeStatus = WorkflowNodeStatus()
          self.workflowNodeStatus.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 9:
        if ftype == TType.LIST:
          self.taskDetailsList = []
          (_etype71, _size68) = iprot.readListBegin()
          for _i72 in xrange(_size68):
            _elem73 = TaskDetails()
            _elem73.read(iprot)
            self.taskDetailsList.append(_elem73)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 10:
        if ftype == TType.LIST:
          self.errors = []
          (_etype77, _size74) = iprot.readListBegin()
          for _i78 in xrange(_size74):
            _elem79 = ErrorDetails()
            _elem79.read(iprot)
            self.errors.append(_elem79)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('WorkflowNodeDetails')
    if self.nodeInstanceId is not None:
      oprot.writeFieldBegin('nodeInstanceId', TType.STRING, 1)
      oprot.writeString(self.nodeInstanceId)
      oprot.writeFieldEnd()
    if self.creationTime is not None:
      oprot.writeFieldBegin('creationTime', TType.I64, 2)
      oprot.writeI64(self.creationTime)
      oprot.writeFieldEnd()
    if self.nodeName is not None:
      oprot.writeFieldBegin('nodeName', TType.STRING, 3)
      oprot.writeString(self.nodeName)
      oprot.writeFieldEnd()
    if self.executionUnit is not None:
      oprot.writeFieldBegin('executionUnit', TType.I32, 4)
      oprot.writeI32(self.executionUnit)
      oprot.writeFieldEnd()
    if self.executionUnitData is not None:
      oprot.writeFieldBegin('executionUnitData', TType.STRING, 5)
      oprot.writeString(self.executionUnitData)
      oprot.writeFieldEnd()
    if self.nodeInputs is not None:
      oprot.writeFieldBegin('nodeInputs', TType.LIST, 6)
      oprot.writeListBegin(TType.STRUCT, len(self.nodeInputs))
      for iter80 in self.nodeInputs:
        iter80.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.nodeOutputs is not None:
      oprot.writeFieldBegin('nodeOutputs', TType.LIST, 7)
      oprot.writeListBegin(TType.STRUCT, len(self.nodeOutputs))
      for iter81 in self.nodeOutputs:
        iter81.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.workflowNodeStatus is not None:
      oprot.writeFieldBegin('workflowNodeStatus', TType.STRUCT, 8)
      self.workflowNodeStatus.write(oprot)
      oprot.writeFieldEnd()
    if self.taskDetailsList is not None:
      oprot.writeFieldBegin('taskDetailsList', TType.LIST, 9)
      oprot.writeListBegin(TType.STRUCT, len(self.taskDetailsList))
      for iter82 in self.taskDetailsList:
        iter82.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.errors is not None:
      oprot.writeFieldBegin('errors', TType.LIST, 10)
      oprot.writeListBegin(TType.STRUCT, len(self.errors))
      for iter83 in self.errors:
        iter83.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.nodeInstanceId is None:
      raise TProtocol.TProtocolException(message='Required field nodeInstanceId is unset!')
    if self.nodeName is None:
      raise TProtocol.TProtocolException(message='Required field nodeName is unset!')
    if self.executionUnit is None:
      raise TProtocol.TProtocolException(message='Required field executionUnit is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.nodeInstanceId)
    value = (value * 31) ^ hash(self.creationTime)
    value = (value * 31) ^ hash(self.nodeName)
    value = (value * 31) ^ hash(self.executionUnit)
    value = (value * 31) ^ hash(self.executionUnitData)
    value = (value * 31) ^ hash(self.nodeInputs)
    value = (value * 31) ^ hash(self.nodeOutputs)
    value = (value * 31) ^ hash(self.workflowNodeStatus)
    value = (value * 31) ^ hash(self.taskDetailsList)
    value = (value * 31) ^ hash(self.errors)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class ValidatorResult:
  """
  This data structure can be used to store the validation results
  captured during validation step and during the launchExperiment
  operation it can be easilly checked to see the errors occured
  during the experiment launch operation


  Attributes:
   - result
   - errorDetails
  """

  thrift_spec = (
    None, # 0
    (1, TType.BOOL, 'result', None, None, ), # 1
    (2, TType.STRING, 'errorDetails', None, None, ), # 2
  )

  def __init__(self, result=None, errorDetails=None,):
    self.result = result
    self.errorDetails = errorDetails

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.BOOL:
          self.result = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.errorDetails = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('ValidatorResult')
    if self.result is not None:
      oprot.writeFieldBegin('result', TType.BOOL, 1)
      oprot.writeBool(self.result)
      oprot.writeFieldEnd()
    if self.errorDetails is not None:
      oprot.writeFieldBegin('errorDetails', TType.STRING, 2)
      oprot.writeString(self.errorDetails)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.result is None:
      raise TProtocol.TProtocolException(message='Required field result is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.result)
    value = (value * 31) ^ hash(self.errorDetails)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class ValidationResults:
  """
  Attributes:
   - validationState
   - validationResultList
  """

  thrift_spec = (
    None, # 0
    (1, TType.BOOL, 'validationState', None, None, ), # 1
    (2, TType.LIST, 'validationResultList', (TType.STRUCT,(ValidatorResult, ValidatorResult.thrift_spec)), None, ), # 2
  )

  def __init__(self, validationState=None, validationResultList=None,):
    self.validationState = validationState
    self.validationResultList = validationResultList

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.BOOL:
          self.validationState = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.validationResultList = []
          (_etype87, _size84) = iprot.readListBegin()
          for _i88 in xrange(_size84):
            _elem89 = ValidatorResult()
            _elem89.read(iprot)
            self.validationResultList.append(_elem89)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('ValidationResults')
    if self.validationState is not None:
      oprot.writeFieldBegin('validationState', TType.BOOL, 1)
      oprot.writeBool(self.validationState)
      oprot.writeFieldEnd()
    if self.validationResultList is not None:
      oprot.writeFieldBegin('validationResultList', TType.LIST, 2)
      oprot.writeListBegin(TType.STRUCT, len(self.validationResultList))
      for iter90 in self.validationResultList:
        iter90.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.validationState is None:
      raise TProtocol.TProtocolException(message='Required field validationState is unset!')
    if self.validationResultList is None:
      raise TProtocol.TProtocolException(message='Required field validationResultList is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.validationState)
    value = (value * 31) ^ hash(self.validationResultList)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class Experiment:
  """
  A structure holding the experiment metadata and its child models.

  userName:
    The user name of the targeted gateway end user on whose behalf the experiment is being created.
      the associated gateway identity can only be inferred from the security hand-shake so as to avoid
      authorized Airavata Clients mimicking an unauthorized request. If a gateway is not registered with
      Airavata, an authorization exception is thrown.

  experimentName:
    The name of the experiment as defined by the user. The name need not be unique as uniqueness is enforced
       by the generated experiment id.

  experimentDescription:
     The verbose description of the experiment. This is an optional parameter.

  Attributes:
   - experimentID
   - projectID
   - creationTime
   - userName
   - name
   - description
   - applicationId
   - applicationVersion
   - workflowTemplateId
   - workflowTemplateVersion
   - gatewayExecutionId
   - enableEmailNotification
   - emailAddresses
   - userConfigurationData
   - workflowExecutionInstanceId
   - experimentInputs
   - experimentOutputs
   - experimentStatus
   - stateChangeList
   - workflowNodeDetailsList
   - errors
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'experimentID', None, "DO_NOT_SET_AT_CLIENTS", ), # 1
    (2, TType.STRING, 'projectID', None, "DEFAULT", ), # 2
    (3, TType.I64, 'creationTime', None, None, ), # 3
    (4, TType.STRING, 'userName', None, None, ), # 4
    (5, TType.STRING, 'name', None, None, ), # 5
    (6, TType.STRING, 'description', None, None, ), # 6
    (7, TType.STRING, 'applicationId', None, None, ), # 7
    (8, TType.STRING, 'applicationVersion', None, None, ), # 8
    (9, TType.STRING, 'workflowTemplateId', None, None, ), # 9
    (10, TType.STRING, 'workflowTemplateVersion', None, None, ), # 10
    (11, TType.STRING, 'gatewayExecutionId', None, None, ), # 11
    (12, TType.BOOL, 'enableEmailNotification', None, None, ), # 12
    (13, TType.LIST, 'emailAddresses', (TType.STRING,None), None, ), # 13
    (14, TType.STRUCT, 'userConfigurationData', (UserConfigurationData, UserConfigurationData.thrift_spec), None, ), # 14
    (15, TType.STRING, 'workflowExecutionInstanceId', None, None, ), # 15
    (16, TType.LIST, 'experimentInputs', (TType.STRUCT,(apache.airavata.model.appcatalog.appinterface.ttypes.InputDataObjectType, apache.airavata.model.appcatalog.appinterface.ttypes.InputDataObjectType.thrift_spec)), None, ), # 16
    (17, TType.LIST, 'experimentOutputs', (TType.STRUCT,(apache.airavata.model.appcatalog.appinterface.ttypes.OutputDataObjectType, apache.airavata.model.appcatalog.appinterface.ttypes.OutputDataObjectType.thrift_spec)), None, ), # 17
    (18, TType.STRUCT, 'experimentStatus', (ExperimentStatus, ExperimentStatus.thrift_spec), None, ), # 18
    (19, TType.LIST, 'stateChangeList', (TType.STRUCT,(WorkflowNodeStatus, WorkflowNodeStatus.thrift_spec)), None, ), # 19
    (20, TType.LIST, 'workflowNodeDetailsList', (TType.STRUCT,(WorkflowNodeDetails, WorkflowNodeDetails.thrift_spec)), None, ), # 20
    (21, TType.LIST, 'errors', (TType.STRUCT,(ErrorDetails, ErrorDetails.thrift_spec)), None, ), # 21
  )

  def __init__(self, experimentID=thrift_spec[1][4], projectID=thrift_spec[2][4], creationTime=None, userName=None, name=None, description=None, applicationId=None, applicationVersion=None, workflowTemplateId=None, workflowTemplateVersion=None, gatewayExecutionId=None, enableEmailNotification=None, emailAddresses=None, userConfigurationData=None, workflowExecutionInstanceId=None, experimentInputs=None, experimentOutputs=None, experimentStatus=None, stateChangeList=None, workflowNodeDetailsList=None, errors=None,):
    self.experimentID = experimentID
    self.projectID = projectID
    self.creationTime = creationTime
    self.userName = userName
    self.name = name
    self.description = description
    self.applicationId = applicationId
    self.applicationVersion = applicationVersion
    self.workflowTemplateId = workflowTemplateId
    self.workflowTemplateVersion = workflowTemplateVersion
    self.gatewayExecutionId = gatewayExecutionId
    self.enableEmailNotification = enableEmailNotification
    self.emailAddresses = emailAddresses
    self.userConfigurationData = userConfigurationData
    self.workflowExecutionInstanceId = workflowExecutionInstanceId
    self.experimentInputs = experimentInputs
    self.experimentOutputs = experimentOutputs
    self.experimentStatus = experimentStatus
    self.stateChangeList = stateChangeList
    self.workflowNodeDetailsList = workflowNodeDetailsList
    self.errors = errors

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.experimentID = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.projectID = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I64:
          self.creationTime = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.userName = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.name = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRING:
          self.description = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.STRING:
          self.applicationId = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.STRING:
          self.applicationVersion = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 9:
        if ftype == TType.STRING:
          self.workflowTemplateId = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 10:
        if ftype == TType.STRING:
          self.workflowTemplateVersion = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 11:
        if ftype == TType.STRING:
          self.gatewayExecutionId = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 12:
        if ftype == TType.BOOL:
          self.enableEmailNotification = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 13:
        if ftype == TType.LIST:
          self.emailAddresses = []
          (_etype94, _size91) = iprot.readListBegin()
          for _i95 in xrange(_size91):
            _elem96 = iprot.readString();
            self.emailAddresses.append(_elem96)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 14:
        if ftype == TType.STRUCT:
          self.userConfigurationData = UserConfigurationData()
          self.userConfigurationData.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 15:
        if ftype == TType.STRING:
          self.workflowExecutionInstanceId = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 16:
        if ftype == TType.LIST:
          self.experimentInputs = []
          (_etype100, _size97) = iprot.readListBegin()
          for _i101 in xrange(_size97):
            _elem102 = apache.airavata.model.appcatalog.appinterface.ttypes.InputDataObjectType()
            _elem102.read(iprot)
            self.experimentInputs.append(_elem102)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 17:
        if ftype == TType.LIST:
          self.experimentOutputs = []
          (_etype106, _size103) = iprot.readListBegin()
          for _i107 in xrange(_size103):
            _elem108 = apache.airavata.model.appcatalog.appinterface.ttypes.OutputDataObjectType()
            _elem108.read(iprot)
            self.experimentOutputs.append(_elem108)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 18:
        if ftype == TType.STRUCT:
          self.experimentStatus = ExperimentStatus()
          self.experimentStatus.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 19:
        if ftype == TType.LIST:
          self.stateChangeList = []
          (_etype112, _size109) = iprot.readListBegin()
          for _i113 in xrange(_size109):
            _elem114 = WorkflowNodeStatus()
            _elem114.read(iprot)
            self.stateChangeList.append(_elem114)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 20:
        if ftype == TType.LIST:
          self.workflowNodeDetailsList = []
          (_etype118, _size115) = iprot.readListBegin()
          for _i119 in xrange(_size115):
            _elem120 = WorkflowNodeDetails()
            _elem120.read(iprot)
            self.workflowNodeDetailsList.append(_elem120)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 21:
        if ftype == TType.LIST:
          self.errors = []
          (_etype124, _size121) = iprot.readListBegin()
          for _i125 in xrange(_size121):
            _elem126 = ErrorDetails()
            _elem126.read(iprot)
            self.errors.append(_elem126)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('Experiment')
    if self.experimentID is not None:
      oprot.writeFieldBegin('experimentID', TType.STRING, 1)
      oprot.writeString(self.experimentID)
      oprot.writeFieldEnd()
    if self.projectID is not None:
      oprot.writeFieldBegin('projectID', TType.STRING, 2)
      oprot.writeString(self.projectID)
      oprot.writeFieldEnd()
    if self.creationTime is not None:
      oprot.writeFieldBegin('creationTime', TType.I64, 3)
      oprot.writeI64(self.creationTime)
      oprot.writeFieldEnd()
    if self.userName is not None:
      oprot.writeFieldBegin('userName', TType.STRING, 4)
      oprot.writeString(self.userName)
      oprot.writeFieldEnd()
    if self.name is not None:
      oprot.writeFieldBegin('name', TType.STRING, 5)
      oprot.writeString(self.name)
      oprot.writeFieldEnd()
    if self.description is not None:
      oprot.writeFieldBegin('description', TType.STRING, 6)
      oprot.writeString(self.description)
      oprot.writeFieldEnd()
    if self.applicationId is not None:
      oprot.writeFieldBegin('applicationId', TType.STRING, 7)
      oprot.writeString(self.applicationId)
      oprot.writeFieldEnd()
    if self.applicationVersion is not None:
      oprot.writeFieldBegin('applicationVersion', TType.STRING, 8)
      oprot.writeString(self.applicationVersion)
      oprot.writeFieldEnd()
    if self.workflowTemplateId is not None:
      oprot.writeFieldBegin('workflowTemplateId', TType.STRING, 9)
      oprot.writeString(self.workflowTemplateId)
      oprot.writeFieldEnd()
    if self.workflowTemplateVersion is not None:
      oprot.writeFieldBegin('workflowTemplateVersion', TType.STRING, 10)
      oprot.writeString(self.workflowTemplateVersion)
      oprot.writeFieldEnd()
    if self.gatewayExecutionId is not None:
      oprot.writeFieldBegin('gatewayExecutionId', TType.STRING, 11)
      oprot.writeString(self.gatewayExecutionId)
      oprot.writeFieldEnd()
    if self.enableEmailNotification is not None:
      oprot.writeFieldBegin('enableEmailNotification', TType.BOOL, 12)
      oprot.writeBool(self.enableEmailNotification)
      oprot.writeFieldEnd()
    if self.emailAddresses is not None:
      oprot.writeFieldBegin('emailAddresses', TType.LIST, 13)
      oprot.writeListBegin(TType.STRING, len(self.emailAddresses))
      for iter127 in self.emailAddresses:
        oprot.writeString(iter127)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.userConfigurationData is not None:
      oprot.writeFieldBegin('userConfigurationData', TType.STRUCT, 14)
      self.userConfigurationData.write(oprot)
      oprot.writeFieldEnd()
    if self.workflowExecutionInstanceId is not None:
      oprot.writeFieldBegin('workflowExecutionInstanceId', TType.STRING, 15)
      oprot.writeString(self.workflowExecutionInstanceId)
      oprot.writeFieldEnd()
    if self.experimentInputs is not None:
      oprot.writeFieldBegin('experimentInputs', TType.LIST, 16)
      oprot.writeListBegin(TType.STRUCT, len(self.experimentInputs))
      for iter128 in self.experimentInputs:
        iter128.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.experimentOutputs is not None:
      oprot.writeFieldBegin('experimentOutputs', TType.LIST, 17)
      oprot.writeListBegin(TType.STRUCT, len(self.experimentOutputs))
      for iter129 in self.experimentOutputs:
        iter129.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.experimentStatus is not None:
      oprot.writeFieldBegin('experimentStatus', TType.STRUCT, 18)
      self.experimentStatus.write(oprot)
      oprot.writeFieldEnd()
    if self.stateChangeList is not None:
      oprot.writeFieldBegin('stateChangeList', TType.LIST, 19)
      oprot.writeListBegin(TType.STRUCT, len(self.stateChangeList))
      for iter130 in self.stateChangeList:
        iter130.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.workflowNodeDetailsList is not None:
      oprot.writeFieldBegin('workflowNodeDetailsList', TType.LIST, 20)
      oprot.writeListBegin(TType.STRUCT, len(self.workflowNodeDetailsList))
      for iter131 in self.workflowNodeDetailsList:
        iter131.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.errors is not None:
      oprot.writeFieldBegin('errors', TType.LIST, 21)
      oprot.writeListBegin(TType.STRUCT, len(self.errors))
      for iter132 in self.errors:
        iter132.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.experimentID is None:
      raise TProtocol.TProtocolException(message='Required field experimentID is unset!')
    if self.projectID is None:
      raise TProtocol.TProtocolException(message='Required field projectID is unset!')
    if self.userName is None:
      raise TProtocol.TProtocolException(message='Required field userName is unset!')
    if self.name is None:
      raise TProtocol.TProtocolException(message='Required field name is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.experimentID)
    value = (value * 31) ^ hash(self.projectID)
    value = (value * 31) ^ hash(self.creationTime)
    value = (value * 31) ^ hash(self.userName)
    value = (value * 31) ^ hash(self.name)
    value = (value * 31) ^ hash(self.description)
    value = (value * 31) ^ hash(self.applicationId)
    value = (value * 31) ^ hash(self.applicationVersion)
    value = (value * 31) ^ hash(self.workflowTemplateId)
    value = (value * 31) ^ hash(self.workflowTemplateVersion)
    value = (value * 31) ^ hash(self.gatewayExecutionId)
    value = (value * 31) ^ hash(self.enableEmailNotification)
    value = (value * 31) ^ hash(self.emailAddresses)
    value = (value * 31) ^ hash(self.userConfigurationData)
    value = (value * 31) ^ hash(self.workflowExecutionInstanceId)
    value = (value * 31) ^ hash(self.experimentInputs)
    value = (value * 31) ^ hash(self.experimentOutputs)
    value = (value * 31) ^ hash(self.experimentStatus)
    value = (value * 31) ^ hash(self.stateChangeList)
    value = (value * 31) ^ hash(self.workflowNodeDetailsList)
    value = (value * 31) ^ hash(self.errors)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class ExperimentSummary:
  """
  Attributes:
   - experimentID
   - projectID
   - creationTime
   - userName
   - name
   - description
   - applicationId
   - experimentStatus
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'experimentID', None, None, ), # 1
    (2, TType.STRING, 'projectID', None, None, ), # 2
    (3, TType.I64, 'creationTime', None, None, ), # 3
    (4, TType.STRING, 'userName', None, None, ), # 4
    (5, TType.STRING, 'name', None, None, ), # 5
    (6, TType.STRING, 'description', None, None, ), # 6
    (7, TType.STRING, 'applicationId', None, None, ), # 7
    (8, TType.STRUCT, 'experimentStatus', (ExperimentStatus, ExperimentStatus.thrift_spec), None, ), # 8
  )

  def __init__(self, experimentID=None, projectID=None, creationTime=None, userName=None, name=None, description=None, applicationId=None, experimentStatus=None,):
    self.experimentID = experimentID
    self.projectID = projectID
    self.creationTime = creationTime
    self.userName = userName
    self.name = name
    self.description = description
    self.applicationId = applicationId
    self.experimentStatus = experimentStatus

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.experimentID = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.projectID = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I64:
          self.creationTime = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.userName = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.name = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRING:
          self.description = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.STRING:
          self.applicationId = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.STRUCT:
          self.experimentStatus = ExperimentStatus()
          self.experimentStatus.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('ExperimentSummary')
    if self.experimentID is not None:
      oprot.writeFieldBegin('experimentID', TType.STRING, 1)
      oprot.writeString(self.experimentID)
      oprot.writeFieldEnd()
    if self.projectID is not None:
      oprot.writeFieldBegin('projectID', TType.STRING, 2)
      oprot.writeString(self.projectID)
      oprot.writeFieldEnd()
    if self.creationTime is not None:
      oprot.writeFieldBegin('creationTime', TType.I64, 3)
      oprot.writeI64(self.creationTime)
      oprot.writeFieldEnd()
    if self.userName is not None:
      oprot.writeFieldBegin('userName', TType.STRING, 4)
      oprot.writeString(self.userName)
      oprot.writeFieldEnd()
    if self.name is not None:
      oprot.writeFieldBegin('name', TType.STRING, 5)
      oprot.writeString(self.name)
      oprot.writeFieldEnd()
    if self.description is not None:
      oprot.writeFieldBegin('description', TType.STRING, 6)
      oprot.writeString(self.description)
      oprot.writeFieldEnd()
    if self.applicationId is not None:
      oprot.writeFieldBegin('applicationId', TType.STRING, 7)
      oprot.writeString(self.applicationId)
      oprot.writeFieldEnd()
    if self.experimentStatus is not None:
      oprot.writeFieldBegin('experimentStatus', TType.STRUCT, 8)
      self.experimentStatus.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.experimentID is None:
      raise TProtocol.TProtocolException(message='Required field experimentID is unset!')
    if self.projectID is None:
      raise TProtocol.TProtocolException(message='Required field projectID is unset!')
    if self.userName is None:
      raise TProtocol.TProtocolException(message='Required field userName is unset!')
    if self.name is None:
      raise TProtocol.TProtocolException(message='Required field name is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.experimentID)
    value = (value * 31) ^ hash(self.projectID)
    value = (value * 31) ^ hash(self.creationTime)
    value = (value * 31) ^ hash(self.userName)
    value = (value * 31) ^ hash(self.name)
    value = (value * 31) ^ hash(self.description)
    value = (value * 31) ^ hash(self.applicationId)
    value = (value * 31) ^ hash(self.experimentStatus)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class ExperimentStatistics:
  """
  Attributes:
   - allExperimentCount
   - completedExperimentCount
   - cancelledExperimentCount
   - failedExperimentCount
   - allExperiments
   - completedExperiments
   - failedExperiments
   - cancelledExperiments
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'allExperimentCount', None, None, ), # 1
    (2, TType.I32, 'completedExperimentCount', None, None, ), # 2
    (3, TType.I32, 'cancelledExperimentCount', None, None, ), # 3
    (4, TType.I32, 'failedExperimentCount', None, None, ), # 4
    (5, TType.LIST, 'allExperiments', (TType.STRUCT,(ExperimentSummary, ExperimentSummary.thrift_spec)), None, ), # 5
    (6, TType.LIST, 'completedExperiments', (TType.STRUCT,(ExperimentSummary, ExperimentSummary.thrift_spec)), None, ), # 6
    (7, TType.LIST, 'failedExperiments', (TType.STRUCT,(ExperimentSummary, ExperimentSummary.thrift_spec)), None, ), # 7
    (8, TType.LIST, 'cancelledExperiments', (TType.STRUCT,(ExperimentSummary, ExperimentSummary.thrift_spec)), None, ), # 8
  )

  def __init__(self, allExperimentCount=None, completedExperimentCount=None, cancelledExperimentCount=None, failedExperimentCount=None, allExperiments=None, completedExperiments=None, failedExperiments=None, cancelledExperiments=None,):
    self.allExperimentCount = allExperimentCount
    self.completedExperimentCount = completedExperimentCount
    self.cancelledExperimentCount = cancelledExperimentCount
    self.failedExperimentCount = failedExperimentCount
    self.allExperiments = allExperiments
    self.completedExperiments = completedExperiments
    self.failedExperiments = failedExperiments
    self.cancelledExperiments = cancelledExperiments

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.allExperimentCount = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.completedExperimentCount = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.cancelledExperimentCount = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.failedExperimentCount = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.LIST:
          self.allExperiments = []
          (_etype136, _size133) = iprot.readListBegin()
          for _i137 in xrange(_size133):
            _elem138 = ExperimentSummary()
            _elem138.read(iprot)
            self.allExperiments.append(_elem138)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.LIST:
          self.completedExperiments = []
          (_etype142, _size139) = iprot.readListBegin()
          for _i143 in xrange(_size139):
            _elem144 = ExperimentSummary()
            _elem144.read(iprot)
            self.completedExperiments.append(_elem144)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.LIST:
          self.failedExperiments = []
          (_etype148, _size145) = iprot.readListBegin()
          for _i149 in xrange(_size145):
            _elem150 = ExperimentSummary()
            _elem150.read(iprot)
            self.failedExperiments.append(_elem150)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.LIST:
          self.cancelledExperiments = []
          (_etype154, _size151) = iprot.readListBegin()
          for _i155 in xrange(_size151):
            _elem156 = ExperimentSummary()
            _elem156.read(iprot)
            self.cancelledExperiments.append(_elem156)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('ExperimentStatistics')
    if self.allExperimentCount is not None:
      oprot.writeFieldBegin('allExperimentCount', TType.I32, 1)
      oprot.writeI32(self.allExperimentCount)
      oprot.writeFieldEnd()
    if self.completedExperimentCount is not None:
      oprot.writeFieldBegin('completedExperimentCount', TType.I32, 2)
      oprot.writeI32(self.completedExperimentCount)
      oprot.writeFieldEnd()
    if self.cancelledExperimentCount is not None:
      oprot.writeFieldBegin('cancelledExperimentCount', TType.I32, 3)
      oprot.writeI32(self.cancelledExperimentCount)
      oprot.writeFieldEnd()
    if self.failedExperimentCount is not None:
      oprot.writeFieldBegin('failedExperimentCount', TType.I32, 4)
      oprot.writeI32(self.failedExperimentCount)
      oprot.writeFieldEnd()
    if self.allExperiments is not None:
      oprot.writeFieldBegin('allExperiments', TType.LIST, 5)
      oprot.writeListBegin(TType.STRUCT, len(self.allExperiments))
      for iter157 in self.allExperiments:
        iter157.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.completedExperiments is not None:
      oprot.writeFieldBegin('completedExperiments', TType.LIST, 6)
      oprot.writeListBegin(TType.STRUCT, len(self.completedExperiments))
      for iter158 in self.completedExperiments:
        iter158.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.failedExperiments is not None:
      oprot.writeFieldBegin('failedExperiments', TType.LIST, 7)
      oprot.writeListBegin(TType.STRUCT, len(self.failedExperiments))
      for iter159 in self.failedExperiments:
        iter159.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.cancelledExperiments is not None:
      oprot.writeFieldBegin('cancelledExperiments', TType.LIST, 8)
      oprot.writeListBegin(TType.STRUCT, len(self.cancelledExperiments))
      for iter160 in self.cancelledExperiments:
        iter160.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.allExperimentCount is None:
      raise TProtocol.TProtocolException(message='Required field allExperimentCount is unset!')
    if self.completedExperimentCount is None:
      raise TProtocol.TProtocolException(message='Required field completedExperimentCount is unset!')
    if self.failedExperimentCount is None:
      raise TProtocol.TProtocolException(message='Required field failedExperimentCount is unset!')
    if self.allExperiments is None:
      raise TProtocol.TProtocolException(message='Required field allExperiments is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.allExperimentCount)
    value = (value * 31) ^ hash(self.completedExperimentCount)
    value = (value * 31) ^ hash(self.cancelledExperimentCount)
    value = (value * 31) ^ hash(self.failedExperimentCount)
    value = (value * 31) ^ hash(self.allExperiments)
    value = (value * 31) ^ hash(self.completedExperiments)
    value = (value * 31) ^ hash(self.failedExperiments)
    value = (value * 31) ^ hash(self.cancelledExperiments)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)
