#
# Autogenerated by Thrift Compiler (0.9.1)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
#  options string: py
#

from thrift.Thrift import TType, TMessageType, TException, TApplicationException

from thrift.transport import TTransport
from thrift.protocol import TBinaryProtocol, TProtocol
try:
  from thrift.protocol import fastbinary
except:
  fastbinary = None


class ResourceJobManagerType:
  """
  * Enumeration of local resource job manager types supported by Airavata
  *
  * FORK:
  *  Forking of commands without any job manager
  *
  * PBS:
  *  Job manager supporting the Portal Batch System (PBS) protocol. Some examples include TORQUE, PBSPro, Grid Engine.
  *
  * SLURM:
  *  The Simple Linux Utility for Resource Management is a open source workload manager.
   *
   * UGE:
   *  Univa Grid Engine, a variation of PBS implementation.
   *
   * LSF:
   *  IBM Platform Load Sharing Facility is dominantly installed on IBM clusters.
  *
  """
  FORK = 0
  PBS = 1
  SLURM = 2
  LSF = 3
  UGE = 4

  _VALUES_TO_NAMES = {
    0: "FORK",
    1: "PBS",
    2: "SLURM",
    3: "LSF",
    4: "UGE",
  }

  _NAMES_TO_VALUES = {
    "FORK": 0,
    "PBS": 1,
    "SLURM": 2,
    "LSF": 3,
    "UGE": 4,
  }

class JobManagerCommand:
  """
  Enumeration of resource job manager commands

  SUBMISSION:
   Ex: qsub, sbatch

  JOBMONITORING:
   Ex: qstat, squeue

  DELETION:
   Ex: qdel, scancel

  CHECK_JOB:
   Detailed Status about the Job. Ex: checkjob

  SHOW_QUEUE:
   List of Queued Job by the schedular. Ex: showq

  SHOW_RESERVATION:
   List all reservations. Ex:showres, show_res

  SHOW_START:
   Display the start time of the specified job. Ex: showstart

  """
  SUBMISSION = 0
  JOB_MONITORING = 1
  DELETION = 2
  CHECK_JOB = 3
  SHOW_QUEUE = 4
  SHOW_RESERVATION = 5
  SHOW_START = 6

  _VALUES_TO_NAMES = {
    0: "SUBMISSION",
    1: "JOB_MONITORING",
    2: "DELETION",
    3: "CHECK_JOB",
    4: "SHOW_QUEUE",
    5: "SHOW_RESERVATION",
    6: "SHOW_START",
  }

  _NAMES_TO_VALUES = {
    "SUBMISSION": 0,
    "JOB_MONITORING": 1,
    "DELETION": 2,
    "CHECK_JOB": 3,
    "SHOW_QUEUE": 4,
    "SHOW_RESERVATION": 5,
    "SHOW_START": 6,
  }

class FileSystems:
  """
  Enumeration of File Systems on the resource

  FORK:
   Forking of commands without any job manager

  PBS:
   Job manager supporting the Portal Batch System (PBS) protocol. Some examples include TORQUE, PBSPro, Grid Engine.

  UGE:
   Univa Grid Engine, a variation of PBS implementation.

  SLURM:
   The Simple Linux Utility for Resource Management is a open source workload manager.

  """
  HOME = 0
  WORK = 1
  LOCALTMP = 2
  SCRATCH = 3
  ARCHIVE = 4

  _VALUES_TO_NAMES = {
    0: "HOME",
    1: "WORK",
    2: "LOCALTMP",
    3: "SCRATCH",
    4: "ARCHIVE",
  }

  _NAMES_TO_VALUES = {
    "HOME": 0,
    "WORK": 1,
    "LOCALTMP": 2,
    "SCRATCH": 3,
    "ARCHIVE": 4,
  }

class SecurityProtocol:
  """
  Enumeration of security authentication and authorization mechanisms supported by Airavata. This enumeration just
   describes the supported mechanism. The corresponding security credentials are registered with Airavata Credential
   store.

  USERNAME_PASSWORD:
   A User Name.

  SSH_KEYS:
   SSH Keys

  FIXME: Change GSI to a more precise generic security protocol - X509

  """
  USERNAME_PASSWORD = 0
  SSH_KEYS = 1
  GSI = 2
  KERBEROS = 3
  OAUTH = 4

  _VALUES_TO_NAMES = {
    0: "USERNAME_PASSWORD",
    1: "SSH_KEYS",
    2: "GSI",
    3: "KERBEROS",
    4: "OAUTH",
  }

  _NAMES_TO_VALUES = {
    "USERNAME_PASSWORD": 0,
    "SSH_KEYS": 1,
    "GSI": 2,
    "KERBEROS": 3,
    "OAUTH": 4,
  }

class JobSubmissionProtocol:
  """
  Enumeration of Airavata supported Job Submission Mechanisms for High Performance Computing Clusters.

  SSH:
   Execute remote job submission commands using via secure shell protocol.

  GRAM:
   Execute remote jobs via Globus GRAM service.

  UNICORE:
   Execute remote jobs via Unicore services

  """
  LOCAL = 0
  SSH = 1
  GLOBUS = 2
  UNICORE = 3
  CLOUD = 4

  _VALUES_TO_NAMES = {
    0: "LOCAL",
    1: "SSH",
    2: "GLOBUS",
    3: "UNICORE",
    4: "CLOUD",
  }

  _NAMES_TO_VALUES = {
    "LOCAL": 0,
    "SSH": 1,
    "GLOBUS": 2,
    "UNICORE": 3,
    "CLOUD": 4,
  }

class MonitorMode:
  """
  Monitoring modes

  POLL_JOB_MANAGER:
  GFac need to pull job status changes.

  XSEDE_AMQP_SUBSCRIBE:
  Server will publish job status changes to amqp servert.


  """
  POLL_JOB_MANAGER = 0
  XSEDE_AMQP_SUBSCRIBE = 1

  _VALUES_TO_NAMES = {
    0: "POLL_JOB_MANAGER",
    1: "XSEDE_AMQP_SUBSCRIBE",
  }

  _NAMES_TO_VALUES = {
    "POLL_JOB_MANAGER": 0,
    "XSEDE_AMQP_SUBSCRIBE": 1,
  }

class DataMovementProtocol:
  """
  Enumeration of data movement supported by Airavata

  SCP:
   Job manager supporting the Portal Batch System (PBS) protocol. Some examples include TORQUE, PBSPro, Grid Engine.

  SFTP:
   The Simple Linux Utility for Resource Management is a open source workload manager.

  GridFTP:
   Globus File Transfer Protocol

  UNICORE_STORAGE_SERVICE:
   Storage Service Provided by Unicore

  """
  LOCAL = 0
  SCP = 1
  SFTP = 2
  GridFTP = 3
  UNICORE_STORAGE_SERVICE = 4

  _VALUES_TO_NAMES = {
    0: "LOCAL",
    1: "SCP",
    2: "SFTP",
    3: "GridFTP",
    4: "UNICORE_STORAGE_SERVICE",
  }

  _NAMES_TO_VALUES = {
    "LOCAL": 0,
    "SCP": 1,
    "SFTP": 2,
    "GridFTP": 3,
    "UNICORE_STORAGE_SERVICE": 4,
  }

class ProviderName:
  """
  Provider name

  """
  EC2 = 0
  AWSEC2 = 1
  RACKSPACE = 2

  _VALUES_TO_NAMES = {
    0: "EC2",
    1: "AWSEC2",
    2: "RACKSPACE",
  }

  _NAMES_TO_VALUES = {
    "EC2": 0,
    "AWSEC2": 1,
    "RACKSPACE": 2,
  }


class ResourceJobManager:
  """
  Resource Job Manager Information

  resourceJobManagerType:
   A typical HPC cluster has a single Job Manager to manage the resources.

  pushMonitoringEndpoint:
   If the job manager pushes out state changes to a database or bus, specify the service endpoint.
    Ex: Moab Web Service, Moab MongoDB URL, AMQP (GLUE2) Broker

  jobManagerBinPath:
   Path to the Job Manager Installation Binary directory.

  jobManagerCommands:
   An enumeration of commonly used manager commands.


  Attributes:
   - resourceJobManagerId
   - resourceJobManagerType
   - pushMonitoringEndpoint
   - jobManagerBinPath
   - jobManagerCommands
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'resourceJobManagerId', None, "DO_NOT_SET_AT_CLIENTS", ), # 1
    (2, TType.I32, 'resourceJobManagerType', None, None, ), # 2
    (3, TType.STRING, 'pushMonitoringEndpoint', None, None, ), # 3
    (4, TType.STRING, 'jobManagerBinPath', None, None, ), # 4
    (5, TType.MAP, 'jobManagerCommands', (TType.I32,None,TType.STRING,None), None, ), # 5
  )

  def __init__(self, resourceJobManagerId=thrift_spec[1][4], resourceJobManagerType=None, pushMonitoringEndpoint=None, jobManagerBinPath=None, jobManagerCommands=None,):
    self.resourceJobManagerId = resourceJobManagerId
    self.resourceJobManagerType = resourceJobManagerType
    self.pushMonitoringEndpoint = pushMonitoringEndpoint
    self.jobManagerBinPath = jobManagerBinPath
    self.jobManagerCommands = jobManagerCommands

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.resourceJobManagerId = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.resourceJobManagerType = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.pushMonitoringEndpoint = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.jobManagerBinPath = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.MAP:
          self.jobManagerCommands = {}
          (_ktype1, _vtype2, _size0 ) = iprot.readMapBegin()
          for _i4 in xrange(_size0):
            _key5 = iprot.readI32();
            _val6 = iprot.readString();
            self.jobManagerCommands[_key5] = _val6
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('ResourceJobManager')
    if self.resourceJobManagerId is not None:
      oprot.writeFieldBegin('resourceJobManagerId', TType.STRING, 1)
      oprot.writeString(self.resourceJobManagerId)
      oprot.writeFieldEnd()
    if self.resourceJobManagerType is not None:
      oprot.writeFieldBegin('resourceJobManagerType', TType.I32, 2)
      oprot.writeI32(self.resourceJobManagerType)
      oprot.writeFieldEnd()
    if self.pushMonitoringEndpoint is not None:
      oprot.writeFieldBegin('pushMonitoringEndpoint', TType.STRING, 3)
      oprot.writeString(self.pushMonitoringEndpoint)
      oprot.writeFieldEnd()
    if self.jobManagerBinPath is not None:
      oprot.writeFieldBegin('jobManagerBinPath', TType.STRING, 4)
      oprot.writeString(self.jobManagerBinPath)
      oprot.writeFieldEnd()
    if self.jobManagerCommands is not None:
      oprot.writeFieldBegin('jobManagerCommands', TType.MAP, 5)
      oprot.writeMapBegin(TType.I32, TType.STRING, len(self.jobManagerCommands))
      for kiter7,viter8 in self.jobManagerCommands.items():
        oprot.writeI32(kiter7)
        oprot.writeString(viter8)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.resourceJobManagerId is None:
      raise TProtocol.TProtocolException(message='Required field resourceJobManagerId is unset!')
    if self.resourceJobManagerType is None:
      raise TProtocol.TProtocolException(message='Required field resourceJobManagerType is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class BatchQueue:
  """
  Batch Queue Information on SuperComputers

  maxRunTime:
   Maximum allowed run time in hours.

  Attributes:
   - queueName
   - queueDescription
   - maxRunTime
   - maxNodes
   - maxProcessors
   - maxJobsInQueue
   - maxMemory
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'queueName', None, None, ), # 1
    (2, TType.STRING, 'queueDescription', None, None, ), # 2
    (3, TType.I32, 'maxRunTime', None, None, ), # 3
    (4, TType.I32, 'maxNodes', None, None, ), # 4
    (5, TType.I32, 'maxProcessors', None, None, ), # 5
    (6, TType.I32, 'maxJobsInQueue', None, None, ), # 6
    (7, TType.I32, 'maxMemory', None, None, ), # 7
  )

  def __init__(self, queueName=None, queueDescription=None, maxRunTime=None, maxNodes=None, maxProcessors=None, maxJobsInQueue=None, maxMemory=None,):
    self.queueName = queueName
    self.queueDescription = queueDescription
    self.maxRunTime = maxRunTime
    self.maxNodes = maxNodes
    self.maxProcessors = maxProcessors
    self.maxJobsInQueue = maxJobsInQueue
    self.maxMemory = maxMemory

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.queueName = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.queueDescription = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.maxRunTime = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.maxNodes = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.I32:
          self.maxProcessors = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.I32:
          self.maxJobsInQueue = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.I32:
          self.maxMemory = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('BatchQueue')
    if self.queueName is not None:
      oprot.writeFieldBegin('queueName', TType.STRING, 1)
      oprot.writeString(self.queueName)
      oprot.writeFieldEnd()
    if self.queueDescription is not None:
      oprot.writeFieldBegin('queueDescription', TType.STRING, 2)
      oprot.writeString(self.queueDescription)
      oprot.writeFieldEnd()
    if self.maxRunTime is not None:
      oprot.writeFieldBegin('maxRunTime', TType.I32, 3)
      oprot.writeI32(self.maxRunTime)
      oprot.writeFieldEnd()
    if self.maxNodes is not None:
      oprot.writeFieldBegin('maxNodes', TType.I32, 4)
      oprot.writeI32(self.maxNodes)
      oprot.writeFieldEnd()
    if self.maxProcessors is not None:
      oprot.writeFieldBegin('maxProcessors', TType.I32, 5)
      oprot.writeI32(self.maxProcessors)
      oprot.writeFieldEnd()
    if self.maxJobsInQueue is not None:
      oprot.writeFieldBegin('maxJobsInQueue', TType.I32, 6)
      oprot.writeI32(self.maxJobsInQueue)
      oprot.writeFieldEnd()
    if self.maxMemory is not None:
      oprot.writeFieldBegin('maxMemory', TType.I32, 7)
      oprot.writeI32(self.maxMemory)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.queueName is None:
      raise TProtocol.TProtocolException(message='Required field queueName is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class SCPDataMovement:
  """
  Data Movement through Secured Copy

  alternativeSCPHostName:
   If the login to scp is different than the hostname itself, specify it here

  sshPort:
   If a non-default port needs to used, specify it.

  Attributes:
   - dataMovementInterfaceId
   - securityProtocol
   - alternativeSCPHostName
   - sshPort
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'dataMovementInterfaceId', None, "DO_NOT_SET_AT_CLIENTS", ), # 1
    (2, TType.I32, 'securityProtocol', None, None, ), # 2
    (3, TType.STRING, 'alternativeSCPHostName', None, None, ), # 3
    (4, TType.I32, 'sshPort', None, 22, ), # 4
  )

  def __init__(self, dataMovementInterfaceId=thrift_spec[1][4], securityProtocol=None, alternativeSCPHostName=None, sshPort=thrift_spec[4][4],):
    self.dataMovementInterfaceId = dataMovementInterfaceId
    self.securityProtocol = securityProtocol
    self.alternativeSCPHostName = alternativeSCPHostName
    self.sshPort = sshPort

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.dataMovementInterfaceId = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.securityProtocol = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.alternativeSCPHostName = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.sshPort = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('SCPDataMovement')
    if self.dataMovementInterfaceId is not None:
      oprot.writeFieldBegin('dataMovementInterfaceId', TType.STRING, 1)
      oprot.writeString(self.dataMovementInterfaceId)
      oprot.writeFieldEnd()
    if self.securityProtocol is not None:
      oprot.writeFieldBegin('securityProtocol', TType.I32, 2)
      oprot.writeI32(self.securityProtocol)
      oprot.writeFieldEnd()
    if self.alternativeSCPHostName is not None:
      oprot.writeFieldBegin('alternativeSCPHostName', TType.STRING, 3)
      oprot.writeString(self.alternativeSCPHostName)
      oprot.writeFieldEnd()
    if self.sshPort is not None:
      oprot.writeFieldBegin('sshPort', TType.I32, 4)
      oprot.writeI32(self.sshPort)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.dataMovementInterfaceId is None:
      raise TProtocol.TProtocolException(message='Required field dataMovementInterfaceId is unset!')
    if self.securityProtocol is None:
      raise TProtocol.TProtocolException(message='Required field securityProtocol is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class GridFTPDataMovement:
  """
  Data Movement through GridFTP

  alternativeSCPHostName:
   If the login to scp is different than the hostname itself, specify it here

  sshPort:
   If a non-default port needs to used, specify it.

  Attributes:
   - dataMovementInterfaceId
   - securityProtocol
   - gridFTPEndPoints
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'dataMovementInterfaceId', None, "DO_NOT_SET_AT_CLIENTS", ), # 1
    (2, TType.I32, 'securityProtocol', None, None, ), # 2
    (3, TType.LIST, 'gridFTPEndPoints', (TType.STRING,None), None, ), # 3
  )

  def __init__(self, dataMovementInterfaceId=thrift_spec[1][4], securityProtocol=None, gridFTPEndPoints=None,):
    self.dataMovementInterfaceId = dataMovementInterfaceId
    self.securityProtocol = securityProtocol
    self.gridFTPEndPoints = gridFTPEndPoints

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.dataMovementInterfaceId = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.securityProtocol = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.gridFTPEndPoints = []
          (_etype12, _size9) = iprot.readListBegin()
          for _i13 in xrange(_size9):
            _elem14 = iprot.readString();
            self.gridFTPEndPoints.append(_elem14)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('GridFTPDataMovement')
    if self.dataMovementInterfaceId is not None:
      oprot.writeFieldBegin('dataMovementInterfaceId', TType.STRING, 1)
      oprot.writeString(self.dataMovementInterfaceId)
      oprot.writeFieldEnd()
    if self.securityProtocol is not None:
      oprot.writeFieldBegin('securityProtocol', TType.I32, 2)
      oprot.writeI32(self.securityProtocol)
      oprot.writeFieldEnd()
    if self.gridFTPEndPoints is not None:
      oprot.writeFieldBegin('gridFTPEndPoints', TType.LIST, 3)
      oprot.writeListBegin(TType.STRING, len(self.gridFTPEndPoints))
      for iter15 in self.gridFTPEndPoints:
        oprot.writeString(iter15)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.dataMovementInterfaceId is None:
      raise TProtocol.TProtocolException(message='Required field dataMovementInterfaceId is unset!')
    if self.securityProtocol is None:
      raise TProtocol.TProtocolException(message='Required field securityProtocol is unset!')
    if self.gridFTPEndPoints is None:
      raise TProtocol.TProtocolException(message='Required field gridFTPEndPoints is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class UnicoreDataMovement:
  """
  Data Movement through UnicoreStorage

  unicoreEndPointURL:
   unicoreGateway End Point. The provider will query this service to fetch required service end points.

  Attributes:
   - dataMovementInterfaceId
   - securityProtocol
   - unicoreEndPointURL
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'dataMovementInterfaceId', None, "DO_NOT_SET_AT_CLIENTS", ), # 1
    (2, TType.I32, 'securityProtocol', None, None, ), # 2
    (3, TType.STRING, 'unicoreEndPointURL', None, None, ), # 3
  )

  def __init__(self, dataMovementInterfaceId=thrift_spec[1][4], securityProtocol=None, unicoreEndPointURL=None,):
    self.dataMovementInterfaceId = dataMovementInterfaceId
    self.securityProtocol = securityProtocol
    self.unicoreEndPointURL = unicoreEndPointURL

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.dataMovementInterfaceId = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.securityProtocol = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.unicoreEndPointURL = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('UnicoreDataMovement')
    if self.dataMovementInterfaceId is not None:
      oprot.writeFieldBegin('dataMovementInterfaceId', TType.STRING, 1)
      oprot.writeString(self.dataMovementInterfaceId)
      oprot.writeFieldEnd()
    if self.securityProtocol is not None:
      oprot.writeFieldBegin('securityProtocol', TType.I32, 2)
      oprot.writeI32(self.securityProtocol)
      oprot.writeFieldEnd()
    if self.unicoreEndPointURL is not None:
      oprot.writeFieldBegin('unicoreEndPointURL', TType.STRING, 3)
      oprot.writeString(self.unicoreEndPointURL)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.dataMovementInterfaceId is None:
      raise TProtocol.TProtocolException(message='Required field dataMovementInterfaceId is unset!')
    if self.securityProtocol is None:
      raise TProtocol.TProtocolException(message='Required field securityProtocol is unset!')
    if self.unicoreEndPointURL is None:
      raise TProtocol.TProtocolException(message='Required field unicoreEndPointURL is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class LOCALSubmission:
  """
  Locally Fork Jobs as OS processes

  alternativeSSHHostName:
   If the login to ssh is different than the hostname itself, specify it here

  sshPort:
   If a non-default port needs to used, specify it.

  Attributes:
   - jobSubmissionInterfaceId
   - resourceJobManager
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'jobSubmissionInterfaceId', None, "DO_NOT_SET_AT_CLIENTS", ), # 1
    (2, TType.STRUCT, 'resourceJobManager', (ResourceJobManager, ResourceJobManager.thrift_spec), None, ), # 2
  )

  def __init__(self, jobSubmissionInterfaceId=thrift_spec[1][4], resourceJobManager=None,):
    self.jobSubmissionInterfaceId = jobSubmissionInterfaceId
    self.resourceJobManager = resourceJobManager

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.jobSubmissionInterfaceId = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.resourceJobManager = ResourceJobManager()
          self.resourceJobManager.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('LOCALSubmission')
    if self.jobSubmissionInterfaceId is not None:
      oprot.writeFieldBegin('jobSubmissionInterfaceId', TType.STRING, 1)
      oprot.writeString(self.jobSubmissionInterfaceId)
      oprot.writeFieldEnd()
    if self.resourceJobManager is not None:
      oprot.writeFieldBegin('resourceJobManager', TType.STRUCT, 2)
      self.resourceJobManager.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.jobSubmissionInterfaceId is None:
      raise TProtocol.TProtocolException(message='Required field jobSubmissionInterfaceId is unset!')
    if self.resourceJobManager is None:
      raise TProtocol.TProtocolException(message='Required field resourceJobManager is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class LOCALDataMovement:
  """
  LOCAL

  alternativeSCPHostName:
   If the login to scp is different than the hostname itself, specify it here

  sshPort:
   If a non-defualt port needs to used, specify it.

  Attributes:
   - dataMovementInterfaceId
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'dataMovementInterfaceId', None, "DO_NOT_SET_AT_CLIENTS", ), # 1
  )

  def __init__(self, dataMovementInterfaceId=thrift_spec[1][4],):
    self.dataMovementInterfaceId = dataMovementInterfaceId

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.dataMovementInterfaceId = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('LOCALDataMovement')
    if self.dataMovementInterfaceId is not None:
      oprot.writeFieldBegin('dataMovementInterfaceId', TType.STRING, 1)
      oprot.writeString(self.dataMovementInterfaceId)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.dataMovementInterfaceId is None:
      raise TProtocol.TProtocolException(message='Required field dataMovementInterfaceId is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class SSHJobSubmission:
  """
  Authenticate using Secured Shell

  alternativeSSHHostName:
   If the login to ssh is different than the hostname itself, specify it here

  sshPort:
   If a non-default port needs to used, specify it.

  Attributes:
   - jobSubmissionInterfaceId
   - securityProtocol
   - resourceJobManager
   - alternativeSSHHostName
   - sshPort
   - monitorMode
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'jobSubmissionInterfaceId', None, "DO_NOT_SET_AT_CLIENTS", ), # 1
    (2, TType.I32, 'securityProtocol', None, None, ), # 2
    (3, TType.STRUCT, 'resourceJobManager', (ResourceJobManager, ResourceJobManager.thrift_spec), None, ), # 3
    (4, TType.STRING, 'alternativeSSHHostName', None, None, ), # 4
    (5, TType.I32, 'sshPort', None, 22, ), # 5
    (6, TType.I32, 'monitorMode', None, None, ), # 6
  )

  def __init__(self, jobSubmissionInterfaceId=thrift_spec[1][4], securityProtocol=None, resourceJobManager=None, alternativeSSHHostName=None, sshPort=thrift_spec[5][4], monitorMode=None,):
    self.jobSubmissionInterfaceId = jobSubmissionInterfaceId
    self.securityProtocol = securityProtocol
    self.resourceJobManager = resourceJobManager
    self.alternativeSSHHostName = alternativeSSHHostName
    self.sshPort = sshPort
    self.monitorMode = monitorMode

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.jobSubmissionInterfaceId = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.securityProtocol = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.resourceJobManager = ResourceJobManager()
          self.resourceJobManager.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.alternativeSSHHostName = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.I32:
          self.sshPort = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.I32:
          self.monitorMode = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('SSHJobSubmission')
    if self.jobSubmissionInterfaceId is not None:
      oprot.writeFieldBegin('jobSubmissionInterfaceId', TType.STRING, 1)
      oprot.writeString(self.jobSubmissionInterfaceId)
      oprot.writeFieldEnd()
    if self.securityProtocol is not None:
      oprot.writeFieldBegin('securityProtocol', TType.I32, 2)
      oprot.writeI32(self.securityProtocol)
      oprot.writeFieldEnd()
    if self.resourceJobManager is not None:
      oprot.writeFieldBegin('resourceJobManager', TType.STRUCT, 3)
      self.resourceJobManager.write(oprot)
      oprot.writeFieldEnd()
    if self.alternativeSSHHostName is not None:
      oprot.writeFieldBegin('alternativeSSHHostName', TType.STRING, 4)
      oprot.writeString(self.alternativeSSHHostName)
      oprot.writeFieldEnd()
    if self.sshPort is not None:
      oprot.writeFieldBegin('sshPort', TType.I32, 5)
      oprot.writeI32(self.sshPort)
      oprot.writeFieldEnd()
    if self.monitorMode is not None:
      oprot.writeFieldBegin('monitorMode', TType.I32, 6)
      oprot.writeI32(self.monitorMode)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.jobSubmissionInterfaceId is None:
      raise TProtocol.TProtocolException(message='Required field jobSubmissionInterfaceId is unset!')
    if self.securityProtocol is None:
      raise TProtocol.TProtocolException(message='Required field securityProtocol is unset!')
    if self.resourceJobManager is None:
      raise TProtocol.TProtocolException(message='Required field resourceJobManager is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class GlobusJobSubmission:
  """
  Attributes:
   - jobSubmissionInterfaceId
   - securityProtocol
   - globusGateKeeperEndPoint
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'jobSubmissionInterfaceId', None, "DO_NOT_SET_AT_CLIENTS", ), # 1
    (2, TType.I32, 'securityProtocol', None, None, ), # 2
    (3, TType.LIST, 'globusGateKeeperEndPoint', (TType.STRING,None), None, ), # 3
  )

  def __init__(self, jobSubmissionInterfaceId=thrift_spec[1][4], securityProtocol=None, globusGateKeeperEndPoint=None,):
    self.jobSubmissionInterfaceId = jobSubmissionInterfaceId
    self.securityProtocol = securityProtocol
    self.globusGateKeeperEndPoint = globusGateKeeperEndPoint

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.jobSubmissionInterfaceId = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.securityProtocol = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.globusGateKeeperEndPoint = []
          (_etype19, _size16) = iprot.readListBegin()
          for _i20 in xrange(_size16):
            _elem21 = iprot.readString();
            self.globusGateKeeperEndPoint.append(_elem21)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('GlobusJobSubmission')
    if self.jobSubmissionInterfaceId is not None:
      oprot.writeFieldBegin('jobSubmissionInterfaceId', TType.STRING, 1)
      oprot.writeString(self.jobSubmissionInterfaceId)
      oprot.writeFieldEnd()
    if self.securityProtocol is not None:
      oprot.writeFieldBegin('securityProtocol', TType.I32, 2)
      oprot.writeI32(self.securityProtocol)
      oprot.writeFieldEnd()
    if self.globusGateKeeperEndPoint is not None:
      oprot.writeFieldBegin('globusGateKeeperEndPoint', TType.LIST, 3)
      oprot.writeListBegin(TType.STRING, len(self.globusGateKeeperEndPoint))
      for iter22 in self.globusGateKeeperEndPoint:
        oprot.writeString(iter22)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.jobSubmissionInterfaceId is None:
      raise TProtocol.TProtocolException(message='Required field jobSubmissionInterfaceId is unset!')
    if self.securityProtocol is None:
      raise TProtocol.TProtocolException(message='Required field securityProtocol is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class UnicoreJobSubmission:
  """
  Unicore Job Submission

  unicoreEndPointURL:
   unicoreGateway End Point. The provider will query this service to fetch required service end points.
  authenticationMode
   The authenticationMode defines the way certificate is fetched.

  Attributes:
   - jobSubmissionInterfaceId
   - securityProtocol
   - unicoreEndPointURL
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'jobSubmissionInterfaceId', None, "DO_NOT_SET_AT_CLIENTS", ), # 1
    (2, TType.I32, 'securityProtocol', None, None, ), # 2
    (3, TType.STRING, 'unicoreEndPointURL', None, None, ), # 3
  )

  def __init__(self, jobSubmissionInterfaceId=thrift_spec[1][4], securityProtocol=None, unicoreEndPointURL=None,):
    self.jobSubmissionInterfaceId = jobSubmissionInterfaceId
    self.securityProtocol = securityProtocol
    self.unicoreEndPointURL = unicoreEndPointURL

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.jobSubmissionInterfaceId = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.securityProtocol = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.unicoreEndPointURL = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('UnicoreJobSubmission')
    if self.jobSubmissionInterfaceId is not None:
      oprot.writeFieldBegin('jobSubmissionInterfaceId', TType.STRING, 1)
      oprot.writeString(self.jobSubmissionInterfaceId)
      oprot.writeFieldEnd()
    if self.securityProtocol is not None:
      oprot.writeFieldBegin('securityProtocol', TType.I32, 2)
      oprot.writeI32(self.securityProtocol)
      oprot.writeFieldEnd()
    if self.unicoreEndPointURL is not None:
      oprot.writeFieldBegin('unicoreEndPointURL', TType.STRING, 3)
      oprot.writeString(self.unicoreEndPointURL)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.jobSubmissionInterfaceId is None:
      raise TProtocol.TProtocolException(message='Required field jobSubmissionInterfaceId is unset!')
    if self.securityProtocol is None:
      raise TProtocol.TProtocolException(message='Required field securityProtocol is unset!')
    if self.unicoreEndPointURL is None:
      raise TProtocol.TProtocolException(message='Required field unicoreEndPointURL is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class CloudJobSubmission:
  """
  Cloud Job Submission



  Attributes:
   - jobSubmissionInterfaceId
   - securityProtocol
   - nodeId
   - executableType
   - providerName
   - userAccountName
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'jobSubmissionInterfaceId', None, "DO_NOT_SET_AT_CLIENTS", ), # 1
    (2, TType.I32, 'securityProtocol', None, None, ), # 2
    (3, TType.STRING, 'nodeId', None, None, ), # 3
    (4, TType.STRING, 'executableType', None, None, ), # 4
    (5, TType.I32, 'providerName', None, None, ), # 5
    (6, TType.STRING, 'userAccountName', None, None, ), # 6
  )

  def __init__(self, jobSubmissionInterfaceId=thrift_spec[1][4], securityProtocol=None, nodeId=None, executableType=None, providerName=None, userAccountName=None,):
    self.jobSubmissionInterfaceId = jobSubmissionInterfaceId
    self.securityProtocol = securityProtocol
    self.nodeId = nodeId
    self.executableType = executableType
    self.providerName = providerName
    self.userAccountName = userAccountName

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.jobSubmissionInterfaceId = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.securityProtocol = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.nodeId = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.executableType = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.I32:
          self.providerName = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRING:
          self.userAccountName = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('CloudJobSubmission')
    if self.jobSubmissionInterfaceId is not None:
      oprot.writeFieldBegin('jobSubmissionInterfaceId', TType.STRING, 1)
      oprot.writeString(self.jobSubmissionInterfaceId)
      oprot.writeFieldEnd()
    if self.securityProtocol is not None:
      oprot.writeFieldBegin('securityProtocol', TType.I32, 2)
      oprot.writeI32(self.securityProtocol)
      oprot.writeFieldEnd()
    if self.nodeId is not None:
      oprot.writeFieldBegin('nodeId', TType.STRING, 3)
      oprot.writeString(self.nodeId)
      oprot.writeFieldEnd()
    if self.executableType is not None:
      oprot.writeFieldBegin('executableType', TType.STRING, 4)
      oprot.writeString(self.executableType)
      oprot.writeFieldEnd()
    if self.providerName is not None:
      oprot.writeFieldBegin('providerName', TType.I32, 5)
      oprot.writeI32(self.providerName)
      oprot.writeFieldEnd()
    if self.userAccountName is not None:
      oprot.writeFieldBegin('userAccountName', TType.STRING, 6)
      oprot.writeString(self.userAccountName)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.jobSubmissionInterfaceId is None:
      raise TProtocol.TProtocolException(message='Required field jobSubmissionInterfaceId is unset!')
    if self.securityProtocol is None:
      raise TProtocol.TProtocolException(message='Required field securityProtocol is unset!')
    if self.nodeId is None:
      raise TProtocol.TProtocolException(message='Required field nodeId is unset!')
    if self.executableType is None:
      raise TProtocol.TProtocolException(message='Required field executableType is unset!')
    if self.providerName is None:
      raise TProtocol.TProtocolException(message='Required field providerName is unset!')
    if self.userAccountName is None:
      raise TProtocol.TProtocolException(message='Required field userAccountName is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class JobSubmissionInterface:
  """
  Job Submission Interfaces

  jobSubmissionInterfaceId: The Job Submission Interface has to be previously registered and referenced here.

  priorityOrder:
   For resources with multiple interfaces, the priority order should be selected.
    Lower the numerical number, higher the priority


  Attributes:
   - jobSubmissionInterfaceId
   - jobSubmissionProtocol
   - priorityOrder
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'jobSubmissionInterfaceId', None, None, ), # 1
    (2, TType.I32, 'jobSubmissionProtocol', None, None, ), # 2
    (3, TType.I32, 'priorityOrder', None, 0, ), # 3
  )

  def __init__(self, jobSubmissionInterfaceId=None, jobSubmissionProtocol=None, priorityOrder=thrift_spec[3][4],):
    self.jobSubmissionInterfaceId = jobSubmissionInterfaceId
    self.jobSubmissionProtocol = jobSubmissionProtocol
    self.priorityOrder = priorityOrder

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.jobSubmissionInterfaceId = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.jobSubmissionProtocol = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.priorityOrder = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('JobSubmissionInterface')
    if self.jobSubmissionInterfaceId is not None:
      oprot.writeFieldBegin('jobSubmissionInterfaceId', TType.STRING, 1)
      oprot.writeString(self.jobSubmissionInterfaceId)
      oprot.writeFieldEnd()
    if self.jobSubmissionProtocol is not None:
      oprot.writeFieldBegin('jobSubmissionProtocol', TType.I32, 2)
      oprot.writeI32(self.jobSubmissionProtocol)
      oprot.writeFieldEnd()
    if self.priorityOrder is not None:
      oprot.writeFieldBegin('priorityOrder', TType.I32, 3)
      oprot.writeI32(self.priorityOrder)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.jobSubmissionInterfaceId is None:
      raise TProtocol.TProtocolException(message='Required field jobSubmissionInterfaceId is unset!')
    if self.jobSubmissionProtocol is None:
      raise TProtocol.TProtocolException(message='Required field jobSubmissionProtocol is unset!')
    if self.priorityOrder is None:
      raise TProtocol.TProtocolException(message='Required field priorityOrder is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class DataMovementInterface:
  """
  Data Movement Interfaces

  dataMovementInterfaceId: The Data Movement Interface has to be previously registered and referenced here.

  priorityOrder:
   For resources with multiple interfaces, the priority order should be selected.
    Lower the numerical number, higher the priority


  Attributes:
   - dataMovementInterfaceId
   - dataMovementProtocol
   - priorityOrder
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'dataMovementInterfaceId', None, None, ), # 1
    (2, TType.I32, 'dataMovementProtocol', None, None, ), # 2
    (3, TType.I32, 'priorityOrder', None, 0, ), # 3
  )

  def __init__(self, dataMovementInterfaceId=None, dataMovementProtocol=None, priorityOrder=thrift_spec[3][4],):
    self.dataMovementInterfaceId = dataMovementInterfaceId
    self.dataMovementProtocol = dataMovementProtocol
    self.priorityOrder = priorityOrder

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.dataMovementInterfaceId = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.dataMovementProtocol = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.priorityOrder = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('DataMovementInterface')
    if self.dataMovementInterfaceId is not None:
      oprot.writeFieldBegin('dataMovementInterfaceId', TType.STRING, 1)
      oprot.writeString(self.dataMovementInterfaceId)
      oprot.writeFieldEnd()
    if self.dataMovementProtocol is not None:
      oprot.writeFieldBegin('dataMovementProtocol', TType.I32, 2)
      oprot.writeI32(self.dataMovementProtocol)
      oprot.writeFieldEnd()
    if self.priorityOrder is not None:
      oprot.writeFieldBegin('priorityOrder', TType.I32, 3)
      oprot.writeI32(self.priorityOrder)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.dataMovementInterfaceId is None:
      raise TProtocol.TProtocolException(message='Required field dataMovementInterfaceId is unset!')
    if self.dataMovementProtocol is None:
      raise TProtocol.TProtocolException(message='Required field dataMovementProtocol is unset!')
    if self.priorityOrder is None:
      raise TProtocol.TProtocolException(message='Required field priorityOrder is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class ComputeResourceDescription:
  """
  Computational Resource Description

  computeResourceId: Airavata Internal Unique Identifier to distinguish Compute Resource.

  hostName:
    Fully Qualified Host Name.

  hostAliases:
    Aliases if any.

  ipAddress:
    IP Addresses of the Resource.

  resourceDescription:
   A user friendly description of the resource.

  JobSubmissionProtocols:
   A computational resources may have one or more ways of submitting Jobs. This structure
     will hold all available mechanisms to interact with the resource.
   The key is the priority

  DataMovementProtocol:
   Option to specify a prefered data movement mechanism of the available options.

  fileSystems:
   Map of file systems type and the path.


  Attributes:
   - computeResourceId
   - hostName
   - hostAliases
   - ipAddresses
   - resourceDescription
   - batchQueues
   - fileSystems
   - jobSubmissionInterfaces
   - dataMovementInterfaces
   - maxMemoryPerNode
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'computeResourceId', None, "DO_NOT_SET_AT_CLIENTS", ), # 1
    (2, TType.STRING, 'hostName', None, None, ), # 2
    (3, TType.LIST, 'hostAliases', (TType.STRING,None), None, ), # 3
    (4, TType.LIST, 'ipAddresses', (TType.STRING,None), None, ), # 4
    (5, TType.STRING, 'resourceDescription', None, None, ), # 5
    (6, TType.LIST, 'batchQueues', (TType.STRUCT,(BatchQueue, BatchQueue.thrift_spec)), None, ), # 6
    (7, TType.MAP, 'fileSystems', (TType.I32,None,TType.STRING,None), None, ), # 7
    (8, TType.LIST, 'jobSubmissionInterfaces', (TType.STRUCT,(JobSubmissionInterface, JobSubmissionInterface.thrift_spec)), None, ), # 8
    (9, TType.LIST, 'dataMovementInterfaces', (TType.STRUCT,(DataMovementInterface, DataMovementInterface.thrift_spec)), None, ), # 9
    (10, TType.I32, 'maxMemoryPerNode', None, None, ), # 10
  )

  def __init__(self, computeResourceId=thrift_spec[1][4], hostName=None, hostAliases=None, ipAddresses=None, resourceDescription=None, batchQueues=None, fileSystems=None, jobSubmissionInterfaces=None, dataMovementInterfaces=None, maxMemoryPerNode=None,):
    self.computeResourceId = computeResourceId
    self.hostName = hostName
    self.hostAliases = hostAliases
    self.ipAddresses = ipAddresses
    self.resourceDescription = resourceDescription
    self.batchQueues = batchQueues
    self.fileSystems = fileSystems
    self.jobSubmissionInterfaces = jobSubmissionInterfaces
    self.dataMovementInterfaces = dataMovementInterfaces
    self.maxMemoryPerNode = maxMemoryPerNode

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.computeResourceId = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.hostName = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.hostAliases = []
          (_etype26, _size23) = iprot.readListBegin()
          for _i27 in xrange(_size23):
            _elem28 = iprot.readString();
            self.hostAliases.append(_elem28)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.LIST:
          self.ipAddresses = []
          (_etype32, _size29) = iprot.readListBegin()
          for _i33 in xrange(_size29):
            _elem34 = iprot.readString();
            self.ipAddresses.append(_elem34)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.resourceDescription = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.LIST:
          self.batchQueues = []
          (_etype38, _size35) = iprot.readListBegin()
          for _i39 in xrange(_size35):
            _elem40 = BatchQueue()
            _elem40.read(iprot)
            self.batchQueues.append(_elem40)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.MAP:
          self.fileSystems = {}
          (_ktype42, _vtype43, _size41 ) = iprot.readMapBegin()
          for _i45 in xrange(_size41):
            _key46 = iprot.readI32();
            _val47 = iprot.readString();
            self.fileSystems[_key46] = _val47
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.LIST:
          self.jobSubmissionInterfaces = []
          (_etype51, _size48) = iprot.readListBegin()
          for _i52 in xrange(_size48):
            _elem53 = JobSubmissionInterface()
            _elem53.read(iprot)
            self.jobSubmissionInterfaces.append(_elem53)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 9:
        if ftype == TType.LIST:
          self.dataMovementInterfaces = []
          (_etype57, _size54) = iprot.readListBegin()
          for _i58 in xrange(_size54):
            _elem59 = DataMovementInterface()
            _elem59.read(iprot)
            self.dataMovementInterfaces.append(_elem59)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 10:
        if ftype == TType.I32:
          self.maxMemoryPerNode = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('ComputeResourceDescription')
    if self.computeResourceId is not None:
      oprot.writeFieldBegin('computeResourceId', TType.STRING, 1)
      oprot.writeString(self.computeResourceId)
      oprot.writeFieldEnd()
    if self.hostName is not None:
      oprot.writeFieldBegin('hostName', TType.STRING, 2)
      oprot.writeString(self.hostName)
      oprot.writeFieldEnd()
    if self.hostAliases is not None:
      oprot.writeFieldBegin('hostAliases', TType.LIST, 3)
      oprot.writeListBegin(TType.STRING, len(self.hostAliases))
      for iter60 in self.hostAliases:
        oprot.writeString(iter60)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.ipAddresses is not None:
      oprot.writeFieldBegin('ipAddresses', TType.LIST, 4)
      oprot.writeListBegin(TType.STRING, len(self.ipAddresses))
      for iter61 in self.ipAddresses:
        oprot.writeString(iter61)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.resourceDescription is not None:
      oprot.writeFieldBegin('resourceDescription', TType.STRING, 5)
      oprot.writeString(self.resourceDescription)
      oprot.writeFieldEnd()
    if self.batchQueues is not None:
      oprot.writeFieldBegin('batchQueues', TType.LIST, 6)
      oprot.writeListBegin(TType.STRUCT, len(self.batchQueues))
      for iter62 in self.batchQueues:
        iter62.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.fileSystems is not None:
      oprot.writeFieldBegin('fileSystems', TType.MAP, 7)
      oprot.writeMapBegin(TType.I32, TType.STRING, len(self.fileSystems))
      for kiter63,viter64 in self.fileSystems.items():
        oprot.writeI32(kiter63)
        oprot.writeString(viter64)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.jobSubmissionInterfaces is not None:
      oprot.writeFieldBegin('jobSubmissionInterfaces', TType.LIST, 8)
      oprot.writeListBegin(TType.STRUCT, len(self.jobSubmissionInterfaces))
      for iter65 in self.jobSubmissionInterfaces:
        iter65.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.dataMovementInterfaces is not None:
      oprot.writeFieldBegin('dataMovementInterfaces', TType.LIST, 9)
      oprot.writeListBegin(TType.STRUCT, len(self.dataMovementInterfaces))
      for iter66 in self.dataMovementInterfaces:
        iter66.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.maxMemoryPerNode is not None:
      oprot.writeFieldBegin('maxMemoryPerNode', TType.I32, 10)
      oprot.writeI32(self.maxMemoryPerNode)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.computeResourceId is None:
      raise TProtocol.TProtocolException(message='Required field computeResourceId is unset!')
    if self.hostName is None:
      raise TProtocol.TProtocolException(message='Required field hostName is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)
