#
# Autogenerated by Thrift Compiler (0.9.3)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
#  options string: py
#

from thrift.Thrift import TType, TMessageType, TException, TApplicationException
import apache.airavata.model.commons.ttypes


from thrift.transport import TTransport
from thrift.protocol import TBinaryProtocol, TProtocol
try:
  from thrift.protocol import fastbinary
except:
  fastbinary = None


class Status:
  ACTIVE = 0
  CONFIRMED = 1
  APPROVED = 2
  DELETED = 3
  DUPLICATE = 4
  GRACE_PERIOD = 5
  INVITED = 6
  DENIED = 7
  PENDING = 8
  PENDING_APPROVAL = 9
  PENDING_CONFIRMATION = 10
  SUSPENDED = 11
  DECLINED = 12
  EXPIRED = 13

  _VALUES_TO_NAMES = {
    0: "ACTIVE",
    1: "CONFIRMED",
    2: "APPROVED",
    3: "DELETED",
    4: "DUPLICATE",
    5: "GRACE_PERIOD",
    6: "INVITED",
    7: "DENIED",
    8: "PENDING",
    9: "PENDING_APPROVAL",
    10: "PENDING_CONFIRMATION",
    11: "SUSPENDED",
    12: "DECLINED",
    13: "EXPIRED",
  }

  _NAMES_TO_VALUES = {
    "ACTIVE": 0,
    "CONFIRMED": 1,
    "APPROVED": 2,
    "DELETED": 3,
    "DUPLICATE": 4,
    "GRACE_PERIOD": 5,
    "INVITED": 6,
    "DENIED": 7,
    "PENDING": 8,
    "PENDING_APPROVAL": 9,
    "PENDING_CONFIRMATION": 10,
    "SUSPENDED": 11,
    "DECLINED": 12,
    "EXPIRED": 13,
  }

class USCitizenship:
  """
  U.S. Citizen (see: http://en.wikipedia.org/wiki/ISO_3166-1_alpha-2)

  """
  US_CITIZEN = 0
  US_PERMANENT_RESIDENT = 1
  OTHER_NON_US_CITIZEN = 2

  _VALUES_TO_NAMES = {
    0: "US_CITIZEN",
    1: "US_PERMANENT_RESIDENT",
    2: "OTHER_NON_US_CITIZEN",
  }

  _NAMES_TO_VALUES = {
    "US_CITIZEN": 0,
    "US_PERMANENT_RESIDENT": 1,
    "OTHER_NON_US_CITIZEN": 2,
  }

class ethnicity:
  """
  Hispanic or Latino - a person of Mexican, Puerto Rican, Cuban, South or
   Central American, or other Spanish culture or origin, regardless of race.

  """
  HISPANIC_LATINO = 0
  NOT_HISPANIC_LATINO = 1

  _VALUES_TO_NAMES = {
    0: "HISPANIC_LATINO",
    1: "NOT_HISPANIC_LATINO",
  }

  _NAMES_TO_VALUES = {
    "HISPANIC_LATINO": 0,
    "NOT_HISPANIC_LATINO": 1,
  }

class race:
  """
  * Asian - a person having origins in any of the original peoples of the Far East,
  *      Southeast Asia, or the Indian subcontinent including, for example, Cambodia,
   *      China, India, Japan, Korea, Malaysia, Pakistan, the Philippine Islands,
   *      Thailand, and Vietnam.
  * American Indian or Alaskan Native - a person having origins in any of the original
   *     peoples of North and South America (including Central America), and who maintains
    *     tribal affiliation or community attachment.
  * Black or African American - a person having origins in any of the black racial groups
  *      of Africa.
  * Native Hawaiian or Pacific Islander - a person having origins in any of the original
  *      peoples of Hawaii, Guan, Samoa, or other Pacific Islands.
  * White - a person having origins in any of the original peoples of Europe, the Middle East, or North Africa.
  *
  """
  ASIAN = 0
  AMERICAN_INDIAN_OR_ALASKAN_NATIVE = 1
  BLACK_OR_AFRICAN_AMERICAN = 2
  NATIVE_HAWAIIAN_OR_PACIFIC_ISLANDER = 3
  WHITE = 4

  _VALUES_TO_NAMES = {
    0: "ASIAN",
    1: "AMERICAN_INDIAN_OR_ALASKAN_NATIVE",
    2: "BLACK_OR_AFRICAN_AMERICAN",
    3: "NATIVE_HAWAIIAN_OR_PACIFIC_ISLANDER",
    4: "WHITE",
  }

  _NAMES_TO_VALUES = {
    "ASIAN": 0,
    "AMERICAN_INDIAN_OR_ALASKAN_NATIVE": 1,
    "BLACK_OR_AFRICAN_AMERICAN": 2,
    "NATIVE_HAWAIIAN_OR_PACIFIC_ISLANDER": 3,
    "WHITE": 4,
  }

class disability:
  HEARING_IMAPAIRED = 0
  VISUAL_IMPAIRED = 1
  MOBILITY_OR_ORTHOPEDIC_IMPAIRMENT = 2
  OTHER_IMPAIRMENT = 3

  _VALUES_TO_NAMES = {
    0: "HEARING_IMAPAIRED",
    1: "VISUAL_IMPAIRED",
    2: "MOBILITY_OR_ORTHOPEDIC_IMPAIRMENT",
    3: "OTHER_IMPAIRMENT",
  }

  _NAMES_TO_VALUES = {
    "HEARING_IMAPAIRED": 0,
    "VISUAL_IMPAIRED": 1,
    "MOBILITY_OR_ORTHOPEDIC_IMPAIRMENT": 2,
    "OTHER_IMPAIRMENT": 3,
  }


class NSFDemographics:
  """
  A structure holding the NSF Demographic information.



  Attributes:
   - gender
   - usCitizenship
   - ethnicities
   - races
   - disabilities
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'gender', None, None, ), # 1
    (2, TType.I32, 'usCitizenship', None, None, ), # 2
    (3, TType.LIST, 'ethnicities', (TType.I32,None), None, ), # 3
    (4, TType.LIST, 'races', (TType.I32,None), None, ), # 4
    (5, TType.LIST, 'disabilities', (TType.I32,None), None, ), # 5
  )

  def __init__(self, gender=None, usCitizenship=None, ethnicities=None, races=None, disabilities=None,):
    self.gender = gender
    self.usCitizenship = usCitizenship
    self.ethnicities = ethnicities
    self.races = races
    self.disabilities = disabilities

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.gender = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.usCitizenship = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.ethnicities = []
          (_etype3, _size0) = iprot.readListBegin()
          for _i4 in xrange(_size0):
            _elem5 = iprot.readI32()
            self.ethnicities.append(_elem5)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.LIST:
          self.races = []
          (_etype9, _size6) = iprot.readListBegin()
          for _i10 in xrange(_size6):
            _elem11 = iprot.readI32()
            self.races.append(_elem11)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.LIST:
          self.disabilities = []
          (_etype15, _size12) = iprot.readListBegin()
          for _i16 in xrange(_size12):
            _elem17 = iprot.readI32()
            self.disabilities.append(_elem17)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('NSFDemographics')
    if self.gender is not None:
      oprot.writeFieldBegin('gender', TType.STRING, 1)
      oprot.writeString(self.gender)
      oprot.writeFieldEnd()
    if self.usCitizenship is not None:
      oprot.writeFieldBegin('usCitizenship', TType.I32, 2)
      oprot.writeI32(self.usCitizenship)
      oprot.writeFieldEnd()
    if self.ethnicities is not None:
      oprot.writeFieldBegin('ethnicities', TType.LIST, 3)
      oprot.writeListBegin(TType.I32, len(self.ethnicities))
      for iter18 in self.ethnicities:
        oprot.writeI32(iter18)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.races is not None:
      oprot.writeFieldBegin('races', TType.LIST, 4)
      oprot.writeListBegin(TType.I32, len(self.races))
      for iter19 in self.races:
        oprot.writeI32(iter19)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.disabilities is not None:
      oprot.writeFieldBegin('disabilities', TType.LIST, 5)
      oprot.writeListBegin(TType.I32, len(self.disabilities))
      for iter20 in self.disabilities:
        oprot.writeI32(iter20)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.gender)
    value = (value * 31) ^ hash(self.usCitizenship)
    value = (value * 31) ^ hash(self.ethnicities)
    value = (value * 31) ^ hash(self.races)
    value = (value * 31) ^ hash(self.disabilities)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class UserProfile:
  """
  * A structure holding the user profile and its child models.
  *
  * Notes:
  *  The model does not include passwords as it is assumed an external identity provider is used to authenticate user.
  *  References:
  *     NSF Demographic Information - http://www.nsf.gov/pubs/2000/00form1225/00form1225.doc
  *     LDAP Schema - https://tools.ietf.org/html/rfc4519
  *     SCIM 2.0 - https://tools.ietf.org/html/rfc7643
  *
  * userModelVersion:
  *  Version number of profile
  *
  * airavataInternalUserId:
  *  internal to Airavata, not intended to be used outside of the Airavata platform or possibly by gateways
  *  (that is, never shown to users), never reassigned, REQUIRED
  *
  * userId:
  *  Externally assertable unique identifier. SAML (primarly in higher education, academic) tends to keep
  *   user name less opaque. OpenID Connect maintains them to be opaque.
  *
  * emails:
  *   Email identifier are Verified, REQUIRED and MULTIVALUED
  *
  * userName:
  *  Name-based identifiers can be multivalues. To keep it simple, Airavata will make it a string.
  *   In the future these can be enumerated as:
      *   Official name (as asserted possibly by some external identity provider)
      *   Prefered name (as asserted or suggested by user directly)
      *   Components:
      *      givenName
      *      surname (familyName)
      *      displayName (often asserted by user to handle things like middle names, suffix, prefix, and the like)
  *
  * orcidId: ORCID ID - http://orcid.org/about/what-is-orcid)
  *
  * phones: Telephone MULTIVALUED
  *
  * country: Country of Residance
  *
  * nationality Countries of citizenship
  *
  * comments:
  *   Free-form information (treated as opaque by Airavata and simply passed to resource).
  *
  * labeledURI:
    * Google Scholar, Web of Science, ACS, e.t.c
  *
  * timeZone:
  *  User’s preferred timezone - IANA Timezone Databases - http://www.iana.org/time-zones.
  *

  Attributes:
   - userModelVersion
   - airavataInternalUserId
   - userId
   - gatewayId
   - emails
   - userName
   - orcidId
   - phones
   - country
   - nationality
   - homeOrganization
   - orginationAffiliation
   - creationTime
   - lastAccessTime
   - validUntil
   - State
   - comments
   - labeledURI
   - gpgKey
   - timeZone
   - nsfDemographics
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'userModelVersion', None, "1.0", ), # 1
    (2, TType.STRING, 'airavataInternalUserId', None, "DO_NOT_SET_AT_CLIENTS", ), # 2
    (3, TType.STRING, 'userId', None, None, ), # 3
    (4, TType.STRING, 'gatewayId', None, None, ), # 4
    (5, TType.LIST, 'emails', (TType.STRING,None), None, ), # 5
    (6, TType.STRING, 'userName', None, None, ), # 6
    (7, TType.STRING, 'orcidId', None, None, ), # 7
    (8, TType.LIST, 'phones', (TType.STRING,None), None, ), # 8
    (9, TType.STRING, 'country', None, None, ), # 9
    (10, TType.LIST, 'nationality', (TType.STRING,None), None, ), # 10
    (11, TType.STRING, 'homeOrganization', None, None, ), # 11
    (12, TType.STRING, 'orginationAffiliation', None, None, ), # 12
    (13, TType.STRING, 'creationTime', None, None, ), # 13
    (14, TType.STRING, 'lastAccessTime', None, None, ), # 14
    (15, TType.STRING, 'validUntil', None, None, ), # 15
    (16, TType.I32, 'State', None, None, ), # 16
    (17, TType.STRING, 'comments', None, None, ), # 17
    (18, TType.LIST, 'labeledURI', (TType.STRING,None), None, ), # 18
    (19, TType.STRING, 'gpgKey', None, None, ), # 19
    (20, TType.STRING, 'timeZone', None, None, ), # 20
    (21, TType.STRUCT, 'nsfDemographics', (NSFDemographics, NSFDemographics.thrift_spec), None, ), # 21
  )

  def __init__(self, userModelVersion=thrift_spec[1][4], airavataInternalUserId=thrift_spec[2][4], userId=None, gatewayId=None, emails=None, userName=None, orcidId=None, phones=None, country=None, nationality=None, homeOrganization=None, orginationAffiliation=None, creationTime=None, lastAccessTime=None, validUntil=None, State=None, comments=None, labeledURI=None, gpgKey=None, timeZone=None, nsfDemographics=None,):
    self.userModelVersion = userModelVersion
    self.airavataInternalUserId = airavataInternalUserId
    self.userId = userId
    self.gatewayId = gatewayId
    self.emails = emails
    self.userName = userName
    self.orcidId = orcidId
    self.phones = phones
    self.country = country
    self.nationality = nationality
    self.homeOrganization = homeOrganization
    self.orginationAffiliation = orginationAffiliation
    self.creationTime = creationTime
    self.lastAccessTime = lastAccessTime
    self.validUntil = validUntil
    self.State = State
    self.comments = comments
    self.labeledURI = labeledURI
    self.gpgKey = gpgKey
    self.timeZone = timeZone
    self.nsfDemographics = nsfDemographics

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.userModelVersion = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.airavataInternalUserId = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.userId = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.gatewayId = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.LIST:
          self.emails = []
          (_etype24, _size21) = iprot.readListBegin()
          for _i25 in xrange(_size21):
            _elem26 = iprot.readString()
            self.emails.append(_elem26)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRING:
          self.userName = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.STRING:
          self.orcidId = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.LIST:
          self.phones = []
          (_etype30, _size27) = iprot.readListBegin()
          for _i31 in xrange(_size27):
            _elem32 = iprot.readString()
            self.phones.append(_elem32)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 9:
        if ftype == TType.STRING:
          self.country = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 10:
        if ftype == TType.LIST:
          self.nationality = []
          (_etype36, _size33) = iprot.readListBegin()
          for _i37 in xrange(_size33):
            _elem38 = iprot.readString()
            self.nationality.append(_elem38)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 11:
        if ftype == TType.STRING:
          self.homeOrganization = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 12:
        if ftype == TType.STRING:
          self.orginationAffiliation = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 13:
        if ftype == TType.STRING:
          self.creationTime = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 14:
        if ftype == TType.STRING:
          self.lastAccessTime = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 15:
        if ftype == TType.STRING:
          self.validUntil = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 16:
        if ftype == TType.I32:
          self.State = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 17:
        if ftype == TType.STRING:
          self.comments = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 18:
        if ftype == TType.LIST:
          self.labeledURI = []
          (_etype42, _size39) = iprot.readListBegin()
          for _i43 in xrange(_size39):
            _elem44 = iprot.readString()
            self.labeledURI.append(_elem44)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 19:
        if ftype == TType.STRING:
          self.gpgKey = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 20:
        if ftype == TType.STRING:
          self.timeZone = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 21:
        if ftype == TType.STRUCT:
          self.nsfDemographics = NSFDemographics()
          self.nsfDemographics.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('UserProfile')
    if self.userModelVersion is not None:
      oprot.writeFieldBegin('userModelVersion', TType.STRING, 1)
      oprot.writeString(self.userModelVersion)
      oprot.writeFieldEnd()
    if self.airavataInternalUserId is not None:
      oprot.writeFieldBegin('airavataInternalUserId', TType.STRING, 2)
      oprot.writeString(self.airavataInternalUserId)
      oprot.writeFieldEnd()
    if self.userId is not None:
      oprot.writeFieldBegin('userId', TType.STRING, 3)
      oprot.writeString(self.userId)
      oprot.writeFieldEnd()
    if self.gatewayId is not None:
      oprot.writeFieldBegin('gatewayId', TType.STRING, 4)
      oprot.writeString(self.gatewayId)
      oprot.writeFieldEnd()
    if self.emails is not None:
      oprot.writeFieldBegin('emails', TType.LIST, 5)
      oprot.writeListBegin(TType.STRING, len(self.emails))
      for iter45 in self.emails:
        oprot.writeString(iter45)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.userName is not None:
      oprot.writeFieldBegin('userName', TType.STRING, 6)
      oprot.writeString(self.userName)
      oprot.writeFieldEnd()
    if self.orcidId is not None:
      oprot.writeFieldBegin('orcidId', TType.STRING, 7)
      oprot.writeString(self.orcidId)
      oprot.writeFieldEnd()
    if self.phones is not None:
      oprot.writeFieldBegin('phones', TType.LIST, 8)
      oprot.writeListBegin(TType.STRING, len(self.phones))
      for iter46 in self.phones:
        oprot.writeString(iter46)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.country is not None:
      oprot.writeFieldBegin('country', TType.STRING, 9)
      oprot.writeString(self.country)
      oprot.writeFieldEnd()
    if self.nationality is not None:
      oprot.writeFieldBegin('nationality', TType.LIST, 10)
      oprot.writeListBegin(TType.STRING, len(self.nationality))
      for iter47 in self.nationality:
        oprot.writeString(iter47)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.homeOrganization is not None:
      oprot.writeFieldBegin('homeOrganization', TType.STRING, 11)
      oprot.writeString(self.homeOrganization)
      oprot.writeFieldEnd()
    if self.orginationAffiliation is not None:
      oprot.writeFieldBegin('orginationAffiliation', TType.STRING, 12)
      oprot.writeString(self.orginationAffiliation)
      oprot.writeFieldEnd()
    if self.creationTime is not None:
      oprot.writeFieldBegin('creationTime', TType.STRING, 13)
      oprot.writeString(self.creationTime)
      oprot.writeFieldEnd()
    if self.lastAccessTime is not None:
      oprot.writeFieldBegin('lastAccessTime', TType.STRING, 14)
      oprot.writeString(self.lastAccessTime)
      oprot.writeFieldEnd()
    if self.validUntil is not None:
      oprot.writeFieldBegin('validUntil', TType.STRING, 15)
      oprot.writeString(self.validUntil)
      oprot.writeFieldEnd()
    if self.State is not None:
      oprot.writeFieldBegin('State', TType.I32, 16)
      oprot.writeI32(self.State)
      oprot.writeFieldEnd()
    if self.comments is not None:
      oprot.writeFieldBegin('comments', TType.STRING, 17)
      oprot.writeString(self.comments)
      oprot.writeFieldEnd()
    if self.labeledURI is not None:
      oprot.writeFieldBegin('labeledURI', TType.LIST, 18)
      oprot.writeListBegin(TType.STRING, len(self.labeledURI))
      for iter48 in self.labeledURI:
        oprot.writeString(iter48)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.gpgKey is not None:
      oprot.writeFieldBegin('gpgKey', TType.STRING, 19)
      oprot.writeString(self.gpgKey)
      oprot.writeFieldEnd()
    if self.timeZone is not None:
      oprot.writeFieldBegin('timeZone', TType.STRING, 20)
      oprot.writeString(self.timeZone)
      oprot.writeFieldEnd()
    if self.nsfDemographics is not None:
      oprot.writeFieldBegin('nsfDemographics', TType.STRUCT, 21)
      self.nsfDemographics.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.userModelVersion is None:
      raise TProtocol.TProtocolException(message='Required field userModelVersion is unset!')
    if self.airavataInternalUserId is None:
      raise TProtocol.TProtocolException(message='Required field airavataInternalUserId is unset!')
    if self.userId is None:
      raise TProtocol.TProtocolException(message='Required field userId is unset!')
    if self.gatewayId is None:
      raise TProtocol.TProtocolException(message='Required field gatewayId is unset!')
    if self.emails is None:
      raise TProtocol.TProtocolException(message='Required field emails is unset!')
    if self.creationTime is None:
      raise TProtocol.TProtocolException(message='Required field creationTime is unset!')
    if self.lastAccessTime is None:
      raise TProtocol.TProtocolException(message='Required field lastAccessTime is unset!')
    if self.validUntil is None:
      raise TProtocol.TProtocolException(message='Required field validUntil is unset!')
    if self.State is None:
      raise TProtocol.TProtocolException(message='Required field State is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.userModelVersion)
    value = (value * 31) ^ hash(self.airavataInternalUserId)
    value = (value * 31) ^ hash(self.userId)
    value = (value * 31) ^ hash(self.gatewayId)
    value = (value * 31) ^ hash(self.emails)
    value = (value * 31) ^ hash(self.userName)
    value = (value * 31) ^ hash(self.orcidId)
    value = (value * 31) ^ hash(self.phones)
    value = (value * 31) ^ hash(self.country)
    value = (value * 31) ^ hash(self.nationality)
    value = (value * 31) ^ hash(self.homeOrganization)
    value = (value * 31) ^ hash(self.orginationAffiliation)
    value = (value * 31) ^ hash(self.creationTime)
    value = (value * 31) ^ hash(self.lastAccessTime)
    value = (value * 31) ^ hash(self.validUntil)
    value = (value * 31) ^ hash(self.State)
    value = (value * 31) ^ hash(self.comments)
    value = (value * 31) ^ hash(self.labeledURI)
    value = (value * 31) ^ hash(self.gpgKey)
    value = (value * 31) ^ hash(self.timeZone)
    value = (value * 31) ^ hash(self.nsfDemographics)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)
