#
# Autogenerated by Thrift Compiler (0.21.0)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
#  options string: py:enum,type_hints
#

from __future__ import annotations
import typing
from thrift.Thrift import TType, TMessageType, TFrozenDict, TException, TApplicationException
from thrift.protocol.TProtocol import TProtocolException
from thrift.TRecursive import fix_spec
from uuid import UUID
from enum import IntEnum

import sys
import airavata.base.api.BaseAPI
import logging
from .ttypes import *
from thrift.Thrift import TProcessor
from thrift.transport import TTransport
all_structs = []


class Iface(airavata.base.api.BaseAPI.Iface):
    def createDomain(self, domain: airavata.model.sharing.ttypes.Domain) -> str:
        """
        <p>API method to create a new domain</p>

        Parameters:
         - domain

        """
        pass

    def updateDomain(self, domain: airavata.model.sharing.ttypes.Domain) -> bool:
        """
        <p>API method to update a domain</p>

        Parameters:
         - domain

        """
        pass

    def isDomainExists(self, domainId: str) -> bool:
        """
        <p>API method to check Domain Exists</p>

        Parameters:
         - domainId

        """
        pass

    def deleteDomain(self, domainId: str) -> bool:
        """
        <p>API method to delete domain</p>

        Parameters:
         - domainId

        """
        pass

    def getDomain(self, domainId: str) -> airavata.model.sharing.ttypes.Domain:
        """
        <p>API method to retrieve a domain</p>

        Parameters:
         - domainId

        """
        pass

    def getDomains(self, offset: int, limit: int) -> list[airavata.model.sharing.ttypes.Domain]:
        """
        <p>API method to get all domain.</p>

        Parameters:
         - offset
         - limit

        """
        pass

    def createUser(self, user: airavata.model.sharing.ttypes.User) -> str:
        """
        <p>API method to register a user in the system</p>

        Parameters:
         - user

        """
        pass

    def updatedUser(self, user: airavata.model.sharing.ttypes.User) -> bool:
        """
        <p>API method to update existing user</p>

        Parameters:
         - user

        """
        pass

    def isUserExists(self, domainId: str, userId: str) -> bool:
        """
        <p>API method to check User Exists</p>

        Parameters:
         - domainId
         - userId

        """
        pass

    def deleteUser(self, domainId: str, userId: str) -> bool:
        """
        <p>API method to delete user</p>

        Parameters:
         - domainId
         - userId

        """
        pass

    def getUser(self, domainId: str, userId: str) -> airavata.model.sharing.ttypes.User:
        """
        <p>API method to get a user</p>

        Parameters:
         - domainId
         - userId

        """
        pass

    def getUsers(self, domainId: str, offset: int, limit: int) -> list[airavata.model.sharing.ttypes.User]:
        """
        <p>API method to get a list of users in a specific domain.</p>
        <li>domainId : Domain id</li>
        <li>offset : Starting result number</li>
        <li>limit : Number of max results to be sent</li>

        Parameters:
         - domainId
         - offset
         - limit

        """
        pass

    def createGroup(self, group: airavata.model.sharing.ttypes.UserGroup) -> str:
        """
        <p>API method to create a new group</p>

        Parameters:
         - group

        """
        pass

    def updateGroup(self, group: airavata.model.sharing.ttypes.UserGroup) -> bool:
        """
        <p>API method to update a group</p>

        Parameters:
         - group

        """
        pass

    def isGroupExists(self, domainId: str, groupId: str) -> bool:
        """
        <p>API method to check Group Exists</p>

        Parameters:
         - domainId
         - groupId

        """
        pass

    def deleteGroup(self, domainId: str, groupId: str) -> bool:
        """
        <p>API method to delete a group</p>

        Parameters:
         - domainId
         - groupId

        """
        pass

    def getGroup(self, domainId: str, groupId: str) -> airavata.model.sharing.ttypes.UserGroup:
        """
        <p>API method to get a group</p>

        Parameters:
         - domainId
         - groupId

        """
        pass

    def getGroups(self, domainId: str, offset: int, limit: int) -> list[airavata.model.sharing.ttypes.UserGroup]:
        """
        <p>API method to get groups in a domainId.</p>

        Parameters:
         - domainId
         - offset
         - limit

        """
        pass

    def addUsersToGroup(self, domainId: str, userIds: list[str], groupId: str) -> bool:
        """
        <p>API method to add list of users to a group</p>

        Parameters:
         - domainId
         - userIds
         - groupId

        """
        pass

    def removeUsersFromGroup(self, domainId: str, userIds: list[str], groupId: str) -> bool:
        """
        <p>API method to remove users from a group</p>

        Parameters:
         - domainId
         - userIds
         - groupId

        """
        pass

    def transferGroupOwnership(self, domainId: str, groupId: str, newOwnerId: str) -> bool:
        """
        <p>API method to transfer group ownership</p>

        Parameters:
         - domainId
         - groupId
         - newOwnerId

        """
        pass

    def addGroupAdmins(self, domainId: str, groupId: str, adminIds: list[str]) -> bool:
        """
        <p>API method to add Admin for a group</p>

        Parameters:
         - domainId
         - groupId
         - adminIds

        """
        pass

    def removeGroupAdmins(self, domainId: str, groupId: str, adminIds: list[str]) -> bool:
        """
        <p>API method to remove Admin for a group</p>

        Parameters:
         - domainId
         - groupId
         - adminIds

        """
        pass

    def hasAdminAccess(self, domainId: str, groupId: str, adminId: str) -> bool:
        """
        <p>API method to check whether the user has Admin access for the group</p>

        Parameters:
         - domainId
         - groupId
         - adminId

        """
        pass

    def hasOwnerAccess(self, domainId: str, groupId: str, ownerId: str) -> bool:
        """
        <p>API method to check whether the user has Admin access for the group</p>

        Parameters:
         - domainId
         - groupId
         - ownerId

        """
        pass

    def getGroupMembersOfTypeUser(self, domainId: str, groupId: str, offset: int, limit: int) -> list[airavata.model.sharing.ttypes.User]:
        """
        <p>API method to get list of child users in a group. Only the direct members will be returned.</p>

        Parameters:
         - domainId
         - groupId
         - offset
         - limit

        """
        pass

    def getGroupMembersOfTypeGroup(self, domainId: str, groupId: str, offset: int, limit: int) -> list[airavata.model.sharing.ttypes.UserGroup]:
        """
        <p>API method to get list of child groups in a group. Only the direct members will be returned.</p>

        Parameters:
         - domainId
         - groupId
         - offset
         - limit

        """
        pass

    def addChildGroupsToParentGroup(self, domainId: str, childIds: list[str], groupId: str) -> bool:
        """
        <p>API method to add a child group to a parent group.</p>

        Parameters:
         - domainId
         - childIds
         - groupId

        """
        pass

    def removeChildGroupFromParentGroup(self, domainId: str, childId: str, groupId: str) -> bool:
        """
        <p>API method to remove a child group from parent group.</p>

        Parameters:
         - domainId
         - childId
         - groupId

        """
        pass

    def getAllMemberGroupsForUser(self, domainId: str, userId: str) -> list[airavata.model.sharing.ttypes.UserGroup]:
        """
        Parameters:
         - domainId
         - userId

        """
        pass

    def createEntityType(self, entityType: airavata.model.sharing.ttypes.EntityType) -> str:
        """
        <p>API method to create a new entity type</p>

        Parameters:
         - entityType

        """
        pass

    def updateEntityType(self, entityType: airavata.model.sharing.ttypes.EntityType) -> bool:
        """
        <p>API method to update entity type</p>

        Parameters:
         - entityType

        """
        pass

    def isEntityTypeExists(self, domainId: str, entityTypeId: str) -> bool:
        """
        <p>API method to check EntityType Exists</p>

        Parameters:
         - domainId
         - entityTypeId

        """
        pass

    def deleteEntityType(self, domainId: str, entityTypeId: str) -> bool:
        """
        <p>API method to delete entity type</p>

        Parameters:
         - domainId
         - entityTypeId

        """
        pass

    def getEntityType(self, domainId: str, entityTypeId: str) -> airavata.model.sharing.ttypes.EntityType:
        """
        <p>API method to get an entity type</p>

        Parameters:
         - domainId
         - entityTypeId

        """
        pass

    def getEntityTypes(self, domainId: str, offset: int, limit: int) -> list[airavata.model.sharing.ttypes.EntityType]:
        """
        <p>API method to get entity types in a domainId.</p>

        Parameters:
         - domainId
         - offset
         - limit

        """
        pass

    def createEntity(self, entity: airavata.model.sharing.ttypes.Entity) -> str:
        """
        <p>API method to register new entity</p>

        Parameters:
         - entity

        """
        pass

    def updateEntity(self, entity: airavata.model.sharing.ttypes.Entity) -> bool:
        """
        <p>API method to update entity</p>

        Parameters:
         - entity

        """
        pass

    def isEntityExists(self, domainId: str, entityId: str) -> bool:
        """
        <p>API method to check Entity Exists</p>

        Parameters:
         - domainId
         - entityId

        """
        pass

    def deleteEntity(self, domainId: str, entityId: str) -> bool:
        """
        <p>API method to delete entity</p>

        Parameters:
         - domainId
         - entityId

        """
        pass

    def getEntity(self, domainId: str, entityId: str) -> airavata.model.sharing.ttypes.Entity:
        """
        <p>API method to get entity</p>

        Parameters:
         - domainId
         - entityId

        """
        pass

    def searchEntities(self, domainId: str, userId: str, filters: list[airavata.model.sharing.ttypes.SearchCriteria], offset: int, limit: int) -> list[airavata.model.sharing.ttypes.Entity]:
        """
        <p>API method to search entities</p>

        Parameters:
         - domainId
         - userId
         - filters
         - offset
         - limit

        """
        pass

    def getListOfSharedUsers(self, domainId: str, entityId: str, permissionTypeId: str) -> list[airavata.model.sharing.ttypes.User]:
        """
        <p>API method to get a list of shared users given the entity id</p>

        Parameters:
         - domainId
         - entityId
         - permissionTypeId

        """
        pass

    def getListOfDirectlySharedUsers(self, domainId: str, entityId: str, permissionTypeId: str) -> list[airavata.model.sharing.ttypes.User]:
        """
        <p>API method to get a list of shared users given the entity id where the sharing type is directly applied</p>

        Parameters:
         - domainId
         - entityId
         - permissionTypeId

        """
        pass

    def getListOfSharedGroups(self, domainId: str, entityId: str, permissionTypeId: str) -> list[airavata.model.sharing.ttypes.UserGroup]:
        """
        <p>API method to get a list of shared groups given the entity id</p>

        Parameters:
         - domainId
         - entityId
         - permissionTypeId

        """
        pass

    def getListOfDirectlySharedGroups(self, domainId: str, entityId: str, permissionTypeId: str) -> list[airavata.model.sharing.ttypes.UserGroup]:
        """
        <p>API method to get a list of directly shared groups given the entity id where the sharing type is directly applied</p>

        Parameters:
         - domainId
         - entityId
         - permissionTypeId

        """
        pass

    def createPermissionType(self, permissionType: airavata.model.sharing.ttypes.PermissionType) -> str:
        """
        <p>API method to create permission type</p>

        Parameters:
         - permissionType

        """
        pass

    def updatePermissionType(self, permissionType: airavata.model.sharing.ttypes.PermissionType) -> bool:
        """
        <p>API method to update permission type</p>

        Parameters:
         - permissionType

        """
        pass

    def isPermissionExists(self, dimainId: str, permissionId: str) -> bool:
        """
        <p>API method to check Permission Exists</p>

        Parameters:
         - dimainId
         - permissionId

        """
        pass

    def deletePermissionType(self, domainId: str, permissionTypeId: str) -> bool:
        """
        <p>API method to delete permission type</p>

        Parameters:
         - domainId
         - permissionTypeId

        """
        pass

    def getPermissionType(self, domainId: str, permissionTypeId: str) -> airavata.model.sharing.ttypes.PermissionType:
        """
        <p>API method to get permission type</p>

        Parameters:
         - domainId
         - permissionTypeId

        """
        pass

    def getPermissionTypes(self, domainId: str, offset: int, limit: int) -> list[airavata.model.sharing.ttypes.PermissionType]:
        """
        <p>API method to get list of permission types in a given domainId.</p>

        Parameters:
         - domainId
         - offset
         - limit

        """
        pass

    def shareEntityWithUsers(self, domainId: str, entityId: str, userList: list[str], permissionTypeId: str, cascadePermission: bool) -> bool:
        """
        <p>API method to share an entity with users</p>

        Parameters:
         - domainId
         - entityId
         - userList
         - permissionTypeId
         - cascadePermission

        """
        pass

    def revokeEntitySharingFromUsers(self, domainId: str, entityId: str, userList: list[str], permissionTypeId: str) -> bool:
        """
        <p>API method to revoke sharing from a list of users</p>

        Parameters:
         - domainId
         - entityId
         - userList
         - permissionTypeId

        """
        pass

    def shareEntityWithGroups(self, domainId: str, entityId: str, groupList: list[str], permissionTypeId: str, cascadePermission: bool) -> bool:
        """
        <p>API method to share an entity with list of groups</p>

        Parameters:
         - domainId
         - entityId
         - groupList
         - permissionTypeId
         - cascadePermission

        """
        pass

    def revokeEntitySharingFromGroups(self, domainId: str, entityId: str, groupList: list[str], permissionTypeId: str) -> bool:
        """
        <p>API method to revoke sharing from list of users</p>

        Parameters:
         - domainId
         - entityId
         - groupList
         - permissionTypeId

        """
        pass

    def userHasAccess(self, domainId: str, userId: str, entityId: str, permissionTypeId: str) -> bool:
        """
        <p>API method to check whether a user has access to a specific entity</p>

        Parameters:
         - domainId
         - userId
         - entityId
         - permissionTypeId

        """
        pass


class Client(airavata.base.api.BaseAPI.Client, Iface):
    def __init__(self, iprot, oprot=None):
        airavata.base.api.BaseAPI.Client.__init__(self, iprot, oprot)

    def createDomain(self, domain: airavata.model.sharing.ttypes.Domain) -> str:
        """
        <p>API method to create a new domain</p>

        Parameters:
         - domain

        """
        self.send_createDomain(domain)
        return self.recv_createDomain()

    def send_createDomain(self, domain: airavata.model.sharing.ttypes.Domain):
        self._oprot.writeMessageBegin('createDomain', TMessageType.CALL, self._seqid)
        args = createDomain_args()
        args.domain = domain
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_createDomain(self) -> str:
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = createDomain_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.sre is not None:
            raise result.sre
        if result.dee is not None:
            raise result.dee
        raise TApplicationException(TApplicationException.MISSING_RESULT, "createDomain failed: unknown result")

    def updateDomain(self, domain: airavata.model.sharing.ttypes.Domain) -> bool:
        """
        <p>API method to update a domain</p>

        Parameters:
         - domain

        """
        self.send_updateDomain(domain)
        return self.recv_updateDomain()

    def send_updateDomain(self, domain: airavata.model.sharing.ttypes.Domain):
        self._oprot.writeMessageBegin('updateDomain', TMessageType.CALL, self._seqid)
        args = updateDomain_args()
        args.domain = domain
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_updateDomain(self) -> bool:
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = updateDomain_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.sre is not None:
            raise result.sre
        raise TApplicationException(TApplicationException.MISSING_RESULT, "updateDomain failed: unknown result")

    def isDomainExists(self, domainId: str) -> bool:
        """
        <p>API method to check Domain Exists</p>

        Parameters:
         - domainId

        """
        self.send_isDomainExists(domainId)
        return self.recv_isDomainExists()

    def send_isDomainExists(self, domainId: str):
        self._oprot.writeMessageBegin('isDomainExists', TMessageType.CALL, self._seqid)
        args = isDomainExists_args()
        args.domainId = domainId
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_isDomainExists(self) -> bool:
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = isDomainExists_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.sre is not None:
            raise result.sre
        raise TApplicationException(TApplicationException.MISSING_RESULT, "isDomainExists failed: unknown result")

    def deleteDomain(self, domainId: str) -> bool:
        """
        <p>API method to delete domain</p>

        Parameters:
         - domainId

        """
        self.send_deleteDomain(domainId)
        return self.recv_deleteDomain()

    def send_deleteDomain(self, domainId: str):
        self._oprot.writeMessageBegin('deleteDomain', TMessageType.CALL, self._seqid)
        args = deleteDomain_args()
        args.domainId = domainId
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_deleteDomain(self) -> bool:
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = deleteDomain_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.sre is not None:
            raise result.sre
        raise TApplicationException(TApplicationException.MISSING_RESULT, "deleteDomain failed: unknown result")

    def getDomain(self, domainId: str) -> airavata.model.sharing.ttypes.Domain:
        """
        <p>API method to retrieve a domain</p>

        Parameters:
         - domainId

        """
        self.send_getDomain(domainId)
        return self.recv_getDomain()

    def send_getDomain(self, domainId: str):
        self._oprot.writeMessageBegin('getDomain', TMessageType.CALL, self._seqid)
        args = getDomain_args()
        args.domainId = domainId
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getDomain(self) -> airavata.model.sharing.ttypes.Domain:
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getDomain_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.sre is not None:
            raise result.sre
        raise TApplicationException(TApplicationException.MISSING_RESULT, "getDomain failed: unknown result")

    def getDomains(self, offset: int, limit: int) -> list[airavata.model.sharing.ttypes.Domain]:
        """
        <p>API method to get all domain.</p>

        Parameters:
         - offset
         - limit

        """
        self.send_getDomains(offset, limit)
        return self.recv_getDomains()

    def send_getDomains(self, offset: int, limit: int):
        self._oprot.writeMessageBegin('getDomains', TMessageType.CALL, self._seqid)
        args = getDomains_args()
        args.offset = offset
        args.limit = limit
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getDomains(self) -> list[airavata.model.sharing.ttypes.Domain]:
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getDomains_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.sre is not None:
            raise result.sre
        raise TApplicationException(TApplicationException.MISSING_RESULT, "getDomains failed: unknown result")

    def createUser(self, user: airavata.model.sharing.ttypes.User) -> str:
        """
        <p>API method to register a user in the system</p>

        Parameters:
         - user

        """
        self.send_createUser(user)
        return self.recv_createUser()

    def send_createUser(self, user: airavata.model.sharing.ttypes.User):
        self._oprot.writeMessageBegin('createUser', TMessageType.CALL, self._seqid)
        args = createUser_args()
        args.user = user
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_createUser(self) -> str:
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = createUser_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.sre is not None:
            raise result.sre
        if result.dee is not None:
            raise result.dee
        raise TApplicationException(TApplicationException.MISSING_RESULT, "createUser failed: unknown result")

    def updatedUser(self, user: airavata.model.sharing.ttypes.User) -> bool:
        """
        <p>API method to update existing user</p>

        Parameters:
         - user

        """
        self.send_updatedUser(user)
        return self.recv_updatedUser()

    def send_updatedUser(self, user: airavata.model.sharing.ttypes.User):
        self._oprot.writeMessageBegin('updatedUser', TMessageType.CALL, self._seqid)
        args = updatedUser_args()
        args.user = user
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_updatedUser(self) -> bool:
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = updatedUser_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.sre is not None:
            raise result.sre
        raise TApplicationException(TApplicationException.MISSING_RESULT, "updatedUser failed: unknown result")

    def isUserExists(self, domainId: str, userId: str) -> bool:
        """
        <p>API method to check User Exists</p>

        Parameters:
         - domainId
         - userId

        """
        self.send_isUserExists(domainId, userId)
        return self.recv_isUserExists()

    def send_isUserExists(self, domainId: str, userId: str):
        self._oprot.writeMessageBegin('isUserExists', TMessageType.CALL, self._seqid)
        args = isUserExists_args()
        args.domainId = domainId
        args.userId = userId
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_isUserExists(self) -> bool:
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = isUserExists_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.sre is not None:
            raise result.sre
        raise TApplicationException(TApplicationException.MISSING_RESULT, "isUserExists failed: unknown result")

    def deleteUser(self, domainId: str, userId: str) -> bool:
        """
        <p>API method to delete user</p>

        Parameters:
         - domainId
         - userId

        """
        self.send_deleteUser(domainId, userId)
        return self.recv_deleteUser()

    def send_deleteUser(self, domainId: str, userId: str):
        self._oprot.writeMessageBegin('deleteUser', TMessageType.CALL, self._seqid)
        args = deleteUser_args()
        args.domainId = domainId
        args.userId = userId
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_deleteUser(self) -> bool:
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = deleteUser_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.sre is not None:
            raise result.sre
        raise TApplicationException(TApplicationException.MISSING_RESULT, "deleteUser failed: unknown result")

    def getUser(self, domainId: str, userId: str) -> airavata.model.sharing.ttypes.User:
        """
        <p>API method to get a user</p>

        Parameters:
         - domainId
         - userId

        """
        self.send_getUser(domainId, userId)
        return self.recv_getUser()

    def send_getUser(self, domainId: str, userId: str):
        self._oprot.writeMessageBegin('getUser', TMessageType.CALL, self._seqid)
        args = getUser_args()
        args.domainId = domainId
        args.userId = userId
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getUser(self) -> airavata.model.sharing.ttypes.User:
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getUser_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.sre is not None:
            raise result.sre
        raise TApplicationException(TApplicationException.MISSING_RESULT, "getUser failed: unknown result")

    def getUsers(self, domainId: str, offset: int, limit: int) -> list[airavata.model.sharing.ttypes.User]:
        """
        <p>API method to get a list of users in a specific domain.</p>
        <li>domainId : Domain id</li>
        <li>offset : Starting result number</li>
        <li>limit : Number of max results to be sent</li>

        Parameters:
         - domainId
         - offset
         - limit

        """
        self.send_getUsers(domainId, offset, limit)
        return self.recv_getUsers()

    def send_getUsers(self, domainId: str, offset: int, limit: int):
        self._oprot.writeMessageBegin('getUsers', TMessageType.CALL, self._seqid)
        args = getUsers_args()
        args.domainId = domainId
        args.offset = offset
        args.limit = limit
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getUsers(self) -> list[airavata.model.sharing.ttypes.User]:
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getUsers_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.sre is not None:
            raise result.sre
        raise TApplicationException(TApplicationException.MISSING_RESULT, "getUsers failed: unknown result")

    def createGroup(self, group: airavata.model.sharing.ttypes.UserGroup) -> str:
        """
        <p>API method to create a new group</p>

        Parameters:
         - group

        """
        self.send_createGroup(group)
        return self.recv_createGroup()

    def send_createGroup(self, group: airavata.model.sharing.ttypes.UserGroup):
        self._oprot.writeMessageBegin('createGroup', TMessageType.CALL, self._seqid)
        args = createGroup_args()
        args.group = group
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_createGroup(self) -> str:
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = createGroup_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.sre is not None:
            raise result.sre
        raise TApplicationException(TApplicationException.MISSING_RESULT, "createGroup failed: unknown result")

    def updateGroup(self, group: airavata.model.sharing.ttypes.UserGroup) -> bool:
        """
        <p>API method to update a group</p>

        Parameters:
         - group

        """
        self.send_updateGroup(group)
        return self.recv_updateGroup()

    def send_updateGroup(self, group: airavata.model.sharing.ttypes.UserGroup):
        self._oprot.writeMessageBegin('updateGroup', TMessageType.CALL, self._seqid)
        args = updateGroup_args()
        args.group = group
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_updateGroup(self) -> bool:
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = updateGroup_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.sre is not None:
            raise result.sre
        raise TApplicationException(TApplicationException.MISSING_RESULT, "updateGroup failed: unknown result")

    def isGroupExists(self, domainId: str, groupId: str) -> bool:
        """
        <p>API method to check Group Exists</p>

        Parameters:
         - domainId
         - groupId

        """
        self.send_isGroupExists(domainId, groupId)
        return self.recv_isGroupExists()

    def send_isGroupExists(self, domainId: str, groupId: str):
        self._oprot.writeMessageBegin('isGroupExists', TMessageType.CALL, self._seqid)
        args = isGroupExists_args()
        args.domainId = domainId
        args.groupId = groupId
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_isGroupExists(self) -> bool:
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = isGroupExists_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.sre is not None:
            raise result.sre
        raise TApplicationException(TApplicationException.MISSING_RESULT, "isGroupExists failed: unknown result")

    def deleteGroup(self, domainId: str, groupId: str) -> bool:
        """
        <p>API method to delete a group</p>

        Parameters:
         - domainId
         - groupId

        """
        self.send_deleteGroup(domainId, groupId)
        return self.recv_deleteGroup()

    def send_deleteGroup(self, domainId: str, groupId: str):
        self._oprot.writeMessageBegin('deleteGroup', TMessageType.CALL, self._seqid)
        args = deleteGroup_args()
        args.domainId = domainId
        args.groupId = groupId
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_deleteGroup(self) -> bool:
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = deleteGroup_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.sre is not None:
            raise result.sre
        raise TApplicationException(TApplicationException.MISSING_RESULT, "deleteGroup failed: unknown result")

    def getGroup(self, domainId: str, groupId: str) -> airavata.model.sharing.ttypes.UserGroup:
        """
        <p>API method to get a group</p>

        Parameters:
         - domainId
         - groupId

        """
        self.send_getGroup(domainId, groupId)
        return self.recv_getGroup()

    def send_getGroup(self, domainId: str, groupId: str):
        self._oprot.writeMessageBegin('getGroup', TMessageType.CALL, self._seqid)
        args = getGroup_args()
        args.domainId = domainId
        args.groupId = groupId
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getGroup(self) -> airavata.model.sharing.ttypes.UserGroup:
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getGroup_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.sre is not None:
            raise result.sre
        raise TApplicationException(TApplicationException.MISSING_RESULT, "getGroup failed: unknown result")

    def getGroups(self, domainId: str, offset: int, limit: int) -> list[airavata.model.sharing.ttypes.UserGroup]:
        """
        <p>API method to get groups in a domainId.</p>

        Parameters:
         - domainId
         - offset
         - limit

        """
        self.send_getGroups(domainId, offset, limit)
        return self.recv_getGroups()

    def send_getGroups(self, domainId: str, offset: int, limit: int):
        self._oprot.writeMessageBegin('getGroups', TMessageType.CALL, self._seqid)
        args = getGroups_args()
        args.domainId = domainId
        args.offset = offset
        args.limit = limit
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getGroups(self) -> list[airavata.model.sharing.ttypes.UserGroup]:
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getGroups_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "getGroups failed: unknown result")

    def addUsersToGroup(self, domainId: str, userIds: list[str], groupId: str) -> bool:
        """
        <p>API method to add list of users to a group</p>

        Parameters:
         - domainId
         - userIds
         - groupId

        """
        self.send_addUsersToGroup(domainId, userIds, groupId)
        return self.recv_addUsersToGroup()

    def send_addUsersToGroup(self, domainId: str, userIds: list[str], groupId: str):
        self._oprot.writeMessageBegin('addUsersToGroup', TMessageType.CALL, self._seqid)
        args = addUsersToGroup_args()
        args.domainId = domainId
        args.userIds = userIds
        args.groupId = groupId
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_addUsersToGroup(self) -> bool:
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = addUsersToGroup_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.sre is not None:
            raise result.sre
        raise TApplicationException(TApplicationException.MISSING_RESULT, "addUsersToGroup failed: unknown result")

    def removeUsersFromGroup(self, domainId: str, userIds: list[str], groupId: str) -> bool:
        """
        <p>API method to remove users from a group</p>

        Parameters:
         - domainId
         - userIds
         - groupId

        """
        self.send_removeUsersFromGroup(domainId, userIds, groupId)
        return self.recv_removeUsersFromGroup()

    def send_removeUsersFromGroup(self, domainId: str, userIds: list[str], groupId: str):
        self._oprot.writeMessageBegin('removeUsersFromGroup', TMessageType.CALL, self._seqid)
        args = removeUsersFromGroup_args()
        args.domainId = domainId
        args.userIds = userIds
        args.groupId = groupId
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_removeUsersFromGroup(self) -> bool:
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = removeUsersFromGroup_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.sre is not None:
            raise result.sre
        raise TApplicationException(TApplicationException.MISSING_RESULT, "removeUsersFromGroup failed: unknown result")

    def transferGroupOwnership(self, domainId: str, groupId: str, newOwnerId: str) -> bool:
        """
        <p>API method to transfer group ownership</p>

        Parameters:
         - domainId
         - groupId
         - newOwnerId

        """
        self.send_transferGroupOwnership(domainId, groupId, newOwnerId)
        return self.recv_transferGroupOwnership()

    def send_transferGroupOwnership(self, domainId: str, groupId: str, newOwnerId: str):
        self._oprot.writeMessageBegin('transferGroupOwnership', TMessageType.CALL, self._seqid)
        args = transferGroupOwnership_args()
        args.domainId = domainId
        args.groupId = groupId
        args.newOwnerId = newOwnerId
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_transferGroupOwnership(self) -> bool:
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = transferGroupOwnership_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.sre is not None:
            raise result.sre
        raise TApplicationException(TApplicationException.MISSING_RESULT, "transferGroupOwnership failed: unknown result")

    def addGroupAdmins(self, domainId: str, groupId: str, adminIds: list[str]) -> bool:
        """
        <p>API method to add Admin for a group</p>

        Parameters:
         - domainId
         - groupId
         - adminIds

        """
        self.send_addGroupAdmins(domainId, groupId, adminIds)
        return self.recv_addGroupAdmins()

    def send_addGroupAdmins(self, domainId: str, groupId: str, adminIds: list[str]):
        self._oprot.writeMessageBegin('addGroupAdmins', TMessageType.CALL, self._seqid)
        args = addGroupAdmins_args()
        args.domainId = domainId
        args.groupId = groupId
        args.adminIds = adminIds
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_addGroupAdmins(self) -> bool:
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = addGroupAdmins_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.sre is not None:
            raise result.sre
        raise TApplicationException(TApplicationException.MISSING_RESULT, "addGroupAdmins failed: unknown result")

    def removeGroupAdmins(self, domainId: str, groupId: str, adminIds: list[str]) -> bool:
        """
        <p>API method to remove Admin for a group</p>

        Parameters:
         - domainId
         - groupId
         - adminIds

        """
        self.send_removeGroupAdmins(domainId, groupId, adminIds)
        return self.recv_removeGroupAdmins()

    def send_removeGroupAdmins(self, domainId: str, groupId: str, adminIds: list[str]):
        self._oprot.writeMessageBegin('removeGroupAdmins', TMessageType.CALL, self._seqid)
        args = removeGroupAdmins_args()
        args.domainId = domainId
        args.groupId = groupId
        args.adminIds = adminIds
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_removeGroupAdmins(self) -> bool:
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = removeGroupAdmins_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.sre is not None:
            raise result.sre
        raise TApplicationException(TApplicationException.MISSING_RESULT, "removeGroupAdmins failed: unknown result")

    def hasAdminAccess(self, domainId: str, groupId: str, adminId: str) -> bool:
        """
        <p>API method to check whether the user has Admin access for the group</p>

        Parameters:
         - domainId
         - groupId
         - adminId

        """
        self.send_hasAdminAccess(domainId, groupId, adminId)
        return self.recv_hasAdminAccess()

    def send_hasAdminAccess(self, domainId: str, groupId: str, adminId: str):
        self._oprot.writeMessageBegin('hasAdminAccess', TMessageType.CALL, self._seqid)
        args = hasAdminAccess_args()
        args.domainId = domainId
        args.groupId = groupId
        args.adminId = adminId
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_hasAdminAccess(self) -> bool:
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = hasAdminAccess_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.sre is not None:
            raise result.sre
        raise TApplicationException(TApplicationException.MISSING_RESULT, "hasAdminAccess failed: unknown result")

    def hasOwnerAccess(self, domainId: str, groupId: str, ownerId: str) -> bool:
        """
        <p>API method to check whether the user has Admin access for the group</p>

        Parameters:
         - domainId
         - groupId
         - ownerId

        """
        self.send_hasOwnerAccess(domainId, groupId, ownerId)
        return self.recv_hasOwnerAccess()

    def send_hasOwnerAccess(self, domainId: str, groupId: str, ownerId: str):
        self._oprot.writeMessageBegin('hasOwnerAccess', TMessageType.CALL, self._seqid)
        args = hasOwnerAccess_args()
        args.domainId = domainId
        args.groupId = groupId
        args.ownerId = ownerId
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_hasOwnerAccess(self) -> bool:
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = hasOwnerAccess_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.sre is not None:
            raise result.sre
        raise TApplicationException(TApplicationException.MISSING_RESULT, "hasOwnerAccess failed: unknown result")

    def getGroupMembersOfTypeUser(self, domainId: str, groupId: str, offset: int, limit: int) -> list[airavata.model.sharing.ttypes.User]:
        """
        <p>API method to get list of child users in a group. Only the direct members will be returned.</p>

        Parameters:
         - domainId
         - groupId
         - offset
         - limit

        """
        self.send_getGroupMembersOfTypeUser(domainId, groupId, offset, limit)
        return self.recv_getGroupMembersOfTypeUser()

    def send_getGroupMembersOfTypeUser(self, domainId: str, groupId: str, offset: int, limit: int):
        self._oprot.writeMessageBegin('getGroupMembersOfTypeUser', TMessageType.CALL, self._seqid)
        args = getGroupMembersOfTypeUser_args()
        args.domainId = domainId
        args.groupId = groupId
        args.offset = offset
        args.limit = limit
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getGroupMembersOfTypeUser(self) -> list[airavata.model.sharing.ttypes.User]:
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getGroupMembersOfTypeUser_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.sre is not None:
            raise result.sre
        raise TApplicationException(TApplicationException.MISSING_RESULT, "getGroupMembersOfTypeUser failed: unknown result")

    def getGroupMembersOfTypeGroup(self, domainId: str, groupId: str, offset: int, limit: int) -> list[airavata.model.sharing.ttypes.UserGroup]:
        """
        <p>API method to get list of child groups in a group. Only the direct members will be returned.</p>

        Parameters:
         - domainId
         - groupId
         - offset
         - limit

        """
        self.send_getGroupMembersOfTypeGroup(domainId, groupId, offset, limit)
        return self.recv_getGroupMembersOfTypeGroup()

    def send_getGroupMembersOfTypeGroup(self, domainId: str, groupId: str, offset: int, limit: int):
        self._oprot.writeMessageBegin('getGroupMembersOfTypeGroup', TMessageType.CALL, self._seqid)
        args = getGroupMembersOfTypeGroup_args()
        args.domainId = domainId
        args.groupId = groupId
        args.offset = offset
        args.limit = limit
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getGroupMembersOfTypeGroup(self) -> list[airavata.model.sharing.ttypes.UserGroup]:
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getGroupMembersOfTypeGroup_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.sre is not None:
            raise result.sre
        raise TApplicationException(TApplicationException.MISSING_RESULT, "getGroupMembersOfTypeGroup failed: unknown result")

    def addChildGroupsToParentGroup(self, domainId: str, childIds: list[str], groupId: str) -> bool:
        """
        <p>API method to add a child group to a parent group.</p>

        Parameters:
         - domainId
         - childIds
         - groupId

        """
        self.send_addChildGroupsToParentGroup(domainId, childIds, groupId)
        return self.recv_addChildGroupsToParentGroup()

    def send_addChildGroupsToParentGroup(self, domainId: str, childIds: list[str], groupId: str):
        self._oprot.writeMessageBegin('addChildGroupsToParentGroup', TMessageType.CALL, self._seqid)
        args = addChildGroupsToParentGroup_args()
        args.domainId = domainId
        args.childIds = childIds
        args.groupId = groupId
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_addChildGroupsToParentGroup(self) -> bool:
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = addChildGroupsToParentGroup_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.sre is not None:
            raise result.sre
        raise TApplicationException(TApplicationException.MISSING_RESULT, "addChildGroupsToParentGroup failed: unknown result")

    def removeChildGroupFromParentGroup(self, domainId: str, childId: str, groupId: str) -> bool:
        """
        <p>API method to remove a child group from parent group.</p>

        Parameters:
         - domainId
         - childId
         - groupId

        """
        self.send_removeChildGroupFromParentGroup(domainId, childId, groupId)
        return self.recv_removeChildGroupFromParentGroup()

    def send_removeChildGroupFromParentGroup(self, domainId: str, childId: str, groupId: str):
        self._oprot.writeMessageBegin('removeChildGroupFromParentGroup', TMessageType.CALL, self._seqid)
        args = removeChildGroupFromParentGroup_args()
        args.domainId = domainId
        args.childId = childId
        args.groupId = groupId
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_removeChildGroupFromParentGroup(self) -> bool:
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = removeChildGroupFromParentGroup_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.sre is not None:
            raise result.sre
        raise TApplicationException(TApplicationException.MISSING_RESULT, "removeChildGroupFromParentGroup failed: unknown result")

    def getAllMemberGroupsForUser(self, domainId: str, userId: str) -> list[airavata.model.sharing.ttypes.UserGroup]:
        """
        Parameters:
         - domainId
         - userId

        """
        self.send_getAllMemberGroupsForUser(domainId, userId)
        return self.recv_getAllMemberGroupsForUser()

    def send_getAllMemberGroupsForUser(self, domainId: str, userId: str):
        self._oprot.writeMessageBegin('getAllMemberGroupsForUser', TMessageType.CALL, self._seqid)
        args = getAllMemberGroupsForUser_args()
        args.domainId = domainId
        args.userId = userId
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getAllMemberGroupsForUser(self) -> list[airavata.model.sharing.ttypes.UserGroup]:
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getAllMemberGroupsForUser_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.sre is not None:
            raise result.sre
        raise TApplicationException(TApplicationException.MISSING_RESULT, "getAllMemberGroupsForUser failed: unknown result")

    def createEntityType(self, entityType: airavata.model.sharing.ttypes.EntityType) -> str:
        """
        <p>API method to create a new entity type</p>

        Parameters:
         - entityType

        """
        self.send_createEntityType(entityType)
        return self.recv_createEntityType()

    def send_createEntityType(self, entityType: airavata.model.sharing.ttypes.EntityType):
        self._oprot.writeMessageBegin('createEntityType', TMessageType.CALL, self._seqid)
        args = createEntityType_args()
        args.entityType = entityType
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_createEntityType(self) -> str:
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = createEntityType_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.sre is not None:
            raise result.sre
        if result.dee is not None:
            raise result.dee
        raise TApplicationException(TApplicationException.MISSING_RESULT, "createEntityType failed: unknown result")

    def updateEntityType(self, entityType: airavata.model.sharing.ttypes.EntityType) -> bool:
        """
        <p>API method to update entity type</p>

        Parameters:
         - entityType

        """
        self.send_updateEntityType(entityType)
        return self.recv_updateEntityType()

    def send_updateEntityType(self, entityType: airavata.model.sharing.ttypes.EntityType):
        self._oprot.writeMessageBegin('updateEntityType', TMessageType.CALL, self._seqid)
        args = updateEntityType_args()
        args.entityType = entityType
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_updateEntityType(self) -> bool:
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = updateEntityType_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.sre is not None:
            raise result.sre
        raise TApplicationException(TApplicationException.MISSING_RESULT, "updateEntityType failed: unknown result")

    def isEntityTypeExists(self, domainId: str, entityTypeId: str) -> bool:
        """
        <p>API method to check EntityType Exists</p>

        Parameters:
         - domainId
         - entityTypeId

        """
        self.send_isEntityTypeExists(domainId, entityTypeId)
        return self.recv_isEntityTypeExists()

    def send_isEntityTypeExists(self, domainId: str, entityTypeId: str):
        self._oprot.writeMessageBegin('isEntityTypeExists', TMessageType.CALL, self._seqid)
        args = isEntityTypeExists_args()
        args.domainId = domainId
        args.entityTypeId = entityTypeId
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_isEntityTypeExists(self) -> bool:
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = isEntityTypeExists_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.sre is not None:
            raise result.sre
        raise TApplicationException(TApplicationException.MISSING_RESULT, "isEntityTypeExists failed: unknown result")

    def deleteEntityType(self, domainId: str, entityTypeId: str) -> bool:
        """
        <p>API method to delete entity type</p>

        Parameters:
         - domainId
         - entityTypeId

        """
        self.send_deleteEntityType(domainId, entityTypeId)
        return self.recv_deleteEntityType()

    def send_deleteEntityType(self, domainId: str, entityTypeId: str):
        self._oprot.writeMessageBegin('deleteEntityType', TMessageType.CALL, self._seqid)
        args = deleteEntityType_args()
        args.domainId = domainId
        args.entityTypeId = entityTypeId
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_deleteEntityType(self) -> bool:
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = deleteEntityType_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.sre is not None:
            raise result.sre
        raise TApplicationException(TApplicationException.MISSING_RESULT, "deleteEntityType failed: unknown result")

    def getEntityType(self, domainId: str, entityTypeId: str) -> airavata.model.sharing.ttypes.EntityType:
        """
        <p>API method to get an entity type</p>

        Parameters:
         - domainId
         - entityTypeId

        """
        self.send_getEntityType(domainId, entityTypeId)
        return self.recv_getEntityType()

    def send_getEntityType(self, domainId: str, entityTypeId: str):
        self._oprot.writeMessageBegin('getEntityType', TMessageType.CALL, self._seqid)
        args = getEntityType_args()
        args.domainId = domainId
        args.entityTypeId = entityTypeId
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getEntityType(self) -> airavata.model.sharing.ttypes.EntityType:
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getEntityType_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.sre is not None:
            raise result.sre
        raise TApplicationException(TApplicationException.MISSING_RESULT, "getEntityType failed: unknown result")

    def getEntityTypes(self, domainId: str, offset: int, limit: int) -> list[airavata.model.sharing.ttypes.EntityType]:
        """
        <p>API method to get entity types in a domainId.</p>

        Parameters:
         - domainId
         - offset
         - limit

        """
        self.send_getEntityTypes(domainId, offset, limit)
        return self.recv_getEntityTypes()

    def send_getEntityTypes(self, domainId: str, offset: int, limit: int):
        self._oprot.writeMessageBegin('getEntityTypes', TMessageType.CALL, self._seqid)
        args = getEntityTypes_args()
        args.domainId = domainId
        args.offset = offset
        args.limit = limit
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getEntityTypes(self) -> list[airavata.model.sharing.ttypes.EntityType]:
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getEntityTypes_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.sre is not None:
            raise result.sre
        raise TApplicationException(TApplicationException.MISSING_RESULT, "getEntityTypes failed: unknown result")

    def createEntity(self, entity: airavata.model.sharing.ttypes.Entity) -> str:
        """
        <p>API method to register new entity</p>

        Parameters:
         - entity

        """
        self.send_createEntity(entity)
        return self.recv_createEntity()

    def send_createEntity(self, entity: airavata.model.sharing.ttypes.Entity):
        self._oprot.writeMessageBegin('createEntity', TMessageType.CALL, self._seqid)
        args = createEntity_args()
        args.entity = entity
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_createEntity(self) -> str:
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = createEntity_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.sre is not None:
            raise result.sre
        raise TApplicationException(TApplicationException.MISSING_RESULT, "createEntity failed: unknown result")

    def updateEntity(self, entity: airavata.model.sharing.ttypes.Entity) -> bool:
        """
        <p>API method to update entity</p>

        Parameters:
         - entity

        """
        self.send_updateEntity(entity)
        return self.recv_updateEntity()

    def send_updateEntity(self, entity: airavata.model.sharing.ttypes.Entity):
        self._oprot.writeMessageBegin('updateEntity', TMessageType.CALL, self._seqid)
        args = updateEntity_args()
        args.entity = entity
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_updateEntity(self) -> bool:
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = updateEntity_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.sre is not None:
            raise result.sre
        raise TApplicationException(TApplicationException.MISSING_RESULT, "updateEntity failed: unknown result")

    def isEntityExists(self, domainId: str, entityId: str) -> bool:
        """
        <p>API method to check Entity Exists</p>

        Parameters:
         - domainId
         - entityId

        """
        self.send_isEntityExists(domainId, entityId)
        return self.recv_isEntityExists()

    def send_isEntityExists(self, domainId: str, entityId: str):
        self._oprot.writeMessageBegin('isEntityExists', TMessageType.CALL, self._seqid)
        args = isEntityExists_args()
        args.domainId = domainId
        args.entityId = entityId
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_isEntityExists(self) -> bool:
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = isEntityExists_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.sre is not None:
            raise result.sre
        raise TApplicationException(TApplicationException.MISSING_RESULT, "isEntityExists failed: unknown result")

    def deleteEntity(self, domainId: str, entityId: str) -> bool:
        """
        <p>API method to delete entity</p>

        Parameters:
         - domainId
         - entityId

        """
        self.send_deleteEntity(domainId, entityId)
        return self.recv_deleteEntity()

    def send_deleteEntity(self, domainId: str, entityId: str):
        self._oprot.writeMessageBegin('deleteEntity', TMessageType.CALL, self._seqid)
        args = deleteEntity_args()
        args.domainId = domainId
        args.entityId = entityId
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_deleteEntity(self) -> bool:
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = deleteEntity_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.sre is not None:
            raise result.sre
        raise TApplicationException(TApplicationException.MISSING_RESULT, "deleteEntity failed: unknown result")

    def getEntity(self, domainId: str, entityId: str) -> airavata.model.sharing.ttypes.Entity:
        """
        <p>API method to get entity</p>

        Parameters:
         - domainId
         - entityId

        """
        self.send_getEntity(domainId, entityId)
        return self.recv_getEntity()

    def send_getEntity(self, domainId: str, entityId: str):
        self._oprot.writeMessageBegin('getEntity', TMessageType.CALL, self._seqid)
        args = getEntity_args()
        args.domainId = domainId
        args.entityId = entityId
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getEntity(self) -> airavata.model.sharing.ttypes.Entity:
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getEntity_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.sre is not None:
            raise result.sre
        raise TApplicationException(TApplicationException.MISSING_RESULT, "getEntity failed: unknown result")

    def searchEntities(self, domainId: str, userId: str, filters: list[airavata.model.sharing.ttypes.SearchCriteria], offset: int, limit: int) -> list[airavata.model.sharing.ttypes.Entity]:
        """
        <p>API method to search entities</p>

        Parameters:
         - domainId
         - userId
         - filters
         - offset
         - limit

        """
        self.send_searchEntities(domainId, userId, filters, offset, limit)
        return self.recv_searchEntities()

    def send_searchEntities(self, domainId: str, userId: str, filters: list[airavata.model.sharing.ttypes.SearchCriteria], offset: int, limit: int):
        self._oprot.writeMessageBegin('searchEntities', TMessageType.CALL, self._seqid)
        args = searchEntities_args()
        args.domainId = domainId
        args.userId = userId
        args.filters = filters
        args.offset = offset
        args.limit = limit
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_searchEntities(self) -> list[airavata.model.sharing.ttypes.Entity]:
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = searchEntities_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.sre is not None:
            raise result.sre
        raise TApplicationException(TApplicationException.MISSING_RESULT, "searchEntities failed: unknown result")

    def getListOfSharedUsers(self, domainId: str, entityId: str, permissionTypeId: str) -> list[airavata.model.sharing.ttypes.User]:
        """
        <p>API method to get a list of shared users given the entity id</p>

        Parameters:
         - domainId
         - entityId
         - permissionTypeId

        """
        self.send_getListOfSharedUsers(domainId, entityId, permissionTypeId)
        return self.recv_getListOfSharedUsers()

    def send_getListOfSharedUsers(self, domainId: str, entityId: str, permissionTypeId: str):
        self._oprot.writeMessageBegin('getListOfSharedUsers', TMessageType.CALL, self._seqid)
        args = getListOfSharedUsers_args()
        args.domainId = domainId
        args.entityId = entityId
        args.permissionTypeId = permissionTypeId
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getListOfSharedUsers(self) -> list[airavata.model.sharing.ttypes.User]:
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getListOfSharedUsers_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.sre is not None:
            raise result.sre
        raise TApplicationException(TApplicationException.MISSING_RESULT, "getListOfSharedUsers failed: unknown result")

    def getListOfDirectlySharedUsers(self, domainId: str, entityId: str, permissionTypeId: str) -> list[airavata.model.sharing.ttypes.User]:
        """
        <p>API method to get a list of shared users given the entity id where the sharing type is directly applied</p>

        Parameters:
         - domainId
         - entityId
         - permissionTypeId

        """
        self.send_getListOfDirectlySharedUsers(domainId, entityId, permissionTypeId)
        return self.recv_getListOfDirectlySharedUsers()

    def send_getListOfDirectlySharedUsers(self, domainId: str, entityId: str, permissionTypeId: str):
        self._oprot.writeMessageBegin('getListOfDirectlySharedUsers', TMessageType.CALL, self._seqid)
        args = getListOfDirectlySharedUsers_args()
        args.domainId = domainId
        args.entityId = entityId
        args.permissionTypeId = permissionTypeId
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getListOfDirectlySharedUsers(self) -> list[airavata.model.sharing.ttypes.User]:
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getListOfDirectlySharedUsers_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.sre is not None:
            raise result.sre
        raise TApplicationException(TApplicationException.MISSING_RESULT, "getListOfDirectlySharedUsers failed: unknown result")

    def getListOfSharedGroups(self, domainId: str, entityId: str, permissionTypeId: str) -> list[airavata.model.sharing.ttypes.UserGroup]:
        """
        <p>API method to get a list of shared groups given the entity id</p>

        Parameters:
         - domainId
         - entityId
         - permissionTypeId

        """
        self.send_getListOfSharedGroups(domainId, entityId, permissionTypeId)
        return self.recv_getListOfSharedGroups()

    def send_getListOfSharedGroups(self, domainId: str, entityId: str, permissionTypeId: str):
        self._oprot.writeMessageBegin('getListOfSharedGroups', TMessageType.CALL, self._seqid)
        args = getListOfSharedGroups_args()
        args.domainId = domainId
        args.entityId = entityId
        args.permissionTypeId = permissionTypeId
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getListOfSharedGroups(self) -> list[airavata.model.sharing.ttypes.UserGroup]:
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getListOfSharedGroups_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.sre is not None:
            raise result.sre
        raise TApplicationException(TApplicationException.MISSING_RESULT, "getListOfSharedGroups failed: unknown result")

    def getListOfDirectlySharedGroups(self, domainId: str, entityId: str, permissionTypeId: str) -> list[airavata.model.sharing.ttypes.UserGroup]:
        """
        <p>API method to get a list of directly shared groups given the entity id where the sharing type is directly applied</p>

        Parameters:
         - domainId
         - entityId
         - permissionTypeId

        """
        self.send_getListOfDirectlySharedGroups(domainId, entityId, permissionTypeId)
        return self.recv_getListOfDirectlySharedGroups()

    def send_getListOfDirectlySharedGroups(self, domainId: str, entityId: str, permissionTypeId: str):
        self._oprot.writeMessageBegin('getListOfDirectlySharedGroups', TMessageType.CALL, self._seqid)
        args = getListOfDirectlySharedGroups_args()
        args.domainId = domainId
        args.entityId = entityId
        args.permissionTypeId = permissionTypeId
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getListOfDirectlySharedGroups(self) -> list[airavata.model.sharing.ttypes.UserGroup]:
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getListOfDirectlySharedGroups_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.sre is not None:
            raise result.sre
        raise TApplicationException(TApplicationException.MISSING_RESULT, "getListOfDirectlySharedGroups failed: unknown result")

    def createPermissionType(self, permissionType: airavata.model.sharing.ttypes.PermissionType) -> str:
        """
        <p>API method to create permission type</p>

        Parameters:
         - permissionType

        """
        self.send_createPermissionType(permissionType)
        return self.recv_createPermissionType()

    def send_createPermissionType(self, permissionType: airavata.model.sharing.ttypes.PermissionType):
        self._oprot.writeMessageBegin('createPermissionType', TMessageType.CALL, self._seqid)
        args = createPermissionType_args()
        args.permissionType = permissionType
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_createPermissionType(self) -> str:
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = createPermissionType_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.sre is not None:
            raise result.sre
        if result.dee is not None:
            raise result.dee
        raise TApplicationException(TApplicationException.MISSING_RESULT, "createPermissionType failed: unknown result")

    def updatePermissionType(self, permissionType: airavata.model.sharing.ttypes.PermissionType) -> bool:
        """
        <p>API method to update permission type</p>

        Parameters:
         - permissionType

        """
        self.send_updatePermissionType(permissionType)
        return self.recv_updatePermissionType()

    def send_updatePermissionType(self, permissionType: airavata.model.sharing.ttypes.PermissionType):
        self._oprot.writeMessageBegin('updatePermissionType', TMessageType.CALL, self._seqid)
        args = updatePermissionType_args()
        args.permissionType = permissionType
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_updatePermissionType(self) -> bool:
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = updatePermissionType_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.sre is not None:
            raise result.sre
        raise TApplicationException(TApplicationException.MISSING_RESULT, "updatePermissionType failed: unknown result")

    def isPermissionExists(self, dimainId: str, permissionId: str) -> bool:
        """
        <p>API method to check Permission Exists</p>

        Parameters:
         - dimainId
         - permissionId

        """
        self.send_isPermissionExists(dimainId, permissionId)
        return self.recv_isPermissionExists()

    def send_isPermissionExists(self, dimainId: str, permissionId: str):
        self._oprot.writeMessageBegin('isPermissionExists', TMessageType.CALL, self._seqid)
        args = isPermissionExists_args()
        args.dimainId = dimainId
        args.permissionId = permissionId
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_isPermissionExists(self) -> bool:
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = isPermissionExists_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.sre is not None:
            raise result.sre
        raise TApplicationException(TApplicationException.MISSING_RESULT, "isPermissionExists failed: unknown result")

    def deletePermissionType(self, domainId: str, permissionTypeId: str) -> bool:
        """
        <p>API method to delete permission type</p>

        Parameters:
         - domainId
         - permissionTypeId

        """
        self.send_deletePermissionType(domainId, permissionTypeId)
        return self.recv_deletePermissionType()

    def send_deletePermissionType(self, domainId: str, permissionTypeId: str):
        self._oprot.writeMessageBegin('deletePermissionType', TMessageType.CALL, self._seqid)
        args = deletePermissionType_args()
        args.domainId = domainId
        args.permissionTypeId = permissionTypeId
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_deletePermissionType(self) -> bool:
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = deletePermissionType_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.sre is not None:
            raise result.sre
        raise TApplicationException(TApplicationException.MISSING_RESULT, "deletePermissionType failed: unknown result")

    def getPermissionType(self, domainId: str, permissionTypeId: str) -> airavata.model.sharing.ttypes.PermissionType:
        """
        <p>API method to get permission type</p>

        Parameters:
         - domainId
         - permissionTypeId

        """
        self.send_getPermissionType(domainId, permissionTypeId)
        return self.recv_getPermissionType()

    def send_getPermissionType(self, domainId: str, permissionTypeId: str):
        self._oprot.writeMessageBegin('getPermissionType', TMessageType.CALL, self._seqid)
        args = getPermissionType_args()
        args.domainId = domainId
        args.permissionTypeId = permissionTypeId
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getPermissionType(self) -> airavata.model.sharing.ttypes.PermissionType:
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getPermissionType_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.sre is not None:
            raise result.sre
        raise TApplicationException(TApplicationException.MISSING_RESULT, "getPermissionType failed: unknown result")

    def getPermissionTypes(self, domainId: str, offset: int, limit: int) -> list[airavata.model.sharing.ttypes.PermissionType]:
        """
        <p>API method to get list of permission types in a given domainId.</p>

        Parameters:
         - domainId
         - offset
         - limit

        """
        self.send_getPermissionTypes(domainId, offset, limit)
        return self.recv_getPermissionTypes()

    def send_getPermissionTypes(self, domainId: str, offset: int, limit: int):
        self._oprot.writeMessageBegin('getPermissionTypes', TMessageType.CALL, self._seqid)
        args = getPermissionTypes_args()
        args.domainId = domainId
        args.offset = offset
        args.limit = limit
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getPermissionTypes(self) -> list[airavata.model.sharing.ttypes.PermissionType]:
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getPermissionTypes_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.sre is not None:
            raise result.sre
        raise TApplicationException(TApplicationException.MISSING_RESULT, "getPermissionTypes failed: unknown result")

    def shareEntityWithUsers(self, domainId: str, entityId: str, userList: list[str], permissionTypeId: str, cascadePermission: bool) -> bool:
        """
        <p>API method to share an entity with users</p>

        Parameters:
         - domainId
         - entityId
         - userList
         - permissionTypeId
         - cascadePermission

        """
        self.send_shareEntityWithUsers(domainId, entityId, userList, permissionTypeId, cascadePermission)
        return self.recv_shareEntityWithUsers()

    def send_shareEntityWithUsers(self, domainId: str, entityId: str, userList: list[str], permissionTypeId: str, cascadePermission: bool):
        self._oprot.writeMessageBegin('shareEntityWithUsers', TMessageType.CALL, self._seqid)
        args = shareEntityWithUsers_args()
        args.domainId = domainId
        args.entityId = entityId
        args.userList = userList
        args.permissionTypeId = permissionTypeId
        args.cascadePermission = cascadePermission
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_shareEntityWithUsers(self) -> bool:
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = shareEntityWithUsers_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.sre is not None:
            raise result.sre
        raise TApplicationException(TApplicationException.MISSING_RESULT, "shareEntityWithUsers failed: unknown result")

    def revokeEntitySharingFromUsers(self, domainId: str, entityId: str, userList: list[str], permissionTypeId: str) -> bool:
        """
        <p>API method to revoke sharing from a list of users</p>

        Parameters:
         - domainId
         - entityId
         - userList
         - permissionTypeId

        """
        self.send_revokeEntitySharingFromUsers(domainId, entityId, userList, permissionTypeId)
        return self.recv_revokeEntitySharingFromUsers()

    def send_revokeEntitySharingFromUsers(self, domainId: str, entityId: str, userList: list[str], permissionTypeId: str):
        self._oprot.writeMessageBegin('revokeEntitySharingFromUsers', TMessageType.CALL, self._seqid)
        args = revokeEntitySharingFromUsers_args()
        args.domainId = domainId
        args.entityId = entityId
        args.userList = userList
        args.permissionTypeId = permissionTypeId
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_revokeEntitySharingFromUsers(self) -> bool:
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = revokeEntitySharingFromUsers_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.sre is not None:
            raise result.sre
        raise TApplicationException(TApplicationException.MISSING_RESULT, "revokeEntitySharingFromUsers failed: unknown result")

    def shareEntityWithGroups(self, domainId: str, entityId: str, groupList: list[str], permissionTypeId: str, cascadePermission: bool) -> bool:
        """
        <p>API method to share an entity with list of groups</p>

        Parameters:
         - domainId
         - entityId
         - groupList
         - permissionTypeId
         - cascadePermission

        """
        self.send_shareEntityWithGroups(domainId, entityId, groupList, permissionTypeId, cascadePermission)
        return self.recv_shareEntityWithGroups()

    def send_shareEntityWithGroups(self, domainId: str, entityId: str, groupList: list[str], permissionTypeId: str, cascadePermission: bool):
        self._oprot.writeMessageBegin('shareEntityWithGroups', TMessageType.CALL, self._seqid)
        args = shareEntityWithGroups_args()
        args.domainId = domainId
        args.entityId = entityId
        args.groupList = groupList
        args.permissionTypeId = permissionTypeId
        args.cascadePermission = cascadePermission
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_shareEntityWithGroups(self) -> bool:
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = shareEntityWithGroups_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.sre is not None:
            raise result.sre
        raise TApplicationException(TApplicationException.MISSING_RESULT, "shareEntityWithGroups failed: unknown result")

    def revokeEntitySharingFromGroups(self, domainId: str, entityId: str, groupList: list[str], permissionTypeId: str) -> bool:
        """
        <p>API method to revoke sharing from list of users</p>

        Parameters:
         - domainId
         - entityId
         - groupList
         - permissionTypeId

        """
        self.send_revokeEntitySharingFromGroups(domainId, entityId, groupList, permissionTypeId)
        return self.recv_revokeEntitySharingFromGroups()

    def send_revokeEntitySharingFromGroups(self, domainId: str, entityId: str, groupList: list[str], permissionTypeId: str):
        self._oprot.writeMessageBegin('revokeEntitySharingFromGroups', TMessageType.CALL, self._seqid)
        args = revokeEntitySharingFromGroups_args()
        args.domainId = domainId
        args.entityId = entityId
        args.groupList = groupList
        args.permissionTypeId = permissionTypeId
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_revokeEntitySharingFromGroups(self) -> bool:
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = revokeEntitySharingFromGroups_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.sre is not None:
            raise result.sre
        raise TApplicationException(TApplicationException.MISSING_RESULT, "revokeEntitySharingFromGroups failed: unknown result")

    def userHasAccess(self, domainId: str, userId: str, entityId: str, permissionTypeId: str) -> bool:
        """
        <p>API method to check whether a user has access to a specific entity</p>

        Parameters:
         - domainId
         - userId
         - entityId
         - permissionTypeId

        """
        self.send_userHasAccess(domainId, userId, entityId, permissionTypeId)
        return self.recv_userHasAccess()

    def send_userHasAccess(self, domainId: str, userId: str, entityId: str, permissionTypeId: str):
        self._oprot.writeMessageBegin('userHasAccess', TMessageType.CALL, self._seqid)
        args = userHasAccess_args()
        args.domainId = domainId
        args.userId = userId
        args.entityId = entityId
        args.permissionTypeId = permissionTypeId
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_userHasAccess(self) -> bool:
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = userHasAccess_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.sre is not None:
            raise result.sre
        raise TApplicationException(TApplicationException.MISSING_RESULT, "userHasAccess failed: unknown result")


class Processor(airavata.base.api.BaseAPI.Processor, Iface, TProcessor):
    def __init__(self, handler):
        airavata.base.api.BaseAPI.Processor.__init__(self, handler)
        self._processMap["createDomain"] = Processor.process_createDomain
        self._processMap["updateDomain"] = Processor.process_updateDomain
        self._processMap["isDomainExists"] = Processor.process_isDomainExists
        self._processMap["deleteDomain"] = Processor.process_deleteDomain
        self._processMap["getDomain"] = Processor.process_getDomain
        self._processMap["getDomains"] = Processor.process_getDomains
        self._processMap["createUser"] = Processor.process_createUser
        self._processMap["updatedUser"] = Processor.process_updatedUser
        self._processMap["isUserExists"] = Processor.process_isUserExists
        self._processMap["deleteUser"] = Processor.process_deleteUser
        self._processMap["getUser"] = Processor.process_getUser
        self._processMap["getUsers"] = Processor.process_getUsers
        self._processMap["createGroup"] = Processor.process_createGroup
        self._processMap["updateGroup"] = Processor.process_updateGroup
        self._processMap["isGroupExists"] = Processor.process_isGroupExists
        self._processMap["deleteGroup"] = Processor.process_deleteGroup
        self._processMap["getGroup"] = Processor.process_getGroup
        self._processMap["getGroups"] = Processor.process_getGroups
        self._processMap["addUsersToGroup"] = Processor.process_addUsersToGroup
        self._processMap["removeUsersFromGroup"] = Processor.process_removeUsersFromGroup
        self._processMap["transferGroupOwnership"] = Processor.process_transferGroupOwnership
        self._processMap["addGroupAdmins"] = Processor.process_addGroupAdmins
        self._processMap["removeGroupAdmins"] = Processor.process_removeGroupAdmins
        self._processMap["hasAdminAccess"] = Processor.process_hasAdminAccess
        self._processMap["hasOwnerAccess"] = Processor.process_hasOwnerAccess
        self._processMap["getGroupMembersOfTypeUser"] = Processor.process_getGroupMembersOfTypeUser
        self._processMap["getGroupMembersOfTypeGroup"] = Processor.process_getGroupMembersOfTypeGroup
        self._processMap["addChildGroupsToParentGroup"] = Processor.process_addChildGroupsToParentGroup
        self._processMap["removeChildGroupFromParentGroup"] = Processor.process_removeChildGroupFromParentGroup
        self._processMap["getAllMemberGroupsForUser"] = Processor.process_getAllMemberGroupsForUser
        self._processMap["createEntityType"] = Processor.process_createEntityType
        self._processMap["updateEntityType"] = Processor.process_updateEntityType
        self._processMap["isEntityTypeExists"] = Processor.process_isEntityTypeExists
        self._processMap["deleteEntityType"] = Processor.process_deleteEntityType
        self._processMap["getEntityType"] = Processor.process_getEntityType
        self._processMap["getEntityTypes"] = Processor.process_getEntityTypes
        self._processMap["createEntity"] = Processor.process_createEntity
        self._processMap["updateEntity"] = Processor.process_updateEntity
        self._processMap["isEntityExists"] = Processor.process_isEntityExists
        self._processMap["deleteEntity"] = Processor.process_deleteEntity
        self._processMap["getEntity"] = Processor.process_getEntity
        self._processMap["searchEntities"] = Processor.process_searchEntities
        self._processMap["getListOfSharedUsers"] = Processor.process_getListOfSharedUsers
        self._processMap["getListOfDirectlySharedUsers"] = Processor.process_getListOfDirectlySharedUsers
        self._processMap["getListOfSharedGroups"] = Processor.process_getListOfSharedGroups
        self._processMap["getListOfDirectlySharedGroups"] = Processor.process_getListOfDirectlySharedGroups
        self._processMap["createPermissionType"] = Processor.process_createPermissionType
        self._processMap["updatePermissionType"] = Processor.process_updatePermissionType
        self._processMap["isPermissionExists"] = Processor.process_isPermissionExists
        self._processMap["deletePermissionType"] = Processor.process_deletePermissionType
        self._processMap["getPermissionType"] = Processor.process_getPermissionType
        self._processMap["getPermissionTypes"] = Processor.process_getPermissionTypes
        self._processMap["shareEntityWithUsers"] = Processor.process_shareEntityWithUsers
        self._processMap["revokeEntitySharingFromUsers"] = Processor.process_revokeEntitySharingFromUsers
        self._processMap["shareEntityWithGroups"] = Processor.process_shareEntityWithGroups
        self._processMap["revokeEntitySharingFromGroups"] = Processor.process_revokeEntitySharingFromGroups
        self._processMap["userHasAccess"] = Processor.process_userHasAccess
        self._on_message_begin = None

    def on_message_begin(self, func):
        self._on_message_begin = func

    def process(self, iprot, oprot):
        (name, type, seqid) = iprot.readMessageBegin()
        if self._on_message_begin:
            self._on_message_begin(name, type, seqid)
        if name not in self._processMap:
            iprot.skip(TType.STRUCT)
            iprot.readMessageEnd()
            x = TApplicationException(TApplicationException.UNKNOWN_METHOD, 'Unknown function %s' % (name))
            oprot.writeMessageBegin(name, TMessageType.EXCEPTION, seqid)
            x.write(oprot)
            oprot.writeMessageEnd()
            oprot.trans.flush()
            return
        else:
            self._processMap[name](self, seqid, iprot, oprot)
        return True

    def process_createDomain(self, seqid, iprot, oprot):
        args = createDomain_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = createDomain_result()
        try:
            result.success = self._handler.createDomain(args.domain)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except airavata.model.sharing.ttypes.SharingRegistryException as sre:
            msg_type = TMessageType.REPLY
            result.sre = sre
        except airavata.model.sharing.ttypes.DuplicateEntryException as dee:
            msg_type = TMessageType.REPLY
            result.dee = dee
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("createDomain", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_updateDomain(self, seqid, iprot, oprot):
        args = updateDomain_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = updateDomain_result()
        try:
            result.success = self._handler.updateDomain(args.domain)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except airavata.model.sharing.ttypes.SharingRegistryException as sre:
            msg_type = TMessageType.REPLY
            result.sre = sre
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("updateDomain", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_isDomainExists(self, seqid, iprot, oprot):
        args = isDomainExists_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = isDomainExists_result()
        try:
            result.success = self._handler.isDomainExists(args.domainId)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except airavata.model.sharing.ttypes.SharingRegistryException as sre:
            msg_type = TMessageType.REPLY
            result.sre = sre
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("isDomainExists", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_deleteDomain(self, seqid, iprot, oprot):
        args = deleteDomain_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = deleteDomain_result()
        try:
            result.success = self._handler.deleteDomain(args.domainId)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except airavata.model.sharing.ttypes.SharingRegistryException as sre:
            msg_type = TMessageType.REPLY
            result.sre = sre
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("deleteDomain", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getDomain(self, seqid, iprot, oprot):
        args = getDomain_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getDomain_result()
        try:
            result.success = self._handler.getDomain(args.domainId)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except airavata.model.sharing.ttypes.SharingRegistryException as sre:
            msg_type = TMessageType.REPLY
            result.sre = sre
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("getDomain", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getDomains(self, seqid, iprot, oprot):
        args = getDomains_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getDomains_result()
        try:
            result.success = self._handler.getDomains(args.offset, args.limit)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except airavata.model.sharing.ttypes.SharingRegistryException as sre:
            msg_type = TMessageType.REPLY
            result.sre = sre
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("getDomains", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_createUser(self, seqid, iprot, oprot):
        args = createUser_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = createUser_result()
        try:
            result.success = self._handler.createUser(args.user)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except airavata.model.sharing.ttypes.SharingRegistryException as sre:
            msg_type = TMessageType.REPLY
            result.sre = sre
        except airavata.model.sharing.ttypes.DuplicateEntryException as dee:
            msg_type = TMessageType.REPLY
            result.dee = dee
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("createUser", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_updatedUser(self, seqid, iprot, oprot):
        args = updatedUser_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = updatedUser_result()
        try:
            result.success = self._handler.updatedUser(args.user)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except airavata.model.sharing.ttypes.SharingRegistryException as sre:
            msg_type = TMessageType.REPLY
            result.sre = sre
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("updatedUser", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_isUserExists(self, seqid, iprot, oprot):
        args = isUserExists_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = isUserExists_result()
        try:
            result.success = self._handler.isUserExists(args.domainId, args.userId)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except airavata.model.sharing.ttypes.SharingRegistryException as sre:
            msg_type = TMessageType.REPLY
            result.sre = sre
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("isUserExists", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_deleteUser(self, seqid, iprot, oprot):
        args = deleteUser_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = deleteUser_result()
        try:
            result.success = self._handler.deleteUser(args.domainId, args.userId)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except airavata.model.sharing.ttypes.SharingRegistryException as sre:
            msg_type = TMessageType.REPLY
            result.sre = sre
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("deleteUser", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getUser(self, seqid, iprot, oprot):
        args = getUser_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getUser_result()
        try:
            result.success = self._handler.getUser(args.domainId, args.userId)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except airavata.model.sharing.ttypes.SharingRegistryException as sre:
            msg_type = TMessageType.REPLY
            result.sre = sre
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("getUser", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getUsers(self, seqid, iprot, oprot):
        args = getUsers_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getUsers_result()
        try:
            result.success = self._handler.getUsers(args.domainId, args.offset, args.limit)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except airavata.model.sharing.ttypes.SharingRegistryException as sre:
            msg_type = TMessageType.REPLY
            result.sre = sre
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("getUsers", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_createGroup(self, seqid, iprot, oprot):
        args = createGroup_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = createGroup_result()
        try:
            result.success = self._handler.createGroup(args.group)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except airavata.model.sharing.ttypes.SharingRegistryException as sre:
            msg_type = TMessageType.REPLY
            result.sre = sre
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("createGroup", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_updateGroup(self, seqid, iprot, oprot):
        args = updateGroup_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = updateGroup_result()
        try:
            result.success = self._handler.updateGroup(args.group)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except airavata.model.sharing.ttypes.SharingRegistryException as sre:
            msg_type = TMessageType.REPLY
            result.sre = sre
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("updateGroup", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_isGroupExists(self, seqid, iprot, oprot):
        args = isGroupExists_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = isGroupExists_result()
        try:
            result.success = self._handler.isGroupExists(args.domainId, args.groupId)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except airavata.model.sharing.ttypes.SharingRegistryException as sre:
            msg_type = TMessageType.REPLY
            result.sre = sre
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("isGroupExists", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_deleteGroup(self, seqid, iprot, oprot):
        args = deleteGroup_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = deleteGroup_result()
        try:
            result.success = self._handler.deleteGroup(args.domainId, args.groupId)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except airavata.model.sharing.ttypes.SharingRegistryException as sre:
            msg_type = TMessageType.REPLY
            result.sre = sre
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("deleteGroup", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getGroup(self, seqid, iprot, oprot):
        args = getGroup_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getGroup_result()
        try:
            result.success = self._handler.getGroup(args.domainId, args.groupId)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except airavata.model.sharing.ttypes.SharingRegistryException as sre:
            msg_type = TMessageType.REPLY
            result.sre = sre
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("getGroup", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getGroups(self, seqid, iprot, oprot):
        args = getGroups_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getGroups_result()
        try:
            result.success = self._handler.getGroups(args.domainId, args.offset, args.limit)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("getGroups", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_addUsersToGroup(self, seqid, iprot, oprot):
        args = addUsersToGroup_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = addUsersToGroup_result()
        try:
            result.success = self._handler.addUsersToGroup(args.domainId, args.userIds, args.groupId)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except airavata.model.sharing.ttypes.SharingRegistryException as sre:
            msg_type = TMessageType.REPLY
            result.sre = sre
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("addUsersToGroup", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_removeUsersFromGroup(self, seqid, iprot, oprot):
        args = removeUsersFromGroup_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = removeUsersFromGroup_result()
        try:
            result.success = self._handler.removeUsersFromGroup(args.domainId, args.userIds, args.groupId)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except airavata.model.sharing.ttypes.SharingRegistryException as sre:
            msg_type = TMessageType.REPLY
            result.sre = sre
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("removeUsersFromGroup", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_transferGroupOwnership(self, seqid, iprot, oprot):
        args = transferGroupOwnership_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = transferGroupOwnership_result()
        try:
            result.success = self._handler.transferGroupOwnership(args.domainId, args.groupId, args.newOwnerId)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except airavata.model.sharing.ttypes.SharingRegistryException as sre:
            msg_type = TMessageType.REPLY
            result.sre = sre
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("transferGroupOwnership", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_addGroupAdmins(self, seqid, iprot, oprot):
        args = addGroupAdmins_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = addGroupAdmins_result()
        try:
            result.success = self._handler.addGroupAdmins(args.domainId, args.groupId, args.adminIds)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except airavata.model.sharing.ttypes.SharingRegistryException as sre:
            msg_type = TMessageType.REPLY
            result.sre = sre
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("addGroupAdmins", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_removeGroupAdmins(self, seqid, iprot, oprot):
        args = removeGroupAdmins_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = removeGroupAdmins_result()
        try:
            result.success = self._handler.removeGroupAdmins(args.domainId, args.groupId, args.adminIds)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except airavata.model.sharing.ttypes.SharingRegistryException as sre:
            msg_type = TMessageType.REPLY
            result.sre = sre
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("removeGroupAdmins", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_hasAdminAccess(self, seqid, iprot, oprot):
        args = hasAdminAccess_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = hasAdminAccess_result()
        try:
            result.success = self._handler.hasAdminAccess(args.domainId, args.groupId, args.adminId)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except airavata.model.sharing.ttypes.SharingRegistryException as sre:
            msg_type = TMessageType.REPLY
            result.sre = sre
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("hasAdminAccess", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_hasOwnerAccess(self, seqid, iprot, oprot):
        args = hasOwnerAccess_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = hasOwnerAccess_result()
        try:
            result.success = self._handler.hasOwnerAccess(args.domainId, args.groupId, args.ownerId)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except airavata.model.sharing.ttypes.SharingRegistryException as sre:
            msg_type = TMessageType.REPLY
            result.sre = sre
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("hasOwnerAccess", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getGroupMembersOfTypeUser(self, seqid, iprot, oprot):
        args = getGroupMembersOfTypeUser_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getGroupMembersOfTypeUser_result()
        try:
            result.success = self._handler.getGroupMembersOfTypeUser(args.domainId, args.groupId, args.offset, args.limit)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except airavata.model.sharing.ttypes.SharingRegistryException as sre:
            msg_type = TMessageType.REPLY
            result.sre = sre
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("getGroupMembersOfTypeUser", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getGroupMembersOfTypeGroup(self, seqid, iprot, oprot):
        args = getGroupMembersOfTypeGroup_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getGroupMembersOfTypeGroup_result()
        try:
            result.success = self._handler.getGroupMembersOfTypeGroup(args.domainId, args.groupId, args.offset, args.limit)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except airavata.model.sharing.ttypes.SharingRegistryException as sre:
            msg_type = TMessageType.REPLY
            result.sre = sre
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("getGroupMembersOfTypeGroup", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_addChildGroupsToParentGroup(self, seqid, iprot, oprot):
        args = addChildGroupsToParentGroup_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = addChildGroupsToParentGroup_result()
        try:
            result.success = self._handler.addChildGroupsToParentGroup(args.domainId, args.childIds, args.groupId)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except airavata.model.sharing.ttypes.SharingRegistryException as sre:
            msg_type = TMessageType.REPLY
            result.sre = sre
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("addChildGroupsToParentGroup", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_removeChildGroupFromParentGroup(self, seqid, iprot, oprot):
        args = removeChildGroupFromParentGroup_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = removeChildGroupFromParentGroup_result()
        try:
            result.success = self._handler.removeChildGroupFromParentGroup(args.domainId, args.childId, args.groupId)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except airavata.model.sharing.ttypes.SharingRegistryException as sre:
            msg_type = TMessageType.REPLY
            result.sre = sre
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("removeChildGroupFromParentGroup", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getAllMemberGroupsForUser(self, seqid, iprot, oprot):
        args = getAllMemberGroupsForUser_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getAllMemberGroupsForUser_result()
        try:
            result.success = self._handler.getAllMemberGroupsForUser(args.domainId, args.userId)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except airavata.model.sharing.ttypes.SharingRegistryException as sre:
            msg_type = TMessageType.REPLY
            result.sre = sre
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("getAllMemberGroupsForUser", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_createEntityType(self, seqid, iprot, oprot):
        args = createEntityType_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = createEntityType_result()
        try:
            result.success = self._handler.createEntityType(args.entityType)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except airavata.model.sharing.ttypes.SharingRegistryException as sre:
            msg_type = TMessageType.REPLY
            result.sre = sre
        except airavata.model.sharing.ttypes.DuplicateEntryException as dee:
            msg_type = TMessageType.REPLY
            result.dee = dee
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("createEntityType", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_updateEntityType(self, seqid, iprot, oprot):
        args = updateEntityType_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = updateEntityType_result()
        try:
            result.success = self._handler.updateEntityType(args.entityType)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except airavata.model.sharing.ttypes.SharingRegistryException as sre:
            msg_type = TMessageType.REPLY
            result.sre = sre
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("updateEntityType", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_isEntityTypeExists(self, seqid, iprot, oprot):
        args = isEntityTypeExists_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = isEntityTypeExists_result()
        try:
            result.success = self._handler.isEntityTypeExists(args.domainId, args.entityTypeId)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except airavata.model.sharing.ttypes.SharingRegistryException as sre:
            msg_type = TMessageType.REPLY
            result.sre = sre
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("isEntityTypeExists", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_deleteEntityType(self, seqid, iprot, oprot):
        args = deleteEntityType_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = deleteEntityType_result()
        try:
            result.success = self._handler.deleteEntityType(args.domainId, args.entityTypeId)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except airavata.model.sharing.ttypes.SharingRegistryException as sre:
            msg_type = TMessageType.REPLY
            result.sre = sre
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("deleteEntityType", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getEntityType(self, seqid, iprot, oprot):
        args = getEntityType_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getEntityType_result()
        try:
            result.success = self._handler.getEntityType(args.domainId, args.entityTypeId)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except airavata.model.sharing.ttypes.SharingRegistryException as sre:
            msg_type = TMessageType.REPLY
            result.sre = sre
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("getEntityType", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getEntityTypes(self, seqid, iprot, oprot):
        args = getEntityTypes_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getEntityTypes_result()
        try:
            result.success = self._handler.getEntityTypes(args.domainId, args.offset, args.limit)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except airavata.model.sharing.ttypes.SharingRegistryException as sre:
            msg_type = TMessageType.REPLY
            result.sre = sre
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("getEntityTypes", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_createEntity(self, seqid, iprot, oprot):
        args = createEntity_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = createEntity_result()
        try:
            result.success = self._handler.createEntity(args.entity)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except airavata.model.sharing.ttypes.SharingRegistryException as sre:
            msg_type = TMessageType.REPLY
            result.sre = sre
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("createEntity", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_updateEntity(self, seqid, iprot, oprot):
        args = updateEntity_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = updateEntity_result()
        try:
            result.success = self._handler.updateEntity(args.entity)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except airavata.model.sharing.ttypes.SharingRegistryException as sre:
            msg_type = TMessageType.REPLY
            result.sre = sre
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("updateEntity", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_isEntityExists(self, seqid, iprot, oprot):
        args = isEntityExists_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = isEntityExists_result()
        try:
            result.success = self._handler.isEntityExists(args.domainId, args.entityId)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except airavata.model.sharing.ttypes.SharingRegistryException as sre:
            msg_type = TMessageType.REPLY
            result.sre = sre
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("isEntityExists", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_deleteEntity(self, seqid, iprot, oprot):
        args = deleteEntity_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = deleteEntity_result()
        try:
            result.success = self._handler.deleteEntity(args.domainId, args.entityId)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except airavata.model.sharing.ttypes.SharingRegistryException as sre:
            msg_type = TMessageType.REPLY
            result.sre = sre
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("deleteEntity", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getEntity(self, seqid, iprot, oprot):
        args = getEntity_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getEntity_result()
        try:
            result.success = self._handler.getEntity(args.domainId, args.entityId)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except airavata.model.sharing.ttypes.SharingRegistryException as sre:
            msg_type = TMessageType.REPLY
            result.sre = sre
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("getEntity", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_searchEntities(self, seqid, iprot, oprot):
        args = searchEntities_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = searchEntities_result()
        try:
            result.success = self._handler.searchEntities(args.domainId, args.userId, args.filters, args.offset, args.limit)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except airavata.model.sharing.ttypes.SharingRegistryException as sre:
            msg_type = TMessageType.REPLY
            result.sre = sre
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("searchEntities", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getListOfSharedUsers(self, seqid, iprot, oprot):
        args = getListOfSharedUsers_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getListOfSharedUsers_result()
        try:
            result.success = self._handler.getListOfSharedUsers(args.domainId, args.entityId, args.permissionTypeId)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except airavata.model.sharing.ttypes.SharingRegistryException as sre:
            msg_type = TMessageType.REPLY
            result.sre = sre
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("getListOfSharedUsers", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getListOfDirectlySharedUsers(self, seqid, iprot, oprot):
        args = getListOfDirectlySharedUsers_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getListOfDirectlySharedUsers_result()
        try:
            result.success = self._handler.getListOfDirectlySharedUsers(args.domainId, args.entityId, args.permissionTypeId)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except airavata.model.sharing.ttypes.SharingRegistryException as sre:
            msg_type = TMessageType.REPLY
            result.sre = sre
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("getListOfDirectlySharedUsers", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getListOfSharedGroups(self, seqid, iprot, oprot):
        args = getListOfSharedGroups_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getListOfSharedGroups_result()
        try:
            result.success = self._handler.getListOfSharedGroups(args.domainId, args.entityId, args.permissionTypeId)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except airavata.model.sharing.ttypes.SharingRegistryException as sre:
            msg_type = TMessageType.REPLY
            result.sre = sre
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("getListOfSharedGroups", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getListOfDirectlySharedGroups(self, seqid, iprot, oprot):
        args = getListOfDirectlySharedGroups_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getListOfDirectlySharedGroups_result()
        try:
            result.success = self._handler.getListOfDirectlySharedGroups(args.domainId, args.entityId, args.permissionTypeId)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except airavata.model.sharing.ttypes.SharingRegistryException as sre:
            msg_type = TMessageType.REPLY
            result.sre = sre
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("getListOfDirectlySharedGroups", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_createPermissionType(self, seqid, iprot, oprot):
        args = createPermissionType_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = createPermissionType_result()
        try:
            result.success = self._handler.createPermissionType(args.permissionType)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except airavata.model.sharing.ttypes.SharingRegistryException as sre:
            msg_type = TMessageType.REPLY
            result.sre = sre
        except airavata.model.sharing.ttypes.DuplicateEntryException as dee:
            msg_type = TMessageType.REPLY
            result.dee = dee
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("createPermissionType", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_updatePermissionType(self, seqid, iprot, oprot):
        args = updatePermissionType_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = updatePermissionType_result()
        try:
            result.success = self._handler.updatePermissionType(args.permissionType)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except airavata.model.sharing.ttypes.SharingRegistryException as sre:
            msg_type = TMessageType.REPLY
            result.sre = sre
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("updatePermissionType", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_isPermissionExists(self, seqid, iprot, oprot):
        args = isPermissionExists_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = isPermissionExists_result()
        try:
            result.success = self._handler.isPermissionExists(args.dimainId, args.permissionId)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except airavata.model.sharing.ttypes.SharingRegistryException as sre:
            msg_type = TMessageType.REPLY
            result.sre = sre
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("isPermissionExists", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_deletePermissionType(self, seqid, iprot, oprot):
        args = deletePermissionType_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = deletePermissionType_result()
        try:
            result.success = self._handler.deletePermissionType(args.domainId, args.permissionTypeId)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except airavata.model.sharing.ttypes.SharingRegistryException as sre:
            msg_type = TMessageType.REPLY
            result.sre = sre
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("deletePermissionType", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getPermissionType(self, seqid, iprot, oprot):
        args = getPermissionType_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getPermissionType_result()
        try:
            result.success = self._handler.getPermissionType(args.domainId, args.permissionTypeId)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except airavata.model.sharing.ttypes.SharingRegistryException as sre:
            msg_type = TMessageType.REPLY
            result.sre = sre
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("getPermissionType", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getPermissionTypes(self, seqid, iprot, oprot):
        args = getPermissionTypes_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getPermissionTypes_result()
        try:
            result.success = self._handler.getPermissionTypes(args.domainId, args.offset, args.limit)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except airavata.model.sharing.ttypes.SharingRegistryException as sre:
            msg_type = TMessageType.REPLY
            result.sre = sre
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("getPermissionTypes", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_shareEntityWithUsers(self, seqid, iprot, oprot):
        args = shareEntityWithUsers_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = shareEntityWithUsers_result()
        try:
            result.success = self._handler.shareEntityWithUsers(args.domainId, args.entityId, args.userList, args.permissionTypeId, args.cascadePermission)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except airavata.model.sharing.ttypes.SharingRegistryException as sre:
            msg_type = TMessageType.REPLY
            result.sre = sre
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("shareEntityWithUsers", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_revokeEntitySharingFromUsers(self, seqid, iprot, oprot):
        args = revokeEntitySharingFromUsers_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = revokeEntitySharingFromUsers_result()
        try:
            result.success = self._handler.revokeEntitySharingFromUsers(args.domainId, args.entityId, args.userList, args.permissionTypeId)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except airavata.model.sharing.ttypes.SharingRegistryException as sre:
            msg_type = TMessageType.REPLY
            result.sre = sre
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("revokeEntitySharingFromUsers", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_shareEntityWithGroups(self, seqid, iprot, oprot):
        args = shareEntityWithGroups_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = shareEntityWithGroups_result()
        try:
            result.success = self._handler.shareEntityWithGroups(args.domainId, args.entityId, args.groupList, args.permissionTypeId, args.cascadePermission)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except airavata.model.sharing.ttypes.SharingRegistryException as sre:
            msg_type = TMessageType.REPLY
            result.sre = sre
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("shareEntityWithGroups", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_revokeEntitySharingFromGroups(self, seqid, iprot, oprot):
        args = revokeEntitySharingFromGroups_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = revokeEntitySharingFromGroups_result()
        try:
            result.success = self._handler.revokeEntitySharingFromGroups(args.domainId, args.entityId, args.groupList, args.permissionTypeId)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except airavata.model.sharing.ttypes.SharingRegistryException as sre:
            msg_type = TMessageType.REPLY
            result.sre = sre
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("revokeEntitySharingFromGroups", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_userHasAccess(self, seqid, iprot, oprot):
        args = userHasAccess_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = userHasAccess_result()
        try:
            result.success = self._handler.userHasAccess(args.domainId, args.userId, args.entityId, args.permissionTypeId)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except airavata.model.sharing.ttypes.SharingRegistryException as sre:
            msg_type = TMessageType.REPLY
            result.sre = sre
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("userHasAccess", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

# HELPER FUNCTIONS AND STRUCTURES


class createDomain_args(object):
    """
    Attributes:
     - domain

    """
    thrift_spec: typing.Any = None


    def __init__(self, domain: airavata.model.sharing.ttypes.Domain = None,):
        self.domain: airavata.model.sharing.ttypes.Domain = domain

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.domain = airavata.model.sharing.ttypes.Domain()
                    self.domain.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('createDomain_args')
        if self.domain is not None:
            oprot.writeFieldBegin('domain', TType.STRUCT, 1)
            self.domain.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.domain is None:
            raise TProtocolException(message='Required field domain is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(createDomain_args)
createDomain_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'domain', [airavata.model.sharing.ttypes.Domain, None], None, ),  # 1
)


class createDomain_result(object):
    """
    Attributes:
     - success
     - sre
     - dee

    """
    thrift_spec: typing.Any = None


    def __init__(self, success: typing.Optional[str] = None, sre: typing.Optional[airavata.model.sharing.ttypes.SharingRegistryException] = None, dee: typing.Optional[airavata.model.sharing.ttypes.DuplicateEntryException] = None,):
        self.success: typing.Optional[str] = success
        self.sre: typing.Optional[airavata.model.sharing.ttypes.SharingRegistryException] = sre
        self.dee: typing.Optional[airavata.model.sharing.ttypes.DuplicateEntryException] = dee

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRING:
                    self.success = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.sre = airavata.model.sharing.ttypes.SharingRegistryException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.dee = airavata.model.sharing.ttypes.DuplicateEntryException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('createDomain_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRING, 0)
            oprot.writeString(self.success.encode('utf-8') if sys.version_info[0] == 2 else self.success)
            oprot.writeFieldEnd()
        if self.sre is not None:
            oprot.writeFieldBegin('sre', TType.STRUCT, 1)
            self.sre.write(oprot)
            oprot.writeFieldEnd()
        if self.dee is not None:
            oprot.writeFieldBegin('dee', TType.STRUCT, 2)
            self.dee.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(createDomain_result)
createDomain_result.thrift_spec = (
    (0, TType.STRING, 'success', 'UTF8', None, ),  # 0
    (1, TType.STRUCT, 'sre', [airavata.model.sharing.ttypes.SharingRegistryException, None], None, ),  # 1
    (2, TType.STRUCT, 'dee', [airavata.model.sharing.ttypes.DuplicateEntryException, None], None, ),  # 2
)


class updateDomain_args(object):
    """
    Attributes:
     - domain

    """
    thrift_spec: typing.Any = None


    def __init__(self, domain: airavata.model.sharing.ttypes.Domain = None,):
        self.domain: airavata.model.sharing.ttypes.Domain = domain

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.domain = airavata.model.sharing.ttypes.Domain()
                    self.domain.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('updateDomain_args')
        if self.domain is not None:
            oprot.writeFieldBegin('domain', TType.STRUCT, 1)
            self.domain.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.domain is None:
            raise TProtocolException(message='Required field domain is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(updateDomain_args)
updateDomain_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'domain', [airavata.model.sharing.ttypes.Domain, None], None, ),  # 1
)


class updateDomain_result(object):
    """
    Attributes:
     - success
     - sre

    """
    thrift_spec: typing.Any = None


    def __init__(self, success: typing.Optional[bool] = None, sre: typing.Optional[airavata.model.sharing.ttypes.SharingRegistryException] = None,):
        self.success: typing.Optional[bool] = success
        self.sre: typing.Optional[airavata.model.sharing.ttypes.SharingRegistryException] = sre

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.BOOL:
                    self.success = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.sre = airavata.model.sharing.ttypes.SharingRegistryException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('updateDomain_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.BOOL, 0)
            oprot.writeBool(self.success)
            oprot.writeFieldEnd()
        if self.sre is not None:
            oprot.writeFieldBegin('sre', TType.STRUCT, 1)
            self.sre.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(updateDomain_result)
updateDomain_result.thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'sre', [airavata.model.sharing.ttypes.SharingRegistryException, None], None, ),  # 1
)


class isDomainExists_args(object):
    """
    Attributes:
     - domainId

    """
    thrift_spec: typing.Any = None


    def __init__(self, domainId: str = None,):
        self.domainId: str = domainId

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.domainId = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('isDomainExists_args')
        if self.domainId is not None:
            oprot.writeFieldBegin('domainId', TType.STRING, 1)
            oprot.writeString(self.domainId.encode('utf-8') if sys.version_info[0] == 2 else self.domainId)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.domainId is None:
            raise TProtocolException(message='Required field domainId is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(isDomainExists_args)
isDomainExists_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'domainId', 'UTF8', None, ),  # 1
)


class isDomainExists_result(object):
    """
    Attributes:
     - success
     - sre

    """
    thrift_spec: typing.Any = None


    def __init__(self, success: typing.Optional[bool] = None, sre: typing.Optional[airavata.model.sharing.ttypes.SharingRegistryException] = None,):
        self.success: typing.Optional[bool] = success
        self.sre: typing.Optional[airavata.model.sharing.ttypes.SharingRegistryException] = sre

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.BOOL:
                    self.success = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.sre = airavata.model.sharing.ttypes.SharingRegistryException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('isDomainExists_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.BOOL, 0)
            oprot.writeBool(self.success)
            oprot.writeFieldEnd()
        if self.sre is not None:
            oprot.writeFieldBegin('sre', TType.STRUCT, 1)
            self.sre.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(isDomainExists_result)
isDomainExists_result.thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'sre', [airavata.model.sharing.ttypes.SharingRegistryException, None], None, ),  # 1
)


class deleteDomain_args(object):
    """
    Attributes:
     - domainId

    """
    thrift_spec: typing.Any = None


    def __init__(self, domainId: str = None,):
        self.domainId: str = domainId

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.domainId = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('deleteDomain_args')
        if self.domainId is not None:
            oprot.writeFieldBegin('domainId', TType.STRING, 1)
            oprot.writeString(self.domainId.encode('utf-8') if sys.version_info[0] == 2 else self.domainId)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.domainId is None:
            raise TProtocolException(message='Required field domainId is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(deleteDomain_args)
deleteDomain_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'domainId', 'UTF8', None, ),  # 1
)


class deleteDomain_result(object):
    """
    Attributes:
     - success
     - sre

    """
    thrift_spec: typing.Any = None


    def __init__(self, success: typing.Optional[bool] = None, sre: typing.Optional[airavata.model.sharing.ttypes.SharingRegistryException] = None,):
        self.success: typing.Optional[bool] = success
        self.sre: typing.Optional[airavata.model.sharing.ttypes.SharingRegistryException] = sre

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.BOOL:
                    self.success = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.sre = airavata.model.sharing.ttypes.SharingRegistryException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('deleteDomain_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.BOOL, 0)
            oprot.writeBool(self.success)
            oprot.writeFieldEnd()
        if self.sre is not None:
            oprot.writeFieldBegin('sre', TType.STRUCT, 1)
            self.sre.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(deleteDomain_result)
deleteDomain_result.thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'sre', [airavata.model.sharing.ttypes.SharingRegistryException, None], None, ),  # 1
)


class getDomain_args(object):
    """
    Attributes:
     - domainId

    """
    thrift_spec: typing.Any = None


    def __init__(self, domainId: str = None,):
        self.domainId: str = domainId

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.domainId = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getDomain_args')
        if self.domainId is not None:
            oprot.writeFieldBegin('domainId', TType.STRING, 1)
            oprot.writeString(self.domainId.encode('utf-8') if sys.version_info[0] == 2 else self.domainId)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.domainId is None:
            raise TProtocolException(message='Required field domainId is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getDomain_args)
getDomain_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'domainId', 'UTF8', None, ),  # 1
)


class getDomain_result(object):
    """
    Attributes:
     - success
     - sre

    """
    thrift_spec: typing.Any = None


    def __init__(self, success: typing.Optional[airavata.model.sharing.ttypes.Domain] = None, sre: typing.Optional[airavata.model.sharing.ttypes.SharingRegistryException] = None,):
        self.success: typing.Optional[airavata.model.sharing.ttypes.Domain] = success
        self.sre: typing.Optional[airavata.model.sharing.ttypes.SharingRegistryException] = sre

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = airavata.model.sharing.ttypes.Domain()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.sre = airavata.model.sharing.ttypes.SharingRegistryException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getDomain_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.sre is not None:
            oprot.writeFieldBegin('sre', TType.STRUCT, 1)
            self.sre.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getDomain_result)
getDomain_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [airavata.model.sharing.ttypes.Domain, None], None, ),  # 0
    (1, TType.STRUCT, 'sre', [airavata.model.sharing.ttypes.SharingRegistryException, None], None, ),  # 1
)


class getDomains_args(object):
    """
    Attributes:
     - offset
     - limit

    """
    thrift_spec: typing.Any = None


    def __init__(self, offset: int = None, limit: int = None,):
        self.offset: int = offset
        self.limit: int = limit

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.offset = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.limit = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getDomains_args')
        if self.offset is not None:
            oprot.writeFieldBegin('offset', TType.I32, 1)
            oprot.writeI32(self.offset)
            oprot.writeFieldEnd()
        if self.limit is not None:
            oprot.writeFieldBegin('limit', TType.I32, 2)
            oprot.writeI32(self.limit)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.offset is None:
            raise TProtocolException(message='Required field offset is unset!')
        if self.limit is None:
            raise TProtocolException(message='Required field limit is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getDomains_args)
getDomains_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'offset', None, None, ),  # 1
    (2, TType.I32, 'limit', None, None, ),  # 2
)


class getDomains_result(object):
    """
    Attributes:
     - success
     - sre

    """
    thrift_spec: typing.Any = None


    def __init__(self, success: typing.Optional[list[airavata.model.sharing.ttypes.Domain]] = None, sre: typing.Optional[airavata.model.sharing.ttypes.SharingRegistryException] = None,):
        self.success: typing.Optional[list[airavata.model.sharing.ttypes.Domain]] = success
        self.sre: typing.Optional[airavata.model.sharing.ttypes.SharingRegistryException] = sre

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype3, _size0) = iprot.readListBegin()
                    for _i4 in range(_size0):
                        _elem5 = airavata.model.sharing.ttypes.Domain()
                        _elem5.read(iprot)
                        self.success.append(_elem5)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.sre = airavata.model.sharing.ttypes.SharingRegistryException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getDomains_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter6 in self.success:
                iter6.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.sre is not None:
            oprot.writeFieldBegin('sre', TType.STRUCT, 1)
            self.sre.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getDomains_result)
getDomains_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT, [airavata.model.sharing.ttypes.Domain, None], False), None, ),  # 0
    (1, TType.STRUCT, 'sre', [airavata.model.sharing.ttypes.SharingRegistryException, None], None, ),  # 1
)


class createUser_args(object):
    """
    Attributes:
     - user

    """
    thrift_spec: typing.Any = None


    def __init__(self, user: airavata.model.sharing.ttypes.User = None,):
        self.user: airavata.model.sharing.ttypes.User = user

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.user = airavata.model.sharing.ttypes.User()
                    self.user.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('createUser_args')
        if self.user is not None:
            oprot.writeFieldBegin('user', TType.STRUCT, 1)
            self.user.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.user is None:
            raise TProtocolException(message='Required field user is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(createUser_args)
createUser_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'user', [airavata.model.sharing.ttypes.User, None], None, ),  # 1
)


class createUser_result(object):
    """
    Attributes:
     - success
     - sre
     - dee

    """
    thrift_spec: typing.Any = None


    def __init__(self, success: typing.Optional[str] = None, sre: typing.Optional[airavata.model.sharing.ttypes.SharingRegistryException] = None, dee: typing.Optional[airavata.model.sharing.ttypes.DuplicateEntryException] = None,):
        self.success: typing.Optional[str] = success
        self.sre: typing.Optional[airavata.model.sharing.ttypes.SharingRegistryException] = sre
        self.dee: typing.Optional[airavata.model.sharing.ttypes.DuplicateEntryException] = dee

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRING:
                    self.success = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.sre = airavata.model.sharing.ttypes.SharingRegistryException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.dee = airavata.model.sharing.ttypes.DuplicateEntryException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('createUser_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRING, 0)
            oprot.writeString(self.success.encode('utf-8') if sys.version_info[0] == 2 else self.success)
            oprot.writeFieldEnd()
        if self.sre is not None:
            oprot.writeFieldBegin('sre', TType.STRUCT, 1)
            self.sre.write(oprot)
            oprot.writeFieldEnd()
        if self.dee is not None:
            oprot.writeFieldBegin('dee', TType.STRUCT, 2)
            self.dee.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(createUser_result)
createUser_result.thrift_spec = (
    (0, TType.STRING, 'success', 'UTF8', None, ),  # 0
    (1, TType.STRUCT, 'sre', [airavata.model.sharing.ttypes.SharingRegistryException, None], None, ),  # 1
    (2, TType.STRUCT, 'dee', [airavata.model.sharing.ttypes.DuplicateEntryException, None], None, ),  # 2
)


class updatedUser_args(object):
    """
    Attributes:
     - user

    """
    thrift_spec: typing.Any = None


    def __init__(self, user: airavata.model.sharing.ttypes.User = None,):
        self.user: airavata.model.sharing.ttypes.User = user

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.user = airavata.model.sharing.ttypes.User()
                    self.user.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('updatedUser_args')
        if self.user is not None:
            oprot.writeFieldBegin('user', TType.STRUCT, 1)
            self.user.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.user is None:
            raise TProtocolException(message='Required field user is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(updatedUser_args)
updatedUser_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'user', [airavata.model.sharing.ttypes.User, None], None, ),  # 1
)


class updatedUser_result(object):
    """
    Attributes:
     - success
     - sre

    """
    thrift_spec: typing.Any = None


    def __init__(self, success: typing.Optional[bool] = None, sre: typing.Optional[airavata.model.sharing.ttypes.SharingRegistryException] = None,):
        self.success: typing.Optional[bool] = success
        self.sre: typing.Optional[airavata.model.sharing.ttypes.SharingRegistryException] = sre

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.BOOL:
                    self.success = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.sre = airavata.model.sharing.ttypes.SharingRegistryException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('updatedUser_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.BOOL, 0)
            oprot.writeBool(self.success)
            oprot.writeFieldEnd()
        if self.sre is not None:
            oprot.writeFieldBegin('sre', TType.STRUCT, 1)
            self.sre.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(updatedUser_result)
updatedUser_result.thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'sre', [airavata.model.sharing.ttypes.SharingRegistryException, None], None, ),  # 1
)


class isUserExists_args(object):
    """
    Attributes:
     - domainId
     - userId

    """
    thrift_spec: typing.Any = None


    def __init__(self, domainId: str = None, userId: str = None,):
        self.domainId: str = domainId
        self.userId: str = userId

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.domainId = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.userId = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('isUserExists_args')
        if self.domainId is not None:
            oprot.writeFieldBegin('domainId', TType.STRING, 1)
            oprot.writeString(self.domainId.encode('utf-8') if sys.version_info[0] == 2 else self.domainId)
            oprot.writeFieldEnd()
        if self.userId is not None:
            oprot.writeFieldBegin('userId', TType.STRING, 2)
            oprot.writeString(self.userId.encode('utf-8') if sys.version_info[0] == 2 else self.userId)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.domainId is None:
            raise TProtocolException(message='Required field domainId is unset!')
        if self.userId is None:
            raise TProtocolException(message='Required field userId is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(isUserExists_args)
isUserExists_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'domainId', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'userId', 'UTF8', None, ),  # 2
)


class isUserExists_result(object):
    """
    Attributes:
     - success
     - sre

    """
    thrift_spec: typing.Any = None


    def __init__(self, success: typing.Optional[bool] = None, sre: typing.Optional[airavata.model.sharing.ttypes.SharingRegistryException] = None,):
        self.success: typing.Optional[bool] = success
        self.sre: typing.Optional[airavata.model.sharing.ttypes.SharingRegistryException] = sre

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.BOOL:
                    self.success = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.sre = airavata.model.sharing.ttypes.SharingRegistryException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('isUserExists_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.BOOL, 0)
            oprot.writeBool(self.success)
            oprot.writeFieldEnd()
        if self.sre is not None:
            oprot.writeFieldBegin('sre', TType.STRUCT, 1)
            self.sre.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(isUserExists_result)
isUserExists_result.thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'sre', [airavata.model.sharing.ttypes.SharingRegistryException, None], None, ),  # 1
)


class deleteUser_args(object):
    """
    Attributes:
     - domainId
     - userId

    """
    thrift_spec: typing.Any = None


    def __init__(self, domainId: str = None, userId: str = None,):
        self.domainId: str = domainId
        self.userId: str = userId

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.domainId = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.userId = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('deleteUser_args')
        if self.domainId is not None:
            oprot.writeFieldBegin('domainId', TType.STRING, 1)
            oprot.writeString(self.domainId.encode('utf-8') if sys.version_info[0] == 2 else self.domainId)
            oprot.writeFieldEnd()
        if self.userId is not None:
            oprot.writeFieldBegin('userId', TType.STRING, 2)
            oprot.writeString(self.userId.encode('utf-8') if sys.version_info[0] == 2 else self.userId)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.domainId is None:
            raise TProtocolException(message='Required field domainId is unset!')
        if self.userId is None:
            raise TProtocolException(message='Required field userId is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(deleteUser_args)
deleteUser_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'domainId', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'userId', 'UTF8', None, ),  # 2
)


class deleteUser_result(object):
    """
    Attributes:
     - success
     - sre

    """
    thrift_spec: typing.Any = None


    def __init__(self, success: typing.Optional[bool] = None, sre: typing.Optional[airavata.model.sharing.ttypes.SharingRegistryException] = None,):
        self.success: typing.Optional[bool] = success
        self.sre: typing.Optional[airavata.model.sharing.ttypes.SharingRegistryException] = sre

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.BOOL:
                    self.success = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.sre = airavata.model.sharing.ttypes.SharingRegistryException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('deleteUser_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.BOOL, 0)
            oprot.writeBool(self.success)
            oprot.writeFieldEnd()
        if self.sre is not None:
            oprot.writeFieldBegin('sre', TType.STRUCT, 1)
            self.sre.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(deleteUser_result)
deleteUser_result.thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'sre', [airavata.model.sharing.ttypes.SharingRegistryException, None], None, ),  # 1
)


class getUser_args(object):
    """
    Attributes:
     - domainId
     - userId

    """
    thrift_spec: typing.Any = None


    def __init__(self, domainId: str = None, userId: str = None,):
        self.domainId: str = domainId
        self.userId: str = userId

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.domainId = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.userId = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getUser_args')
        if self.domainId is not None:
            oprot.writeFieldBegin('domainId', TType.STRING, 1)
            oprot.writeString(self.domainId.encode('utf-8') if sys.version_info[0] == 2 else self.domainId)
            oprot.writeFieldEnd()
        if self.userId is not None:
            oprot.writeFieldBegin('userId', TType.STRING, 2)
            oprot.writeString(self.userId.encode('utf-8') if sys.version_info[0] == 2 else self.userId)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.domainId is None:
            raise TProtocolException(message='Required field domainId is unset!')
        if self.userId is None:
            raise TProtocolException(message='Required field userId is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getUser_args)
getUser_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'domainId', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'userId', 'UTF8', None, ),  # 2
)


class getUser_result(object):
    """
    Attributes:
     - success
     - sre

    """
    thrift_spec: typing.Any = None


    def __init__(self, success: typing.Optional[airavata.model.sharing.ttypes.User] = None, sre: typing.Optional[airavata.model.sharing.ttypes.SharingRegistryException] = None,):
        self.success: typing.Optional[airavata.model.sharing.ttypes.User] = success
        self.sre: typing.Optional[airavata.model.sharing.ttypes.SharingRegistryException] = sre

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = airavata.model.sharing.ttypes.User()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.sre = airavata.model.sharing.ttypes.SharingRegistryException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getUser_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.sre is not None:
            oprot.writeFieldBegin('sre', TType.STRUCT, 1)
            self.sre.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getUser_result)
getUser_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [airavata.model.sharing.ttypes.User, None], None, ),  # 0
    (1, TType.STRUCT, 'sre', [airavata.model.sharing.ttypes.SharingRegistryException, None], None, ),  # 1
)


class getUsers_args(object):
    """
    Attributes:
     - domainId
     - offset
     - limit

    """
    thrift_spec: typing.Any = None


    def __init__(self, domainId: str = None, offset: int = None, limit: int = None,):
        self.domainId: str = domainId
        self.offset: int = offset
        self.limit: int = limit

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.domainId = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.offset = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.limit = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getUsers_args')
        if self.domainId is not None:
            oprot.writeFieldBegin('domainId', TType.STRING, 1)
            oprot.writeString(self.domainId.encode('utf-8') if sys.version_info[0] == 2 else self.domainId)
            oprot.writeFieldEnd()
        if self.offset is not None:
            oprot.writeFieldBegin('offset', TType.I32, 2)
            oprot.writeI32(self.offset)
            oprot.writeFieldEnd()
        if self.limit is not None:
            oprot.writeFieldBegin('limit', TType.I32, 3)
            oprot.writeI32(self.limit)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.domainId is None:
            raise TProtocolException(message='Required field domainId is unset!')
        if self.offset is None:
            raise TProtocolException(message='Required field offset is unset!')
        if self.limit is None:
            raise TProtocolException(message='Required field limit is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getUsers_args)
getUsers_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'domainId', 'UTF8', None, ),  # 1
    (2, TType.I32, 'offset', None, None, ),  # 2
    (3, TType.I32, 'limit', None, None, ),  # 3
)


class getUsers_result(object):
    """
    Attributes:
     - success
     - sre

    """
    thrift_spec: typing.Any = None


    def __init__(self, success: typing.Optional[list[airavata.model.sharing.ttypes.User]] = None, sre: typing.Optional[airavata.model.sharing.ttypes.SharingRegistryException] = None,):
        self.success: typing.Optional[list[airavata.model.sharing.ttypes.User]] = success
        self.sre: typing.Optional[airavata.model.sharing.ttypes.SharingRegistryException] = sre

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype10, _size7) = iprot.readListBegin()
                    for _i11 in range(_size7):
                        _elem12 = airavata.model.sharing.ttypes.User()
                        _elem12.read(iprot)
                        self.success.append(_elem12)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.sre = airavata.model.sharing.ttypes.SharingRegistryException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getUsers_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter13 in self.success:
                iter13.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.sre is not None:
            oprot.writeFieldBegin('sre', TType.STRUCT, 1)
            self.sre.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getUsers_result)
getUsers_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT, [airavata.model.sharing.ttypes.User, None], False), None, ),  # 0
    (1, TType.STRUCT, 'sre', [airavata.model.sharing.ttypes.SharingRegistryException, None], None, ),  # 1
)


class createGroup_args(object):
    """
    Attributes:
     - group

    """
    thrift_spec: typing.Any = None


    def __init__(self, group: airavata.model.sharing.ttypes.UserGroup = None,):
        self.group: airavata.model.sharing.ttypes.UserGroup = group

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.group = airavata.model.sharing.ttypes.UserGroup()
                    self.group.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('createGroup_args')
        if self.group is not None:
            oprot.writeFieldBegin('group', TType.STRUCT, 1)
            self.group.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.group is None:
            raise TProtocolException(message='Required field group is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(createGroup_args)
createGroup_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'group', [airavata.model.sharing.ttypes.UserGroup, None], None, ),  # 1
)


class createGroup_result(object):
    """
    Attributes:
     - success
     - sre

    """
    thrift_spec: typing.Any = None


    def __init__(self, success: typing.Optional[str] = None, sre: typing.Optional[airavata.model.sharing.ttypes.SharingRegistryException] = None,):
        self.success: typing.Optional[str] = success
        self.sre: typing.Optional[airavata.model.sharing.ttypes.SharingRegistryException] = sre

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRING:
                    self.success = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.sre = airavata.model.sharing.ttypes.SharingRegistryException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('createGroup_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRING, 0)
            oprot.writeString(self.success.encode('utf-8') if sys.version_info[0] == 2 else self.success)
            oprot.writeFieldEnd()
        if self.sre is not None:
            oprot.writeFieldBegin('sre', TType.STRUCT, 1)
            self.sre.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(createGroup_result)
createGroup_result.thrift_spec = (
    (0, TType.STRING, 'success', 'UTF8', None, ),  # 0
    (1, TType.STRUCT, 'sre', [airavata.model.sharing.ttypes.SharingRegistryException, None], None, ),  # 1
)


class updateGroup_args(object):
    """
    Attributes:
     - group

    """
    thrift_spec: typing.Any = None


    def __init__(self, group: airavata.model.sharing.ttypes.UserGroup = None,):
        self.group: airavata.model.sharing.ttypes.UserGroup = group

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.group = airavata.model.sharing.ttypes.UserGroup()
                    self.group.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('updateGroup_args')
        if self.group is not None:
            oprot.writeFieldBegin('group', TType.STRUCT, 1)
            self.group.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.group is None:
            raise TProtocolException(message='Required field group is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(updateGroup_args)
updateGroup_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'group', [airavata.model.sharing.ttypes.UserGroup, None], None, ),  # 1
)


class updateGroup_result(object):
    """
    Attributes:
     - success
     - sre

    """
    thrift_spec: typing.Any = None


    def __init__(self, success: typing.Optional[bool] = None, sre: typing.Optional[airavata.model.sharing.ttypes.SharingRegistryException] = None,):
        self.success: typing.Optional[bool] = success
        self.sre: typing.Optional[airavata.model.sharing.ttypes.SharingRegistryException] = sre

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.BOOL:
                    self.success = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.sre = airavata.model.sharing.ttypes.SharingRegistryException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('updateGroup_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.BOOL, 0)
            oprot.writeBool(self.success)
            oprot.writeFieldEnd()
        if self.sre is not None:
            oprot.writeFieldBegin('sre', TType.STRUCT, 1)
            self.sre.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(updateGroup_result)
updateGroup_result.thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'sre', [airavata.model.sharing.ttypes.SharingRegistryException, None], None, ),  # 1
)


class isGroupExists_args(object):
    """
    Attributes:
     - domainId
     - groupId

    """
    thrift_spec: typing.Any = None


    def __init__(self, domainId: str = None, groupId: str = None,):
        self.domainId: str = domainId
        self.groupId: str = groupId

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.domainId = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.groupId = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('isGroupExists_args')
        if self.domainId is not None:
            oprot.writeFieldBegin('domainId', TType.STRING, 1)
            oprot.writeString(self.domainId.encode('utf-8') if sys.version_info[0] == 2 else self.domainId)
            oprot.writeFieldEnd()
        if self.groupId is not None:
            oprot.writeFieldBegin('groupId', TType.STRING, 2)
            oprot.writeString(self.groupId.encode('utf-8') if sys.version_info[0] == 2 else self.groupId)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.domainId is None:
            raise TProtocolException(message='Required field domainId is unset!')
        if self.groupId is None:
            raise TProtocolException(message='Required field groupId is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(isGroupExists_args)
isGroupExists_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'domainId', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'groupId', 'UTF8', None, ),  # 2
)


class isGroupExists_result(object):
    """
    Attributes:
     - success
     - sre

    """
    thrift_spec: typing.Any = None


    def __init__(self, success: typing.Optional[bool] = None, sre: typing.Optional[airavata.model.sharing.ttypes.SharingRegistryException] = None,):
        self.success: typing.Optional[bool] = success
        self.sre: typing.Optional[airavata.model.sharing.ttypes.SharingRegistryException] = sre

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.BOOL:
                    self.success = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.sre = airavata.model.sharing.ttypes.SharingRegistryException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('isGroupExists_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.BOOL, 0)
            oprot.writeBool(self.success)
            oprot.writeFieldEnd()
        if self.sre is not None:
            oprot.writeFieldBegin('sre', TType.STRUCT, 1)
            self.sre.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(isGroupExists_result)
isGroupExists_result.thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'sre', [airavata.model.sharing.ttypes.SharingRegistryException, None], None, ),  # 1
)


class deleteGroup_args(object):
    """
    Attributes:
     - domainId
     - groupId

    """
    thrift_spec: typing.Any = None


    def __init__(self, domainId: str = None, groupId: str = None,):
        self.domainId: str = domainId
        self.groupId: str = groupId

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.domainId = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.groupId = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('deleteGroup_args')
        if self.domainId is not None:
            oprot.writeFieldBegin('domainId', TType.STRING, 1)
            oprot.writeString(self.domainId.encode('utf-8') if sys.version_info[0] == 2 else self.domainId)
            oprot.writeFieldEnd()
        if self.groupId is not None:
            oprot.writeFieldBegin('groupId', TType.STRING, 2)
            oprot.writeString(self.groupId.encode('utf-8') if sys.version_info[0] == 2 else self.groupId)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.domainId is None:
            raise TProtocolException(message='Required field domainId is unset!')
        if self.groupId is None:
            raise TProtocolException(message='Required field groupId is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(deleteGroup_args)
deleteGroup_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'domainId', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'groupId', 'UTF8', None, ),  # 2
)


class deleteGroup_result(object):
    """
    Attributes:
     - success
     - sre

    """
    thrift_spec: typing.Any = None


    def __init__(self, success: typing.Optional[bool] = None, sre: typing.Optional[airavata.model.sharing.ttypes.SharingRegistryException] = None,):
        self.success: typing.Optional[bool] = success
        self.sre: typing.Optional[airavata.model.sharing.ttypes.SharingRegistryException] = sre

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.BOOL:
                    self.success = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.sre = airavata.model.sharing.ttypes.SharingRegistryException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('deleteGroup_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.BOOL, 0)
            oprot.writeBool(self.success)
            oprot.writeFieldEnd()
        if self.sre is not None:
            oprot.writeFieldBegin('sre', TType.STRUCT, 1)
            self.sre.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(deleteGroup_result)
deleteGroup_result.thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'sre', [airavata.model.sharing.ttypes.SharingRegistryException, None], None, ),  # 1
)


class getGroup_args(object):
    """
    Attributes:
     - domainId
     - groupId

    """
    thrift_spec: typing.Any = None


    def __init__(self, domainId: str = None, groupId: str = None,):
        self.domainId: str = domainId
        self.groupId: str = groupId

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.domainId = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.groupId = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getGroup_args')
        if self.domainId is not None:
            oprot.writeFieldBegin('domainId', TType.STRING, 1)
            oprot.writeString(self.domainId.encode('utf-8') if sys.version_info[0] == 2 else self.domainId)
            oprot.writeFieldEnd()
        if self.groupId is not None:
            oprot.writeFieldBegin('groupId', TType.STRING, 2)
            oprot.writeString(self.groupId.encode('utf-8') if sys.version_info[0] == 2 else self.groupId)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.domainId is None:
            raise TProtocolException(message='Required field domainId is unset!')
        if self.groupId is None:
            raise TProtocolException(message='Required field groupId is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getGroup_args)
getGroup_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'domainId', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'groupId', 'UTF8', None, ),  # 2
)


class getGroup_result(object):
    """
    Attributes:
     - success
     - sre

    """
    thrift_spec: typing.Any = None


    def __init__(self, success: typing.Optional[airavata.model.sharing.ttypes.UserGroup] = None, sre: typing.Optional[airavata.model.sharing.ttypes.SharingRegistryException] = None,):
        self.success: typing.Optional[airavata.model.sharing.ttypes.UserGroup] = success
        self.sre: typing.Optional[airavata.model.sharing.ttypes.SharingRegistryException] = sre

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = airavata.model.sharing.ttypes.UserGroup()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.sre = airavata.model.sharing.ttypes.SharingRegistryException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getGroup_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.sre is not None:
            oprot.writeFieldBegin('sre', TType.STRUCT, 1)
            self.sre.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getGroup_result)
getGroup_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [airavata.model.sharing.ttypes.UserGroup, None], None, ),  # 0
    (1, TType.STRUCT, 'sre', [airavata.model.sharing.ttypes.SharingRegistryException, None], None, ),  # 1
)


class getGroups_args(object):
    """
    Attributes:
     - domainId
     - offset
     - limit

    """
    thrift_spec: typing.Any = None


    def __init__(self, domainId: str = None, offset: int = None, limit: int = None,):
        self.domainId: str = domainId
        self.offset: int = offset
        self.limit: int = limit

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.domainId = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.offset = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.limit = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getGroups_args')
        if self.domainId is not None:
            oprot.writeFieldBegin('domainId', TType.STRING, 1)
            oprot.writeString(self.domainId.encode('utf-8') if sys.version_info[0] == 2 else self.domainId)
            oprot.writeFieldEnd()
        if self.offset is not None:
            oprot.writeFieldBegin('offset', TType.I32, 2)
            oprot.writeI32(self.offset)
            oprot.writeFieldEnd()
        if self.limit is not None:
            oprot.writeFieldBegin('limit', TType.I32, 3)
            oprot.writeI32(self.limit)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.domainId is None:
            raise TProtocolException(message='Required field domainId is unset!')
        if self.offset is None:
            raise TProtocolException(message='Required field offset is unset!')
        if self.limit is None:
            raise TProtocolException(message='Required field limit is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getGroups_args)
getGroups_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'domainId', 'UTF8', None, ),  # 1
    (2, TType.I32, 'offset', None, None, ),  # 2
    (3, TType.I32, 'limit', None, None, ),  # 3
)


class getGroups_result(object):
    """
    Attributes:
     - success

    """
    thrift_spec: typing.Any = None


    def __init__(self, success: typing.Optional[list[airavata.model.sharing.ttypes.UserGroup]] = None,):
        self.success: typing.Optional[list[airavata.model.sharing.ttypes.UserGroup]] = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype17, _size14) = iprot.readListBegin()
                    for _i18 in range(_size14):
                        _elem19 = airavata.model.sharing.ttypes.UserGroup()
                        _elem19.read(iprot)
                        self.success.append(_elem19)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getGroups_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter20 in self.success:
                iter20.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getGroups_result)
getGroups_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT, [airavata.model.sharing.ttypes.UserGroup, None], False), None, ),  # 0
)


class addUsersToGroup_args(object):
    """
    Attributes:
     - domainId
     - userIds
     - groupId

    """
    thrift_spec: typing.Any = None


    def __init__(self, domainId: str = None, userIds: list[str] = None, groupId: str = None,):
        self.domainId: str = domainId
        self.userIds: list[str] = userIds
        self.groupId: str = groupId

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.domainId = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.userIds = []
                    (_etype24, _size21) = iprot.readListBegin()
                    for _i25 in range(_size21):
                        _elem26 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.userIds.append(_elem26)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.groupId = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('addUsersToGroup_args')
        if self.domainId is not None:
            oprot.writeFieldBegin('domainId', TType.STRING, 1)
            oprot.writeString(self.domainId.encode('utf-8') if sys.version_info[0] == 2 else self.domainId)
            oprot.writeFieldEnd()
        if self.userIds is not None:
            oprot.writeFieldBegin('userIds', TType.LIST, 2)
            oprot.writeListBegin(TType.STRING, len(self.userIds))
            for iter27 in self.userIds:
                oprot.writeString(iter27.encode('utf-8') if sys.version_info[0] == 2 else iter27)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.groupId is not None:
            oprot.writeFieldBegin('groupId', TType.STRING, 3)
            oprot.writeString(self.groupId.encode('utf-8') if sys.version_info[0] == 2 else self.groupId)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.domainId is None:
            raise TProtocolException(message='Required field domainId is unset!')
        if self.userIds is None:
            raise TProtocolException(message='Required field userIds is unset!')
        if self.groupId is None:
            raise TProtocolException(message='Required field groupId is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(addUsersToGroup_args)
addUsersToGroup_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'domainId', 'UTF8', None, ),  # 1
    (2, TType.LIST, 'userIds', (TType.STRING, 'UTF8', False), None, ),  # 2
    (3, TType.STRING, 'groupId', 'UTF8', None, ),  # 3
)


class addUsersToGroup_result(object):
    """
    Attributes:
     - success
     - sre

    """
    thrift_spec: typing.Any = None


    def __init__(self, success: typing.Optional[bool] = None, sre: typing.Optional[airavata.model.sharing.ttypes.SharingRegistryException] = None,):
        self.success: typing.Optional[bool] = success
        self.sre: typing.Optional[airavata.model.sharing.ttypes.SharingRegistryException] = sre

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.BOOL:
                    self.success = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.sre = airavata.model.sharing.ttypes.SharingRegistryException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('addUsersToGroup_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.BOOL, 0)
            oprot.writeBool(self.success)
            oprot.writeFieldEnd()
        if self.sre is not None:
            oprot.writeFieldBegin('sre', TType.STRUCT, 1)
            self.sre.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(addUsersToGroup_result)
addUsersToGroup_result.thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'sre', [airavata.model.sharing.ttypes.SharingRegistryException, None], None, ),  # 1
)


class removeUsersFromGroup_args(object):
    """
    Attributes:
     - domainId
     - userIds
     - groupId

    """
    thrift_spec: typing.Any = None


    def __init__(self, domainId: str = None, userIds: list[str] = None, groupId: str = None,):
        self.domainId: str = domainId
        self.userIds: list[str] = userIds
        self.groupId: str = groupId

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.domainId = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.userIds = []
                    (_etype31, _size28) = iprot.readListBegin()
                    for _i32 in range(_size28):
                        _elem33 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.userIds.append(_elem33)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.groupId = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('removeUsersFromGroup_args')
        if self.domainId is not None:
            oprot.writeFieldBegin('domainId', TType.STRING, 1)
            oprot.writeString(self.domainId.encode('utf-8') if sys.version_info[0] == 2 else self.domainId)
            oprot.writeFieldEnd()
        if self.userIds is not None:
            oprot.writeFieldBegin('userIds', TType.LIST, 2)
            oprot.writeListBegin(TType.STRING, len(self.userIds))
            for iter34 in self.userIds:
                oprot.writeString(iter34.encode('utf-8') if sys.version_info[0] == 2 else iter34)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.groupId is not None:
            oprot.writeFieldBegin('groupId', TType.STRING, 3)
            oprot.writeString(self.groupId.encode('utf-8') if sys.version_info[0] == 2 else self.groupId)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.domainId is None:
            raise TProtocolException(message='Required field domainId is unset!')
        if self.userIds is None:
            raise TProtocolException(message='Required field userIds is unset!')
        if self.groupId is None:
            raise TProtocolException(message='Required field groupId is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(removeUsersFromGroup_args)
removeUsersFromGroup_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'domainId', 'UTF8', None, ),  # 1
    (2, TType.LIST, 'userIds', (TType.STRING, 'UTF8', False), None, ),  # 2
    (3, TType.STRING, 'groupId', 'UTF8', None, ),  # 3
)


class removeUsersFromGroup_result(object):
    """
    Attributes:
     - success
     - sre

    """
    thrift_spec: typing.Any = None


    def __init__(self, success: typing.Optional[bool] = None, sre: typing.Optional[airavata.model.sharing.ttypes.SharingRegistryException] = None,):
        self.success: typing.Optional[bool] = success
        self.sre: typing.Optional[airavata.model.sharing.ttypes.SharingRegistryException] = sre

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.BOOL:
                    self.success = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.sre = airavata.model.sharing.ttypes.SharingRegistryException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('removeUsersFromGroup_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.BOOL, 0)
            oprot.writeBool(self.success)
            oprot.writeFieldEnd()
        if self.sre is not None:
            oprot.writeFieldBegin('sre', TType.STRUCT, 1)
            self.sre.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(removeUsersFromGroup_result)
removeUsersFromGroup_result.thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'sre', [airavata.model.sharing.ttypes.SharingRegistryException, None], None, ),  # 1
)


class transferGroupOwnership_args(object):
    """
    Attributes:
     - domainId
     - groupId
     - newOwnerId

    """
    thrift_spec: typing.Any = None


    def __init__(self, domainId: str = None, groupId: str = None, newOwnerId: str = None,):
        self.domainId: str = domainId
        self.groupId: str = groupId
        self.newOwnerId: str = newOwnerId

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.domainId = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.groupId = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.newOwnerId = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('transferGroupOwnership_args')
        if self.domainId is not None:
            oprot.writeFieldBegin('domainId', TType.STRING, 1)
            oprot.writeString(self.domainId.encode('utf-8') if sys.version_info[0] == 2 else self.domainId)
            oprot.writeFieldEnd()
        if self.groupId is not None:
            oprot.writeFieldBegin('groupId', TType.STRING, 2)
            oprot.writeString(self.groupId.encode('utf-8') if sys.version_info[0] == 2 else self.groupId)
            oprot.writeFieldEnd()
        if self.newOwnerId is not None:
            oprot.writeFieldBegin('newOwnerId', TType.STRING, 3)
            oprot.writeString(self.newOwnerId.encode('utf-8') if sys.version_info[0] == 2 else self.newOwnerId)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.domainId is None:
            raise TProtocolException(message='Required field domainId is unset!')
        if self.groupId is None:
            raise TProtocolException(message='Required field groupId is unset!')
        if self.newOwnerId is None:
            raise TProtocolException(message='Required field newOwnerId is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(transferGroupOwnership_args)
transferGroupOwnership_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'domainId', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'groupId', 'UTF8', None, ),  # 2
    (3, TType.STRING, 'newOwnerId', 'UTF8', None, ),  # 3
)


class transferGroupOwnership_result(object):
    """
    Attributes:
     - success
     - sre

    """
    thrift_spec: typing.Any = None


    def __init__(self, success: typing.Optional[bool] = None, sre: typing.Optional[airavata.model.sharing.ttypes.SharingRegistryException] = None,):
        self.success: typing.Optional[bool] = success
        self.sre: typing.Optional[airavata.model.sharing.ttypes.SharingRegistryException] = sre

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.BOOL:
                    self.success = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.sre = airavata.model.sharing.ttypes.SharingRegistryException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('transferGroupOwnership_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.BOOL, 0)
            oprot.writeBool(self.success)
            oprot.writeFieldEnd()
        if self.sre is not None:
            oprot.writeFieldBegin('sre', TType.STRUCT, 1)
            self.sre.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(transferGroupOwnership_result)
transferGroupOwnership_result.thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'sre', [airavata.model.sharing.ttypes.SharingRegistryException, None], None, ),  # 1
)


class addGroupAdmins_args(object):
    """
    Attributes:
     - domainId
     - groupId
     - adminIds

    """
    thrift_spec: typing.Any = None


    def __init__(self, domainId: str = None, groupId: str = None, adminIds: list[str] = None,):
        self.domainId: str = domainId
        self.groupId: str = groupId
        self.adminIds: list[str] = adminIds

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.domainId = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.groupId = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.adminIds = []
                    (_etype38, _size35) = iprot.readListBegin()
                    for _i39 in range(_size35):
                        _elem40 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.adminIds.append(_elem40)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('addGroupAdmins_args')
        if self.domainId is not None:
            oprot.writeFieldBegin('domainId', TType.STRING, 1)
            oprot.writeString(self.domainId.encode('utf-8') if sys.version_info[0] == 2 else self.domainId)
            oprot.writeFieldEnd()
        if self.groupId is not None:
            oprot.writeFieldBegin('groupId', TType.STRING, 2)
            oprot.writeString(self.groupId.encode('utf-8') if sys.version_info[0] == 2 else self.groupId)
            oprot.writeFieldEnd()
        if self.adminIds is not None:
            oprot.writeFieldBegin('adminIds', TType.LIST, 3)
            oprot.writeListBegin(TType.STRING, len(self.adminIds))
            for iter41 in self.adminIds:
                oprot.writeString(iter41.encode('utf-8') if sys.version_info[0] == 2 else iter41)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.domainId is None:
            raise TProtocolException(message='Required field domainId is unset!')
        if self.groupId is None:
            raise TProtocolException(message='Required field groupId is unset!')
        if self.adminIds is None:
            raise TProtocolException(message='Required field adminIds is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(addGroupAdmins_args)
addGroupAdmins_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'domainId', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'groupId', 'UTF8', None, ),  # 2
    (3, TType.LIST, 'adminIds', (TType.STRING, 'UTF8', False), None, ),  # 3
)


class addGroupAdmins_result(object):
    """
    Attributes:
     - success
     - sre

    """
    thrift_spec: typing.Any = None


    def __init__(self, success: typing.Optional[bool] = None, sre: typing.Optional[airavata.model.sharing.ttypes.SharingRegistryException] = None,):
        self.success: typing.Optional[bool] = success
        self.sre: typing.Optional[airavata.model.sharing.ttypes.SharingRegistryException] = sre

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.BOOL:
                    self.success = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.sre = airavata.model.sharing.ttypes.SharingRegistryException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('addGroupAdmins_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.BOOL, 0)
            oprot.writeBool(self.success)
            oprot.writeFieldEnd()
        if self.sre is not None:
            oprot.writeFieldBegin('sre', TType.STRUCT, 1)
            self.sre.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(addGroupAdmins_result)
addGroupAdmins_result.thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'sre', [airavata.model.sharing.ttypes.SharingRegistryException, None], None, ),  # 1
)


class removeGroupAdmins_args(object):
    """
    Attributes:
     - domainId
     - groupId
     - adminIds

    """
    thrift_spec: typing.Any = None


    def __init__(self, domainId: str = None, groupId: str = None, adminIds: list[str] = None,):
        self.domainId: str = domainId
        self.groupId: str = groupId
        self.adminIds: list[str] = adminIds

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.domainId = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.groupId = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.adminIds = []
                    (_etype45, _size42) = iprot.readListBegin()
                    for _i46 in range(_size42):
                        _elem47 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.adminIds.append(_elem47)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('removeGroupAdmins_args')
        if self.domainId is not None:
            oprot.writeFieldBegin('domainId', TType.STRING, 1)
            oprot.writeString(self.domainId.encode('utf-8') if sys.version_info[0] == 2 else self.domainId)
            oprot.writeFieldEnd()
        if self.groupId is not None:
            oprot.writeFieldBegin('groupId', TType.STRING, 2)
            oprot.writeString(self.groupId.encode('utf-8') if sys.version_info[0] == 2 else self.groupId)
            oprot.writeFieldEnd()
        if self.adminIds is not None:
            oprot.writeFieldBegin('adminIds', TType.LIST, 3)
            oprot.writeListBegin(TType.STRING, len(self.adminIds))
            for iter48 in self.adminIds:
                oprot.writeString(iter48.encode('utf-8') if sys.version_info[0] == 2 else iter48)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.domainId is None:
            raise TProtocolException(message='Required field domainId is unset!')
        if self.groupId is None:
            raise TProtocolException(message='Required field groupId is unset!')
        if self.adminIds is None:
            raise TProtocolException(message='Required field adminIds is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(removeGroupAdmins_args)
removeGroupAdmins_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'domainId', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'groupId', 'UTF8', None, ),  # 2
    (3, TType.LIST, 'adminIds', (TType.STRING, 'UTF8', False), None, ),  # 3
)


class removeGroupAdmins_result(object):
    """
    Attributes:
     - success
     - sre

    """
    thrift_spec: typing.Any = None


    def __init__(self, success: typing.Optional[bool] = None, sre: typing.Optional[airavata.model.sharing.ttypes.SharingRegistryException] = None,):
        self.success: typing.Optional[bool] = success
        self.sre: typing.Optional[airavata.model.sharing.ttypes.SharingRegistryException] = sre

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.BOOL:
                    self.success = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.sre = airavata.model.sharing.ttypes.SharingRegistryException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('removeGroupAdmins_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.BOOL, 0)
            oprot.writeBool(self.success)
            oprot.writeFieldEnd()
        if self.sre is not None:
            oprot.writeFieldBegin('sre', TType.STRUCT, 1)
            self.sre.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(removeGroupAdmins_result)
removeGroupAdmins_result.thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'sre', [airavata.model.sharing.ttypes.SharingRegistryException, None], None, ),  # 1
)


class hasAdminAccess_args(object):
    """
    Attributes:
     - domainId
     - groupId
     - adminId

    """
    thrift_spec: typing.Any = None


    def __init__(self, domainId: str = None, groupId: str = None, adminId: str = None,):
        self.domainId: str = domainId
        self.groupId: str = groupId
        self.adminId: str = adminId

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.domainId = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.groupId = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.adminId = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('hasAdminAccess_args')
        if self.domainId is not None:
            oprot.writeFieldBegin('domainId', TType.STRING, 1)
            oprot.writeString(self.domainId.encode('utf-8') if sys.version_info[0] == 2 else self.domainId)
            oprot.writeFieldEnd()
        if self.groupId is not None:
            oprot.writeFieldBegin('groupId', TType.STRING, 2)
            oprot.writeString(self.groupId.encode('utf-8') if sys.version_info[0] == 2 else self.groupId)
            oprot.writeFieldEnd()
        if self.adminId is not None:
            oprot.writeFieldBegin('adminId', TType.STRING, 3)
            oprot.writeString(self.adminId.encode('utf-8') if sys.version_info[0] == 2 else self.adminId)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.domainId is None:
            raise TProtocolException(message='Required field domainId is unset!')
        if self.groupId is None:
            raise TProtocolException(message='Required field groupId is unset!')
        if self.adminId is None:
            raise TProtocolException(message='Required field adminId is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(hasAdminAccess_args)
hasAdminAccess_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'domainId', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'groupId', 'UTF8', None, ),  # 2
    (3, TType.STRING, 'adminId', 'UTF8', None, ),  # 3
)


class hasAdminAccess_result(object):
    """
    Attributes:
     - success
     - sre

    """
    thrift_spec: typing.Any = None


    def __init__(self, success: typing.Optional[bool] = None, sre: typing.Optional[airavata.model.sharing.ttypes.SharingRegistryException] = None,):
        self.success: typing.Optional[bool] = success
        self.sre: typing.Optional[airavata.model.sharing.ttypes.SharingRegistryException] = sre

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.BOOL:
                    self.success = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.sre = airavata.model.sharing.ttypes.SharingRegistryException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('hasAdminAccess_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.BOOL, 0)
            oprot.writeBool(self.success)
            oprot.writeFieldEnd()
        if self.sre is not None:
            oprot.writeFieldBegin('sre', TType.STRUCT, 1)
            self.sre.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(hasAdminAccess_result)
hasAdminAccess_result.thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'sre', [airavata.model.sharing.ttypes.SharingRegistryException, None], None, ),  # 1
)


class hasOwnerAccess_args(object):
    """
    Attributes:
     - domainId
     - groupId
     - ownerId

    """
    thrift_spec: typing.Any = None


    def __init__(self, domainId: str = None, groupId: str = None, ownerId: str = None,):
        self.domainId: str = domainId
        self.groupId: str = groupId
        self.ownerId: str = ownerId

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.domainId = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.groupId = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.ownerId = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('hasOwnerAccess_args')
        if self.domainId is not None:
            oprot.writeFieldBegin('domainId', TType.STRING, 1)
            oprot.writeString(self.domainId.encode('utf-8') if sys.version_info[0] == 2 else self.domainId)
            oprot.writeFieldEnd()
        if self.groupId is not None:
            oprot.writeFieldBegin('groupId', TType.STRING, 2)
            oprot.writeString(self.groupId.encode('utf-8') if sys.version_info[0] == 2 else self.groupId)
            oprot.writeFieldEnd()
        if self.ownerId is not None:
            oprot.writeFieldBegin('ownerId', TType.STRING, 3)
            oprot.writeString(self.ownerId.encode('utf-8') if sys.version_info[0] == 2 else self.ownerId)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.domainId is None:
            raise TProtocolException(message='Required field domainId is unset!')
        if self.groupId is None:
            raise TProtocolException(message='Required field groupId is unset!')
        if self.ownerId is None:
            raise TProtocolException(message='Required field ownerId is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(hasOwnerAccess_args)
hasOwnerAccess_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'domainId', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'groupId', 'UTF8', None, ),  # 2
    (3, TType.STRING, 'ownerId', 'UTF8', None, ),  # 3
)


class hasOwnerAccess_result(object):
    """
    Attributes:
     - success
     - sre

    """
    thrift_spec: typing.Any = None


    def __init__(self, success: typing.Optional[bool] = None, sre: typing.Optional[airavata.model.sharing.ttypes.SharingRegistryException] = None,):
        self.success: typing.Optional[bool] = success
        self.sre: typing.Optional[airavata.model.sharing.ttypes.SharingRegistryException] = sre

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.BOOL:
                    self.success = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.sre = airavata.model.sharing.ttypes.SharingRegistryException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('hasOwnerAccess_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.BOOL, 0)
            oprot.writeBool(self.success)
            oprot.writeFieldEnd()
        if self.sre is not None:
            oprot.writeFieldBegin('sre', TType.STRUCT, 1)
            self.sre.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(hasOwnerAccess_result)
hasOwnerAccess_result.thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'sre', [airavata.model.sharing.ttypes.SharingRegistryException, None], None, ),  # 1
)


class getGroupMembersOfTypeUser_args(object):
    """
    Attributes:
     - domainId
     - groupId
     - offset
     - limit

    """
    thrift_spec: typing.Any = None


    def __init__(self, domainId: typing.Optional[str] = None, groupId: str = None, offset: int = None, limit: int = None,):
        self.domainId: typing.Optional[str] = domainId
        self.groupId: str = groupId
        self.offset: int = offset
        self.limit: int = limit

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.domainId = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.groupId = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.offset = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I32:
                    self.limit = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getGroupMembersOfTypeUser_args')
        if self.domainId is not None:
            oprot.writeFieldBegin('domainId', TType.STRING, 1)
            oprot.writeString(self.domainId.encode('utf-8') if sys.version_info[0] == 2 else self.domainId)
            oprot.writeFieldEnd()
        if self.groupId is not None:
            oprot.writeFieldBegin('groupId', TType.STRING, 2)
            oprot.writeString(self.groupId.encode('utf-8') if sys.version_info[0] == 2 else self.groupId)
            oprot.writeFieldEnd()
        if self.offset is not None:
            oprot.writeFieldBegin('offset', TType.I32, 3)
            oprot.writeI32(self.offset)
            oprot.writeFieldEnd()
        if self.limit is not None:
            oprot.writeFieldBegin('limit', TType.I32, 4)
            oprot.writeI32(self.limit)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.groupId is None:
            raise TProtocolException(message='Required field groupId is unset!')
        if self.offset is None:
            raise TProtocolException(message='Required field offset is unset!')
        if self.limit is None:
            raise TProtocolException(message='Required field limit is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getGroupMembersOfTypeUser_args)
getGroupMembersOfTypeUser_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'domainId', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'groupId', 'UTF8', None, ),  # 2
    (3, TType.I32, 'offset', None, None, ),  # 3
    (4, TType.I32, 'limit', None, None, ),  # 4
)


class getGroupMembersOfTypeUser_result(object):
    """
    Attributes:
     - success
     - sre

    """
    thrift_spec: typing.Any = None


    def __init__(self, success: typing.Optional[list[airavata.model.sharing.ttypes.User]] = None, sre: typing.Optional[airavata.model.sharing.ttypes.SharingRegistryException] = None,):
        self.success: typing.Optional[list[airavata.model.sharing.ttypes.User]] = success
        self.sre: typing.Optional[airavata.model.sharing.ttypes.SharingRegistryException] = sre

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype52, _size49) = iprot.readListBegin()
                    for _i53 in range(_size49):
                        _elem54 = airavata.model.sharing.ttypes.User()
                        _elem54.read(iprot)
                        self.success.append(_elem54)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.sre = airavata.model.sharing.ttypes.SharingRegistryException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getGroupMembersOfTypeUser_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter55 in self.success:
                iter55.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.sre is not None:
            oprot.writeFieldBegin('sre', TType.STRUCT, 1)
            self.sre.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getGroupMembersOfTypeUser_result)
getGroupMembersOfTypeUser_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT, [airavata.model.sharing.ttypes.User, None], False), None, ),  # 0
    (1, TType.STRUCT, 'sre', [airavata.model.sharing.ttypes.SharingRegistryException, None], None, ),  # 1
)


class getGroupMembersOfTypeGroup_args(object):
    """
    Attributes:
     - domainId
     - groupId
     - offset
     - limit

    """
    thrift_spec: typing.Any = None


    def __init__(self, domainId: str = None, groupId: str = None, offset: int = None, limit: int = None,):
        self.domainId: str = domainId
        self.groupId: str = groupId
        self.offset: int = offset
        self.limit: int = limit

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.domainId = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.groupId = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.offset = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I32:
                    self.limit = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getGroupMembersOfTypeGroup_args')
        if self.domainId is not None:
            oprot.writeFieldBegin('domainId', TType.STRING, 1)
            oprot.writeString(self.domainId.encode('utf-8') if sys.version_info[0] == 2 else self.domainId)
            oprot.writeFieldEnd()
        if self.groupId is not None:
            oprot.writeFieldBegin('groupId', TType.STRING, 2)
            oprot.writeString(self.groupId.encode('utf-8') if sys.version_info[0] == 2 else self.groupId)
            oprot.writeFieldEnd()
        if self.offset is not None:
            oprot.writeFieldBegin('offset', TType.I32, 3)
            oprot.writeI32(self.offset)
            oprot.writeFieldEnd()
        if self.limit is not None:
            oprot.writeFieldBegin('limit', TType.I32, 4)
            oprot.writeI32(self.limit)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.domainId is None:
            raise TProtocolException(message='Required field domainId is unset!')
        if self.groupId is None:
            raise TProtocolException(message='Required field groupId is unset!')
        if self.offset is None:
            raise TProtocolException(message='Required field offset is unset!')
        if self.limit is None:
            raise TProtocolException(message='Required field limit is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getGroupMembersOfTypeGroup_args)
getGroupMembersOfTypeGroup_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'domainId', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'groupId', 'UTF8', None, ),  # 2
    (3, TType.I32, 'offset', None, None, ),  # 3
    (4, TType.I32, 'limit', None, None, ),  # 4
)


class getGroupMembersOfTypeGroup_result(object):
    """
    Attributes:
     - success
     - sre

    """
    thrift_spec: typing.Any = None


    def __init__(self, success: typing.Optional[list[airavata.model.sharing.ttypes.UserGroup]] = None, sre: typing.Optional[airavata.model.sharing.ttypes.SharingRegistryException] = None,):
        self.success: typing.Optional[list[airavata.model.sharing.ttypes.UserGroup]] = success
        self.sre: typing.Optional[airavata.model.sharing.ttypes.SharingRegistryException] = sre

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype59, _size56) = iprot.readListBegin()
                    for _i60 in range(_size56):
                        _elem61 = airavata.model.sharing.ttypes.UserGroup()
                        _elem61.read(iprot)
                        self.success.append(_elem61)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.sre = airavata.model.sharing.ttypes.SharingRegistryException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getGroupMembersOfTypeGroup_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter62 in self.success:
                iter62.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.sre is not None:
            oprot.writeFieldBegin('sre', TType.STRUCT, 1)
            self.sre.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getGroupMembersOfTypeGroup_result)
getGroupMembersOfTypeGroup_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT, [airavata.model.sharing.ttypes.UserGroup, None], False), None, ),  # 0
    (1, TType.STRUCT, 'sre', [airavata.model.sharing.ttypes.SharingRegistryException, None], None, ),  # 1
)


class addChildGroupsToParentGroup_args(object):
    """
    Attributes:
     - domainId
     - childIds
     - groupId

    """
    thrift_spec: typing.Any = None


    def __init__(self, domainId: str = None, childIds: list[str] = None, groupId: str = None,):
        self.domainId: str = domainId
        self.childIds: list[str] = childIds
        self.groupId: str = groupId

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.domainId = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.childIds = []
                    (_etype66, _size63) = iprot.readListBegin()
                    for _i67 in range(_size63):
                        _elem68 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.childIds.append(_elem68)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.groupId = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('addChildGroupsToParentGroup_args')
        if self.domainId is not None:
            oprot.writeFieldBegin('domainId', TType.STRING, 1)
            oprot.writeString(self.domainId.encode('utf-8') if sys.version_info[0] == 2 else self.domainId)
            oprot.writeFieldEnd()
        if self.childIds is not None:
            oprot.writeFieldBegin('childIds', TType.LIST, 2)
            oprot.writeListBegin(TType.STRING, len(self.childIds))
            for iter69 in self.childIds:
                oprot.writeString(iter69.encode('utf-8') if sys.version_info[0] == 2 else iter69)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.groupId is not None:
            oprot.writeFieldBegin('groupId', TType.STRING, 3)
            oprot.writeString(self.groupId.encode('utf-8') if sys.version_info[0] == 2 else self.groupId)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.domainId is None:
            raise TProtocolException(message='Required field domainId is unset!')
        if self.childIds is None:
            raise TProtocolException(message='Required field childIds is unset!')
        if self.groupId is None:
            raise TProtocolException(message='Required field groupId is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(addChildGroupsToParentGroup_args)
addChildGroupsToParentGroup_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'domainId', 'UTF8', None, ),  # 1
    (2, TType.LIST, 'childIds', (TType.STRING, 'UTF8', False), None, ),  # 2
    (3, TType.STRING, 'groupId', 'UTF8', None, ),  # 3
)


class addChildGroupsToParentGroup_result(object):
    """
    Attributes:
     - success
     - sre

    """
    thrift_spec: typing.Any = None


    def __init__(self, success: typing.Optional[bool] = None, sre: typing.Optional[airavata.model.sharing.ttypes.SharingRegistryException] = None,):
        self.success: typing.Optional[bool] = success
        self.sre: typing.Optional[airavata.model.sharing.ttypes.SharingRegistryException] = sre

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.BOOL:
                    self.success = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.sre = airavata.model.sharing.ttypes.SharingRegistryException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('addChildGroupsToParentGroup_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.BOOL, 0)
            oprot.writeBool(self.success)
            oprot.writeFieldEnd()
        if self.sre is not None:
            oprot.writeFieldBegin('sre', TType.STRUCT, 1)
            self.sre.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(addChildGroupsToParentGroup_result)
addChildGroupsToParentGroup_result.thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'sre', [airavata.model.sharing.ttypes.SharingRegistryException, None], None, ),  # 1
)


class removeChildGroupFromParentGroup_args(object):
    """
    Attributes:
     - domainId
     - childId
     - groupId

    """
    thrift_spec: typing.Any = None


    def __init__(self, domainId: str = None, childId: str = None, groupId: str = None,):
        self.domainId: str = domainId
        self.childId: str = childId
        self.groupId: str = groupId

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.domainId = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.childId = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.groupId = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('removeChildGroupFromParentGroup_args')
        if self.domainId is not None:
            oprot.writeFieldBegin('domainId', TType.STRING, 1)
            oprot.writeString(self.domainId.encode('utf-8') if sys.version_info[0] == 2 else self.domainId)
            oprot.writeFieldEnd()
        if self.childId is not None:
            oprot.writeFieldBegin('childId', TType.STRING, 2)
            oprot.writeString(self.childId.encode('utf-8') if sys.version_info[0] == 2 else self.childId)
            oprot.writeFieldEnd()
        if self.groupId is not None:
            oprot.writeFieldBegin('groupId', TType.STRING, 3)
            oprot.writeString(self.groupId.encode('utf-8') if sys.version_info[0] == 2 else self.groupId)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.domainId is None:
            raise TProtocolException(message='Required field domainId is unset!')
        if self.childId is None:
            raise TProtocolException(message='Required field childId is unset!')
        if self.groupId is None:
            raise TProtocolException(message='Required field groupId is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(removeChildGroupFromParentGroup_args)
removeChildGroupFromParentGroup_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'domainId', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'childId', 'UTF8', None, ),  # 2
    (3, TType.STRING, 'groupId', 'UTF8', None, ),  # 3
)


class removeChildGroupFromParentGroup_result(object):
    """
    Attributes:
     - success
     - sre

    """
    thrift_spec: typing.Any = None


    def __init__(self, success: typing.Optional[bool] = None, sre: typing.Optional[airavata.model.sharing.ttypes.SharingRegistryException] = None,):
        self.success: typing.Optional[bool] = success
        self.sre: typing.Optional[airavata.model.sharing.ttypes.SharingRegistryException] = sre

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.BOOL:
                    self.success = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.sre = airavata.model.sharing.ttypes.SharingRegistryException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('removeChildGroupFromParentGroup_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.BOOL, 0)
            oprot.writeBool(self.success)
            oprot.writeFieldEnd()
        if self.sre is not None:
            oprot.writeFieldBegin('sre', TType.STRUCT, 1)
            self.sre.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(removeChildGroupFromParentGroup_result)
removeChildGroupFromParentGroup_result.thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'sre', [airavata.model.sharing.ttypes.SharingRegistryException, None], None, ),  # 1
)


class getAllMemberGroupsForUser_args(object):
    """
    Attributes:
     - domainId
     - userId

    """
    thrift_spec: typing.Any = None


    def __init__(self, domainId: str = None, userId: str = None,):
        self.domainId: str = domainId
        self.userId: str = userId

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.domainId = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.userId = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getAllMemberGroupsForUser_args')
        if self.domainId is not None:
            oprot.writeFieldBegin('domainId', TType.STRING, 1)
            oprot.writeString(self.domainId.encode('utf-8') if sys.version_info[0] == 2 else self.domainId)
            oprot.writeFieldEnd()
        if self.userId is not None:
            oprot.writeFieldBegin('userId', TType.STRING, 2)
            oprot.writeString(self.userId.encode('utf-8') if sys.version_info[0] == 2 else self.userId)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.domainId is None:
            raise TProtocolException(message='Required field domainId is unset!')
        if self.userId is None:
            raise TProtocolException(message='Required field userId is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getAllMemberGroupsForUser_args)
getAllMemberGroupsForUser_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'domainId', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'userId', 'UTF8', None, ),  # 2
)


class getAllMemberGroupsForUser_result(object):
    """
    Attributes:
     - success
     - sre

    """
    thrift_spec: typing.Any = None


    def __init__(self, success: typing.Optional[list[airavata.model.sharing.ttypes.UserGroup]] = None, sre: typing.Optional[airavata.model.sharing.ttypes.SharingRegistryException] = None,):
        self.success: typing.Optional[list[airavata.model.sharing.ttypes.UserGroup]] = success
        self.sre: typing.Optional[airavata.model.sharing.ttypes.SharingRegistryException] = sre

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype73, _size70) = iprot.readListBegin()
                    for _i74 in range(_size70):
                        _elem75 = airavata.model.sharing.ttypes.UserGroup()
                        _elem75.read(iprot)
                        self.success.append(_elem75)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.sre = airavata.model.sharing.ttypes.SharingRegistryException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getAllMemberGroupsForUser_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter76 in self.success:
                iter76.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.sre is not None:
            oprot.writeFieldBegin('sre', TType.STRUCT, 1)
            self.sre.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getAllMemberGroupsForUser_result)
getAllMemberGroupsForUser_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT, [airavata.model.sharing.ttypes.UserGroup, None], False), None, ),  # 0
    (1, TType.STRUCT, 'sre', [airavata.model.sharing.ttypes.SharingRegistryException, None], None, ),  # 1
)


class createEntityType_args(object):
    """
    Attributes:
     - entityType

    """
    thrift_spec: typing.Any = None


    def __init__(self, entityType: airavata.model.sharing.ttypes.EntityType = None,):
        self.entityType: airavata.model.sharing.ttypes.EntityType = entityType

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.entityType = airavata.model.sharing.ttypes.EntityType()
                    self.entityType.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('createEntityType_args')
        if self.entityType is not None:
            oprot.writeFieldBegin('entityType', TType.STRUCT, 1)
            self.entityType.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.entityType is None:
            raise TProtocolException(message='Required field entityType is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(createEntityType_args)
createEntityType_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'entityType', [airavata.model.sharing.ttypes.EntityType, None], None, ),  # 1
)


class createEntityType_result(object):
    """
    Attributes:
     - success
     - sre
     - dee

    """
    thrift_spec: typing.Any = None


    def __init__(self, success: typing.Optional[str] = None, sre: typing.Optional[airavata.model.sharing.ttypes.SharingRegistryException] = None, dee: typing.Optional[airavata.model.sharing.ttypes.DuplicateEntryException] = None,):
        self.success: typing.Optional[str] = success
        self.sre: typing.Optional[airavata.model.sharing.ttypes.SharingRegistryException] = sre
        self.dee: typing.Optional[airavata.model.sharing.ttypes.DuplicateEntryException] = dee

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRING:
                    self.success = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.sre = airavata.model.sharing.ttypes.SharingRegistryException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.dee = airavata.model.sharing.ttypes.DuplicateEntryException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('createEntityType_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRING, 0)
            oprot.writeString(self.success.encode('utf-8') if sys.version_info[0] == 2 else self.success)
            oprot.writeFieldEnd()
        if self.sre is not None:
            oprot.writeFieldBegin('sre', TType.STRUCT, 1)
            self.sre.write(oprot)
            oprot.writeFieldEnd()
        if self.dee is not None:
            oprot.writeFieldBegin('dee', TType.STRUCT, 2)
            self.dee.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(createEntityType_result)
createEntityType_result.thrift_spec = (
    (0, TType.STRING, 'success', 'UTF8', None, ),  # 0
    (1, TType.STRUCT, 'sre', [airavata.model.sharing.ttypes.SharingRegistryException, None], None, ),  # 1
    (2, TType.STRUCT, 'dee', [airavata.model.sharing.ttypes.DuplicateEntryException, None], None, ),  # 2
)


class updateEntityType_args(object):
    """
    Attributes:
     - entityType

    """
    thrift_spec: typing.Any = None


    def __init__(self, entityType: airavata.model.sharing.ttypes.EntityType = None,):
        self.entityType: airavata.model.sharing.ttypes.EntityType = entityType

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.entityType = airavata.model.sharing.ttypes.EntityType()
                    self.entityType.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('updateEntityType_args')
        if self.entityType is not None:
            oprot.writeFieldBegin('entityType', TType.STRUCT, 1)
            self.entityType.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.entityType is None:
            raise TProtocolException(message='Required field entityType is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(updateEntityType_args)
updateEntityType_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'entityType', [airavata.model.sharing.ttypes.EntityType, None], None, ),  # 1
)


class updateEntityType_result(object):
    """
    Attributes:
     - success
     - sre

    """
    thrift_spec: typing.Any = None


    def __init__(self, success: typing.Optional[bool] = None, sre: typing.Optional[airavata.model.sharing.ttypes.SharingRegistryException] = None,):
        self.success: typing.Optional[bool] = success
        self.sre: typing.Optional[airavata.model.sharing.ttypes.SharingRegistryException] = sre

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.BOOL:
                    self.success = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.sre = airavata.model.sharing.ttypes.SharingRegistryException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('updateEntityType_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.BOOL, 0)
            oprot.writeBool(self.success)
            oprot.writeFieldEnd()
        if self.sre is not None:
            oprot.writeFieldBegin('sre', TType.STRUCT, 1)
            self.sre.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(updateEntityType_result)
updateEntityType_result.thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'sre', [airavata.model.sharing.ttypes.SharingRegistryException, None], None, ),  # 1
)


class isEntityTypeExists_args(object):
    """
    Attributes:
     - domainId
     - entityTypeId

    """
    thrift_spec: typing.Any = None


    def __init__(self, domainId: str = None, entityTypeId: str = None,):
        self.domainId: str = domainId
        self.entityTypeId: str = entityTypeId

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.domainId = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.entityTypeId = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('isEntityTypeExists_args')
        if self.domainId is not None:
            oprot.writeFieldBegin('domainId', TType.STRING, 1)
            oprot.writeString(self.domainId.encode('utf-8') if sys.version_info[0] == 2 else self.domainId)
            oprot.writeFieldEnd()
        if self.entityTypeId is not None:
            oprot.writeFieldBegin('entityTypeId', TType.STRING, 2)
            oprot.writeString(self.entityTypeId.encode('utf-8') if sys.version_info[0] == 2 else self.entityTypeId)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.domainId is None:
            raise TProtocolException(message='Required field domainId is unset!')
        if self.entityTypeId is None:
            raise TProtocolException(message='Required field entityTypeId is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(isEntityTypeExists_args)
isEntityTypeExists_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'domainId', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'entityTypeId', 'UTF8', None, ),  # 2
)


class isEntityTypeExists_result(object):
    """
    Attributes:
     - success
     - sre

    """
    thrift_spec: typing.Any = None


    def __init__(self, success: typing.Optional[bool] = None, sre: typing.Optional[airavata.model.sharing.ttypes.SharingRegistryException] = None,):
        self.success: typing.Optional[bool] = success
        self.sre: typing.Optional[airavata.model.sharing.ttypes.SharingRegistryException] = sre

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.BOOL:
                    self.success = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.sre = airavata.model.sharing.ttypes.SharingRegistryException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('isEntityTypeExists_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.BOOL, 0)
            oprot.writeBool(self.success)
            oprot.writeFieldEnd()
        if self.sre is not None:
            oprot.writeFieldBegin('sre', TType.STRUCT, 1)
            self.sre.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(isEntityTypeExists_result)
isEntityTypeExists_result.thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'sre', [airavata.model.sharing.ttypes.SharingRegistryException, None], None, ),  # 1
)


class deleteEntityType_args(object):
    """
    Attributes:
     - domainId
     - entityTypeId

    """
    thrift_spec: typing.Any = None


    def __init__(self, domainId: str = None, entityTypeId: str = None,):
        self.domainId: str = domainId
        self.entityTypeId: str = entityTypeId

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.domainId = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.entityTypeId = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('deleteEntityType_args')
        if self.domainId is not None:
            oprot.writeFieldBegin('domainId', TType.STRING, 1)
            oprot.writeString(self.domainId.encode('utf-8') if sys.version_info[0] == 2 else self.domainId)
            oprot.writeFieldEnd()
        if self.entityTypeId is not None:
            oprot.writeFieldBegin('entityTypeId', TType.STRING, 2)
            oprot.writeString(self.entityTypeId.encode('utf-8') if sys.version_info[0] == 2 else self.entityTypeId)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.domainId is None:
            raise TProtocolException(message='Required field domainId is unset!')
        if self.entityTypeId is None:
            raise TProtocolException(message='Required field entityTypeId is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(deleteEntityType_args)
deleteEntityType_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'domainId', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'entityTypeId', 'UTF8', None, ),  # 2
)


class deleteEntityType_result(object):
    """
    Attributes:
     - success
     - sre

    """
    thrift_spec: typing.Any = None


    def __init__(self, success: typing.Optional[bool] = None, sre: typing.Optional[airavata.model.sharing.ttypes.SharingRegistryException] = None,):
        self.success: typing.Optional[bool] = success
        self.sre: typing.Optional[airavata.model.sharing.ttypes.SharingRegistryException] = sre

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.BOOL:
                    self.success = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.sre = airavata.model.sharing.ttypes.SharingRegistryException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('deleteEntityType_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.BOOL, 0)
            oprot.writeBool(self.success)
            oprot.writeFieldEnd()
        if self.sre is not None:
            oprot.writeFieldBegin('sre', TType.STRUCT, 1)
            self.sre.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(deleteEntityType_result)
deleteEntityType_result.thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'sre', [airavata.model.sharing.ttypes.SharingRegistryException, None], None, ),  # 1
)


class getEntityType_args(object):
    """
    Attributes:
     - domainId
     - entityTypeId

    """
    thrift_spec: typing.Any = None


    def __init__(self, domainId: str = None, entityTypeId: str = None,):
        self.domainId: str = domainId
        self.entityTypeId: str = entityTypeId

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.domainId = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.entityTypeId = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getEntityType_args')
        if self.domainId is not None:
            oprot.writeFieldBegin('domainId', TType.STRING, 1)
            oprot.writeString(self.domainId.encode('utf-8') if sys.version_info[0] == 2 else self.domainId)
            oprot.writeFieldEnd()
        if self.entityTypeId is not None:
            oprot.writeFieldBegin('entityTypeId', TType.STRING, 2)
            oprot.writeString(self.entityTypeId.encode('utf-8') if sys.version_info[0] == 2 else self.entityTypeId)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.domainId is None:
            raise TProtocolException(message='Required field domainId is unset!')
        if self.entityTypeId is None:
            raise TProtocolException(message='Required field entityTypeId is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getEntityType_args)
getEntityType_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'domainId', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'entityTypeId', 'UTF8', None, ),  # 2
)


class getEntityType_result(object):
    """
    Attributes:
     - success
     - sre

    """
    thrift_spec: typing.Any = None


    def __init__(self, success: typing.Optional[airavata.model.sharing.ttypes.EntityType] = None, sre: typing.Optional[airavata.model.sharing.ttypes.SharingRegistryException] = None,):
        self.success: typing.Optional[airavata.model.sharing.ttypes.EntityType] = success
        self.sre: typing.Optional[airavata.model.sharing.ttypes.SharingRegistryException] = sre

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = airavata.model.sharing.ttypes.EntityType()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.sre = airavata.model.sharing.ttypes.SharingRegistryException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getEntityType_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.sre is not None:
            oprot.writeFieldBegin('sre', TType.STRUCT, 1)
            self.sre.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getEntityType_result)
getEntityType_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [airavata.model.sharing.ttypes.EntityType, None], None, ),  # 0
    (1, TType.STRUCT, 'sre', [airavata.model.sharing.ttypes.SharingRegistryException, None], None, ),  # 1
)


class getEntityTypes_args(object):
    """
    Attributes:
     - domainId
     - offset
     - limit

    """
    thrift_spec: typing.Any = None


    def __init__(self, domainId: str = None, offset: int = None, limit: int = None,):
        self.domainId: str = domainId
        self.offset: int = offset
        self.limit: int = limit

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.domainId = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.offset = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.limit = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getEntityTypes_args')
        if self.domainId is not None:
            oprot.writeFieldBegin('domainId', TType.STRING, 1)
            oprot.writeString(self.domainId.encode('utf-8') if sys.version_info[0] == 2 else self.domainId)
            oprot.writeFieldEnd()
        if self.offset is not None:
            oprot.writeFieldBegin('offset', TType.I32, 2)
            oprot.writeI32(self.offset)
            oprot.writeFieldEnd()
        if self.limit is not None:
            oprot.writeFieldBegin('limit', TType.I32, 3)
            oprot.writeI32(self.limit)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.domainId is None:
            raise TProtocolException(message='Required field domainId is unset!')
        if self.offset is None:
            raise TProtocolException(message='Required field offset is unset!')
        if self.limit is None:
            raise TProtocolException(message='Required field limit is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getEntityTypes_args)
getEntityTypes_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'domainId', 'UTF8', None, ),  # 1
    (2, TType.I32, 'offset', None, None, ),  # 2
    (3, TType.I32, 'limit', None, None, ),  # 3
)


class getEntityTypes_result(object):
    """
    Attributes:
     - success
     - sre

    """
    thrift_spec: typing.Any = None


    def __init__(self, success: typing.Optional[list[airavata.model.sharing.ttypes.EntityType]] = None, sre: typing.Optional[airavata.model.sharing.ttypes.SharingRegistryException] = None,):
        self.success: typing.Optional[list[airavata.model.sharing.ttypes.EntityType]] = success
        self.sre: typing.Optional[airavata.model.sharing.ttypes.SharingRegistryException] = sre

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype80, _size77) = iprot.readListBegin()
                    for _i81 in range(_size77):
                        _elem82 = airavata.model.sharing.ttypes.EntityType()
                        _elem82.read(iprot)
                        self.success.append(_elem82)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.sre = airavata.model.sharing.ttypes.SharingRegistryException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getEntityTypes_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter83 in self.success:
                iter83.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.sre is not None:
            oprot.writeFieldBegin('sre', TType.STRUCT, 1)
            self.sre.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getEntityTypes_result)
getEntityTypes_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT, [airavata.model.sharing.ttypes.EntityType, None], False), None, ),  # 0
    (1, TType.STRUCT, 'sre', [airavata.model.sharing.ttypes.SharingRegistryException, None], None, ),  # 1
)


class createEntity_args(object):
    """
    Attributes:
     - entity

    """
    thrift_spec: typing.Any = None


    def __init__(self, entity: airavata.model.sharing.ttypes.Entity = None,):
        self.entity: airavata.model.sharing.ttypes.Entity = entity

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.entity = airavata.model.sharing.ttypes.Entity()
                    self.entity.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('createEntity_args')
        if self.entity is not None:
            oprot.writeFieldBegin('entity', TType.STRUCT, 1)
            self.entity.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.entity is None:
            raise TProtocolException(message='Required field entity is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(createEntity_args)
createEntity_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'entity', [airavata.model.sharing.ttypes.Entity, None], None, ),  # 1
)


class createEntity_result(object):
    """
    Attributes:
     - success
     - sre

    """
    thrift_spec: typing.Any = None


    def __init__(self, success: typing.Optional[str] = None, sre: typing.Optional[airavata.model.sharing.ttypes.SharingRegistryException] = None,):
        self.success: typing.Optional[str] = success
        self.sre: typing.Optional[airavata.model.sharing.ttypes.SharingRegistryException] = sre

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRING:
                    self.success = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.sre = airavata.model.sharing.ttypes.SharingRegistryException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('createEntity_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRING, 0)
            oprot.writeString(self.success.encode('utf-8') if sys.version_info[0] == 2 else self.success)
            oprot.writeFieldEnd()
        if self.sre is not None:
            oprot.writeFieldBegin('sre', TType.STRUCT, 1)
            self.sre.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(createEntity_result)
createEntity_result.thrift_spec = (
    (0, TType.STRING, 'success', 'UTF8', None, ),  # 0
    (1, TType.STRUCT, 'sre', [airavata.model.sharing.ttypes.SharingRegistryException, None], None, ),  # 1
)


class updateEntity_args(object):
    """
    Attributes:
     - entity

    """
    thrift_spec: typing.Any = None


    def __init__(self, entity: airavata.model.sharing.ttypes.Entity = None,):
        self.entity: airavata.model.sharing.ttypes.Entity = entity

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.entity = airavata.model.sharing.ttypes.Entity()
                    self.entity.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('updateEntity_args')
        if self.entity is not None:
            oprot.writeFieldBegin('entity', TType.STRUCT, 1)
            self.entity.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.entity is None:
            raise TProtocolException(message='Required field entity is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(updateEntity_args)
updateEntity_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'entity', [airavata.model.sharing.ttypes.Entity, None], None, ),  # 1
)


class updateEntity_result(object):
    """
    Attributes:
     - success
     - sre

    """
    thrift_spec: typing.Any = None


    def __init__(self, success: typing.Optional[bool] = None, sre: typing.Optional[airavata.model.sharing.ttypes.SharingRegistryException] = None,):
        self.success: typing.Optional[bool] = success
        self.sre: typing.Optional[airavata.model.sharing.ttypes.SharingRegistryException] = sre

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.BOOL:
                    self.success = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.sre = airavata.model.sharing.ttypes.SharingRegistryException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('updateEntity_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.BOOL, 0)
            oprot.writeBool(self.success)
            oprot.writeFieldEnd()
        if self.sre is not None:
            oprot.writeFieldBegin('sre', TType.STRUCT, 1)
            self.sre.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(updateEntity_result)
updateEntity_result.thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'sre', [airavata.model.sharing.ttypes.SharingRegistryException, None], None, ),  # 1
)


class isEntityExists_args(object):
    """
    Attributes:
     - domainId
     - entityId

    """
    thrift_spec: typing.Any = None


    def __init__(self, domainId: str = None, entityId: str = None,):
        self.domainId: str = domainId
        self.entityId: str = entityId

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.domainId = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.entityId = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('isEntityExists_args')
        if self.domainId is not None:
            oprot.writeFieldBegin('domainId', TType.STRING, 1)
            oprot.writeString(self.domainId.encode('utf-8') if sys.version_info[0] == 2 else self.domainId)
            oprot.writeFieldEnd()
        if self.entityId is not None:
            oprot.writeFieldBegin('entityId', TType.STRING, 2)
            oprot.writeString(self.entityId.encode('utf-8') if sys.version_info[0] == 2 else self.entityId)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.domainId is None:
            raise TProtocolException(message='Required field domainId is unset!')
        if self.entityId is None:
            raise TProtocolException(message='Required field entityId is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(isEntityExists_args)
isEntityExists_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'domainId', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'entityId', 'UTF8', None, ),  # 2
)


class isEntityExists_result(object):
    """
    Attributes:
     - success
     - sre

    """
    thrift_spec: typing.Any = None


    def __init__(self, success: typing.Optional[bool] = None, sre: typing.Optional[airavata.model.sharing.ttypes.SharingRegistryException] = None,):
        self.success: typing.Optional[bool] = success
        self.sre: typing.Optional[airavata.model.sharing.ttypes.SharingRegistryException] = sre

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.BOOL:
                    self.success = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.sre = airavata.model.sharing.ttypes.SharingRegistryException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('isEntityExists_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.BOOL, 0)
            oprot.writeBool(self.success)
            oprot.writeFieldEnd()
        if self.sre is not None:
            oprot.writeFieldBegin('sre', TType.STRUCT, 1)
            self.sre.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(isEntityExists_result)
isEntityExists_result.thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'sre', [airavata.model.sharing.ttypes.SharingRegistryException, None], None, ),  # 1
)


class deleteEntity_args(object):
    """
    Attributes:
     - domainId
     - entityId

    """
    thrift_spec: typing.Any = None


    def __init__(self, domainId: str = None, entityId: str = None,):
        self.domainId: str = domainId
        self.entityId: str = entityId

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.domainId = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.entityId = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('deleteEntity_args')
        if self.domainId is not None:
            oprot.writeFieldBegin('domainId', TType.STRING, 1)
            oprot.writeString(self.domainId.encode('utf-8') if sys.version_info[0] == 2 else self.domainId)
            oprot.writeFieldEnd()
        if self.entityId is not None:
            oprot.writeFieldBegin('entityId', TType.STRING, 2)
            oprot.writeString(self.entityId.encode('utf-8') if sys.version_info[0] == 2 else self.entityId)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.domainId is None:
            raise TProtocolException(message='Required field domainId is unset!')
        if self.entityId is None:
            raise TProtocolException(message='Required field entityId is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(deleteEntity_args)
deleteEntity_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'domainId', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'entityId', 'UTF8', None, ),  # 2
)


class deleteEntity_result(object):
    """
    Attributes:
     - success
     - sre

    """
    thrift_spec: typing.Any = None


    def __init__(self, success: typing.Optional[bool] = None, sre: typing.Optional[airavata.model.sharing.ttypes.SharingRegistryException] = None,):
        self.success: typing.Optional[bool] = success
        self.sre: typing.Optional[airavata.model.sharing.ttypes.SharingRegistryException] = sre

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.BOOL:
                    self.success = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.sre = airavata.model.sharing.ttypes.SharingRegistryException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('deleteEntity_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.BOOL, 0)
            oprot.writeBool(self.success)
            oprot.writeFieldEnd()
        if self.sre is not None:
            oprot.writeFieldBegin('sre', TType.STRUCT, 1)
            self.sre.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(deleteEntity_result)
deleteEntity_result.thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'sre', [airavata.model.sharing.ttypes.SharingRegistryException, None], None, ),  # 1
)


class getEntity_args(object):
    """
    Attributes:
     - domainId
     - entityId

    """
    thrift_spec: typing.Any = None


    def __init__(self, domainId: str = None, entityId: str = None,):
        self.domainId: str = domainId
        self.entityId: str = entityId

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.domainId = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.entityId = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getEntity_args')
        if self.domainId is not None:
            oprot.writeFieldBegin('domainId', TType.STRING, 1)
            oprot.writeString(self.domainId.encode('utf-8') if sys.version_info[0] == 2 else self.domainId)
            oprot.writeFieldEnd()
        if self.entityId is not None:
            oprot.writeFieldBegin('entityId', TType.STRING, 2)
            oprot.writeString(self.entityId.encode('utf-8') if sys.version_info[0] == 2 else self.entityId)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.domainId is None:
            raise TProtocolException(message='Required field domainId is unset!')
        if self.entityId is None:
            raise TProtocolException(message='Required field entityId is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getEntity_args)
getEntity_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'domainId', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'entityId', 'UTF8', None, ),  # 2
)


class getEntity_result(object):
    """
    Attributes:
     - success
     - sre

    """
    thrift_spec: typing.Any = None


    def __init__(self, success: typing.Optional[airavata.model.sharing.ttypes.Entity] = None, sre: typing.Optional[airavata.model.sharing.ttypes.SharingRegistryException] = None,):
        self.success: typing.Optional[airavata.model.sharing.ttypes.Entity] = success
        self.sre: typing.Optional[airavata.model.sharing.ttypes.SharingRegistryException] = sre

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = airavata.model.sharing.ttypes.Entity()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.sre = airavata.model.sharing.ttypes.SharingRegistryException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getEntity_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.sre is not None:
            oprot.writeFieldBegin('sre', TType.STRUCT, 1)
            self.sre.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getEntity_result)
getEntity_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [airavata.model.sharing.ttypes.Entity, None], None, ),  # 0
    (1, TType.STRUCT, 'sre', [airavata.model.sharing.ttypes.SharingRegistryException, None], None, ),  # 1
)


class searchEntities_args(object):
    """
    Attributes:
     - domainId
     - userId
     - filters
     - offset
     - limit

    """
    thrift_spec: typing.Any = None


    def __init__(self, domainId: str = None, userId: str = None, filters: list[airavata.model.sharing.ttypes.SearchCriteria] = None, offset: int = None, limit: int = None,):
        self.domainId: str = domainId
        self.userId: str = userId
        self.filters: list[airavata.model.sharing.ttypes.SearchCriteria] = filters
        self.offset: int = offset
        self.limit: int = limit

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.domainId = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.userId = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.filters = []
                    (_etype87, _size84) = iprot.readListBegin()
                    for _i88 in range(_size84):
                        _elem89 = airavata.model.sharing.ttypes.SearchCriteria()
                        _elem89.read(iprot)
                        self.filters.append(_elem89)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I32:
                    self.offset = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.I32:
                    self.limit = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('searchEntities_args')
        if self.domainId is not None:
            oprot.writeFieldBegin('domainId', TType.STRING, 1)
            oprot.writeString(self.domainId.encode('utf-8') if sys.version_info[0] == 2 else self.domainId)
            oprot.writeFieldEnd()
        if self.userId is not None:
            oprot.writeFieldBegin('userId', TType.STRING, 2)
            oprot.writeString(self.userId.encode('utf-8') if sys.version_info[0] == 2 else self.userId)
            oprot.writeFieldEnd()
        if self.filters is not None:
            oprot.writeFieldBegin('filters', TType.LIST, 3)
            oprot.writeListBegin(TType.STRUCT, len(self.filters))
            for iter90 in self.filters:
                iter90.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.offset is not None:
            oprot.writeFieldBegin('offset', TType.I32, 4)
            oprot.writeI32(self.offset)
            oprot.writeFieldEnd()
        if self.limit is not None:
            oprot.writeFieldBegin('limit', TType.I32, 5)
            oprot.writeI32(self.limit)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.domainId is None:
            raise TProtocolException(message='Required field domainId is unset!')
        if self.userId is None:
            raise TProtocolException(message='Required field userId is unset!')
        if self.filters is None:
            raise TProtocolException(message='Required field filters is unset!')
        if self.offset is None:
            raise TProtocolException(message='Required field offset is unset!')
        if self.limit is None:
            raise TProtocolException(message='Required field limit is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(searchEntities_args)
searchEntities_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'domainId', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'userId', 'UTF8', None, ),  # 2
    (3, TType.LIST, 'filters', (TType.STRUCT, [airavata.model.sharing.ttypes.SearchCriteria, None], False), None, ),  # 3
    (4, TType.I32, 'offset', None, None, ),  # 4
    (5, TType.I32, 'limit', None, None, ),  # 5
)


class searchEntities_result(object):
    """
    Attributes:
     - success
     - sre

    """
    thrift_spec: typing.Any = None


    def __init__(self, success: typing.Optional[list[airavata.model.sharing.ttypes.Entity]] = None, sre: typing.Optional[airavata.model.sharing.ttypes.SharingRegistryException] = None,):
        self.success: typing.Optional[list[airavata.model.sharing.ttypes.Entity]] = success
        self.sre: typing.Optional[airavata.model.sharing.ttypes.SharingRegistryException] = sre

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype94, _size91) = iprot.readListBegin()
                    for _i95 in range(_size91):
                        _elem96 = airavata.model.sharing.ttypes.Entity()
                        _elem96.read(iprot)
                        self.success.append(_elem96)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.sre = airavata.model.sharing.ttypes.SharingRegistryException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('searchEntities_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter97 in self.success:
                iter97.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.sre is not None:
            oprot.writeFieldBegin('sre', TType.STRUCT, 1)
            self.sre.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(searchEntities_result)
searchEntities_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT, [airavata.model.sharing.ttypes.Entity, None], False), None, ),  # 0
    (1, TType.STRUCT, 'sre', [airavata.model.sharing.ttypes.SharingRegistryException, None], None, ),  # 1
)


class getListOfSharedUsers_args(object):
    """
    Attributes:
     - domainId
     - entityId
     - permissionTypeId

    """
    thrift_spec: typing.Any = None


    def __init__(self, domainId: str = None, entityId: str = None, permissionTypeId: str = None,):
        self.domainId: str = domainId
        self.entityId: str = entityId
        self.permissionTypeId: str = permissionTypeId

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.domainId = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.entityId = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.permissionTypeId = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getListOfSharedUsers_args')
        if self.domainId is not None:
            oprot.writeFieldBegin('domainId', TType.STRING, 1)
            oprot.writeString(self.domainId.encode('utf-8') if sys.version_info[0] == 2 else self.domainId)
            oprot.writeFieldEnd()
        if self.entityId is not None:
            oprot.writeFieldBegin('entityId', TType.STRING, 2)
            oprot.writeString(self.entityId.encode('utf-8') if sys.version_info[0] == 2 else self.entityId)
            oprot.writeFieldEnd()
        if self.permissionTypeId is not None:
            oprot.writeFieldBegin('permissionTypeId', TType.STRING, 3)
            oprot.writeString(self.permissionTypeId.encode('utf-8') if sys.version_info[0] == 2 else self.permissionTypeId)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.domainId is None:
            raise TProtocolException(message='Required field domainId is unset!')
        if self.entityId is None:
            raise TProtocolException(message='Required field entityId is unset!')
        if self.permissionTypeId is None:
            raise TProtocolException(message='Required field permissionTypeId is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getListOfSharedUsers_args)
getListOfSharedUsers_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'domainId', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'entityId', 'UTF8', None, ),  # 2
    (3, TType.STRING, 'permissionTypeId', 'UTF8', None, ),  # 3
)


class getListOfSharedUsers_result(object):
    """
    Attributes:
     - success
     - sre

    """
    thrift_spec: typing.Any = None


    def __init__(self, success: typing.Optional[list[airavata.model.sharing.ttypes.User]] = None, sre: typing.Optional[airavata.model.sharing.ttypes.SharingRegistryException] = None,):
        self.success: typing.Optional[list[airavata.model.sharing.ttypes.User]] = success
        self.sre: typing.Optional[airavata.model.sharing.ttypes.SharingRegistryException] = sre

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype101, _size98) = iprot.readListBegin()
                    for _i102 in range(_size98):
                        _elem103 = airavata.model.sharing.ttypes.User()
                        _elem103.read(iprot)
                        self.success.append(_elem103)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.sre = airavata.model.sharing.ttypes.SharingRegistryException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getListOfSharedUsers_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter104 in self.success:
                iter104.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.sre is not None:
            oprot.writeFieldBegin('sre', TType.STRUCT, 1)
            self.sre.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getListOfSharedUsers_result)
getListOfSharedUsers_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT, [airavata.model.sharing.ttypes.User, None], False), None, ),  # 0
    (1, TType.STRUCT, 'sre', [airavata.model.sharing.ttypes.SharingRegistryException, None], None, ),  # 1
)


class getListOfDirectlySharedUsers_args(object):
    """
    Attributes:
     - domainId
     - entityId
     - permissionTypeId

    """
    thrift_spec: typing.Any = None


    def __init__(self, domainId: str = None, entityId: str = None, permissionTypeId: str = None,):
        self.domainId: str = domainId
        self.entityId: str = entityId
        self.permissionTypeId: str = permissionTypeId

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.domainId = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.entityId = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.permissionTypeId = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getListOfDirectlySharedUsers_args')
        if self.domainId is not None:
            oprot.writeFieldBegin('domainId', TType.STRING, 1)
            oprot.writeString(self.domainId.encode('utf-8') if sys.version_info[0] == 2 else self.domainId)
            oprot.writeFieldEnd()
        if self.entityId is not None:
            oprot.writeFieldBegin('entityId', TType.STRING, 2)
            oprot.writeString(self.entityId.encode('utf-8') if sys.version_info[0] == 2 else self.entityId)
            oprot.writeFieldEnd()
        if self.permissionTypeId is not None:
            oprot.writeFieldBegin('permissionTypeId', TType.STRING, 3)
            oprot.writeString(self.permissionTypeId.encode('utf-8') if sys.version_info[0] == 2 else self.permissionTypeId)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.domainId is None:
            raise TProtocolException(message='Required field domainId is unset!')
        if self.entityId is None:
            raise TProtocolException(message='Required field entityId is unset!')
        if self.permissionTypeId is None:
            raise TProtocolException(message='Required field permissionTypeId is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getListOfDirectlySharedUsers_args)
getListOfDirectlySharedUsers_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'domainId', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'entityId', 'UTF8', None, ),  # 2
    (3, TType.STRING, 'permissionTypeId', 'UTF8', None, ),  # 3
)


class getListOfDirectlySharedUsers_result(object):
    """
    Attributes:
     - success
     - sre

    """
    thrift_spec: typing.Any = None


    def __init__(self, success: typing.Optional[list[airavata.model.sharing.ttypes.User]] = None, sre: typing.Optional[airavata.model.sharing.ttypes.SharingRegistryException] = None,):
        self.success: typing.Optional[list[airavata.model.sharing.ttypes.User]] = success
        self.sre: typing.Optional[airavata.model.sharing.ttypes.SharingRegistryException] = sre

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype108, _size105) = iprot.readListBegin()
                    for _i109 in range(_size105):
                        _elem110 = airavata.model.sharing.ttypes.User()
                        _elem110.read(iprot)
                        self.success.append(_elem110)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.sre = airavata.model.sharing.ttypes.SharingRegistryException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getListOfDirectlySharedUsers_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter111 in self.success:
                iter111.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.sre is not None:
            oprot.writeFieldBegin('sre', TType.STRUCT, 1)
            self.sre.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getListOfDirectlySharedUsers_result)
getListOfDirectlySharedUsers_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT, [airavata.model.sharing.ttypes.User, None], False), None, ),  # 0
    (1, TType.STRUCT, 'sre', [airavata.model.sharing.ttypes.SharingRegistryException, None], None, ),  # 1
)


class getListOfSharedGroups_args(object):
    """
    Attributes:
     - domainId
     - entityId
     - permissionTypeId

    """
    thrift_spec: typing.Any = None


    def __init__(self, domainId: str = None, entityId: str = None, permissionTypeId: str = None,):
        self.domainId: str = domainId
        self.entityId: str = entityId
        self.permissionTypeId: str = permissionTypeId

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.domainId = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.entityId = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.permissionTypeId = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getListOfSharedGroups_args')
        if self.domainId is not None:
            oprot.writeFieldBegin('domainId', TType.STRING, 1)
            oprot.writeString(self.domainId.encode('utf-8') if sys.version_info[0] == 2 else self.domainId)
            oprot.writeFieldEnd()
        if self.entityId is not None:
            oprot.writeFieldBegin('entityId', TType.STRING, 2)
            oprot.writeString(self.entityId.encode('utf-8') if sys.version_info[0] == 2 else self.entityId)
            oprot.writeFieldEnd()
        if self.permissionTypeId is not None:
            oprot.writeFieldBegin('permissionTypeId', TType.STRING, 3)
            oprot.writeString(self.permissionTypeId.encode('utf-8') if sys.version_info[0] == 2 else self.permissionTypeId)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.domainId is None:
            raise TProtocolException(message='Required field domainId is unset!')
        if self.entityId is None:
            raise TProtocolException(message='Required field entityId is unset!')
        if self.permissionTypeId is None:
            raise TProtocolException(message='Required field permissionTypeId is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getListOfSharedGroups_args)
getListOfSharedGroups_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'domainId', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'entityId', 'UTF8', None, ),  # 2
    (3, TType.STRING, 'permissionTypeId', 'UTF8', None, ),  # 3
)


class getListOfSharedGroups_result(object):
    """
    Attributes:
     - success
     - sre

    """
    thrift_spec: typing.Any = None


    def __init__(self, success: typing.Optional[list[airavata.model.sharing.ttypes.UserGroup]] = None, sre: typing.Optional[airavata.model.sharing.ttypes.SharingRegistryException] = None,):
        self.success: typing.Optional[list[airavata.model.sharing.ttypes.UserGroup]] = success
        self.sre: typing.Optional[airavata.model.sharing.ttypes.SharingRegistryException] = sre

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype115, _size112) = iprot.readListBegin()
                    for _i116 in range(_size112):
                        _elem117 = airavata.model.sharing.ttypes.UserGroup()
                        _elem117.read(iprot)
                        self.success.append(_elem117)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.sre = airavata.model.sharing.ttypes.SharingRegistryException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getListOfSharedGroups_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter118 in self.success:
                iter118.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.sre is not None:
            oprot.writeFieldBegin('sre', TType.STRUCT, 1)
            self.sre.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getListOfSharedGroups_result)
getListOfSharedGroups_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT, [airavata.model.sharing.ttypes.UserGroup, None], False), None, ),  # 0
    (1, TType.STRUCT, 'sre', [airavata.model.sharing.ttypes.SharingRegistryException, None], None, ),  # 1
)


class getListOfDirectlySharedGroups_args(object):
    """
    Attributes:
     - domainId
     - entityId
     - permissionTypeId

    """
    thrift_spec: typing.Any = None


    def __init__(self, domainId: str = None, entityId: str = None, permissionTypeId: str = None,):
        self.domainId: str = domainId
        self.entityId: str = entityId
        self.permissionTypeId: str = permissionTypeId

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.domainId = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.entityId = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.permissionTypeId = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getListOfDirectlySharedGroups_args')
        if self.domainId is not None:
            oprot.writeFieldBegin('domainId', TType.STRING, 1)
            oprot.writeString(self.domainId.encode('utf-8') if sys.version_info[0] == 2 else self.domainId)
            oprot.writeFieldEnd()
        if self.entityId is not None:
            oprot.writeFieldBegin('entityId', TType.STRING, 2)
            oprot.writeString(self.entityId.encode('utf-8') if sys.version_info[0] == 2 else self.entityId)
            oprot.writeFieldEnd()
        if self.permissionTypeId is not None:
            oprot.writeFieldBegin('permissionTypeId', TType.STRING, 3)
            oprot.writeString(self.permissionTypeId.encode('utf-8') if sys.version_info[0] == 2 else self.permissionTypeId)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.domainId is None:
            raise TProtocolException(message='Required field domainId is unset!')
        if self.entityId is None:
            raise TProtocolException(message='Required field entityId is unset!')
        if self.permissionTypeId is None:
            raise TProtocolException(message='Required field permissionTypeId is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getListOfDirectlySharedGroups_args)
getListOfDirectlySharedGroups_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'domainId', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'entityId', 'UTF8', None, ),  # 2
    (3, TType.STRING, 'permissionTypeId', 'UTF8', None, ),  # 3
)


class getListOfDirectlySharedGroups_result(object):
    """
    Attributes:
     - success
     - sre

    """
    thrift_spec: typing.Any = None


    def __init__(self, success: typing.Optional[list[airavata.model.sharing.ttypes.UserGroup]] = None, sre: typing.Optional[airavata.model.sharing.ttypes.SharingRegistryException] = None,):
        self.success: typing.Optional[list[airavata.model.sharing.ttypes.UserGroup]] = success
        self.sre: typing.Optional[airavata.model.sharing.ttypes.SharingRegistryException] = sre

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype122, _size119) = iprot.readListBegin()
                    for _i123 in range(_size119):
                        _elem124 = airavata.model.sharing.ttypes.UserGroup()
                        _elem124.read(iprot)
                        self.success.append(_elem124)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.sre = airavata.model.sharing.ttypes.SharingRegistryException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getListOfDirectlySharedGroups_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter125 in self.success:
                iter125.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.sre is not None:
            oprot.writeFieldBegin('sre', TType.STRUCT, 1)
            self.sre.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getListOfDirectlySharedGroups_result)
getListOfDirectlySharedGroups_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT, [airavata.model.sharing.ttypes.UserGroup, None], False), None, ),  # 0
    (1, TType.STRUCT, 'sre', [airavata.model.sharing.ttypes.SharingRegistryException, None], None, ),  # 1
)


class createPermissionType_args(object):
    """
    Attributes:
     - permissionType

    """
    thrift_spec: typing.Any = None


    def __init__(self, permissionType: airavata.model.sharing.ttypes.PermissionType = None,):
        self.permissionType: airavata.model.sharing.ttypes.PermissionType = permissionType

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.permissionType = airavata.model.sharing.ttypes.PermissionType()
                    self.permissionType.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('createPermissionType_args')
        if self.permissionType is not None:
            oprot.writeFieldBegin('permissionType', TType.STRUCT, 1)
            self.permissionType.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.permissionType is None:
            raise TProtocolException(message='Required field permissionType is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(createPermissionType_args)
createPermissionType_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'permissionType', [airavata.model.sharing.ttypes.PermissionType, None], None, ),  # 1
)


class createPermissionType_result(object):
    """
    Attributes:
     - success
     - sre
     - dee

    """
    thrift_spec: typing.Any = None


    def __init__(self, success: typing.Optional[str] = None, sre: typing.Optional[airavata.model.sharing.ttypes.SharingRegistryException] = None, dee: typing.Optional[airavata.model.sharing.ttypes.DuplicateEntryException] = None,):
        self.success: typing.Optional[str] = success
        self.sre: typing.Optional[airavata.model.sharing.ttypes.SharingRegistryException] = sre
        self.dee: typing.Optional[airavata.model.sharing.ttypes.DuplicateEntryException] = dee

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRING:
                    self.success = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.sre = airavata.model.sharing.ttypes.SharingRegistryException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.dee = airavata.model.sharing.ttypes.DuplicateEntryException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('createPermissionType_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRING, 0)
            oprot.writeString(self.success.encode('utf-8') if sys.version_info[0] == 2 else self.success)
            oprot.writeFieldEnd()
        if self.sre is not None:
            oprot.writeFieldBegin('sre', TType.STRUCT, 1)
            self.sre.write(oprot)
            oprot.writeFieldEnd()
        if self.dee is not None:
            oprot.writeFieldBegin('dee', TType.STRUCT, 2)
            self.dee.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(createPermissionType_result)
createPermissionType_result.thrift_spec = (
    (0, TType.STRING, 'success', 'UTF8', None, ),  # 0
    (1, TType.STRUCT, 'sre', [airavata.model.sharing.ttypes.SharingRegistryException, None], None, ),  # 1
    (2, TType.STRUCT, 'dee', [airavata.model.sharing.ttypes.DuplicateEntryException, None], None, ),  # 2
)


class updatePermissionType_args(object):
    """
    Attributes:
     - permissionType

    """
    thrift_spec: typing.Any = None


    def __init__(self, permissionType: airavata.model.sharing.ttypes.PermissionType = None,):
        self.permissionType: airavata.model.sharing.ttypes.PermissionType = permissionType

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.permissionType = airavata.model.sharing.ttypes.PermissionType()
                    self.permissionType.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('updatePermissionType_args')
        if self.permissionType is not None:
            oprot.writeFieldBegin('permissionType', TType.STRUCT, 1)
            self.permissionType.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.permissionType is None:
            raise TProtocolException(message='Required field permissionType is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(updatePermissionType_args)
updatePermissionType_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'permissionType', [airavata.model.sharing.ttypes.PermissionType, None], None, ),  # 1
)


class updatePermissionType_result(object):
    """
    Attributes:
     - success
     - sre

    """
    thrift_spec: typing.Any = None


    def __init__(self, success: typing.Optional[bool] = None, sre: typing.Optional[airavata.model.sharing.ttypes.SharingRegistryException] = None,):
        self.success: typing.Optional[bool] = success
        self.sre: typing.Optional[airavata.model.sharing.ttypes.SharingRegistryException] = sre

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.BOOL:
                    self.success = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.sre = airavata.model.sharing.ttypes.SharingRegistryException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('updatePermissionType_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.BOOL, 0)
            oprot.writeBool(self.success)
            oprot.writeFieldEnd()
        if self.sre is not None:
            oprot.writeFieldBegin('sre', TType.STRUCT, 1)
            self.sre.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(updatePermissionType_result)
updatePermissionType_result.thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'sre', [airavata.model.sharing.ttypes.SharingRegistryException, None], None, ),  # 1
)


class isPermissionExists_args(object):
    """
    Attributes:
     - dimainId
     - permissionId

    """
    thrift_spec: typing.Any = None


    def __init__(self, dimainId: str = None, permissionId: str = None,):
        self.dimainId: str = dimainId
        self.permissionId: str = permissionId

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.dimainId = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.permissionId = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('isPermissionExists_args')
        if self.dimainId is not None:
            oprot.writeFieldBegin('dimainId', TType.STRING, 1)
            oprot.writeString(self.dimainId.encode('utf-8') if sys.version_info[0] == 2 else self.dimainId)
            oprot.writeFieldEnd()
        if self.permissionId is not None:
            oprot.writeFieldBegin('permissionId', TType.STRING, 2)
            oprot.writeString(self.permissionId.encode('utf-8') if sys.version_info[0] == 2 else self.permissionId)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.dimainId is None:
            raise TProtocolException(message='Required field dimainId is unset!')
        if self.permissionId is None:
            raise TProtocolException(message='Required field permissionId is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(isPermissionExists_args)
isPermissionExists_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'dimainId', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'permissionId', 'UTF8', None, ),  # 2
)


class isPermissionExists_result(object):
    """
    Attributes:
     - success
     - sre

    """
    thrift_spec: typing.Any = None


    def __init__(self, success: typing.Optional[bool] = None, sre: typing.Optional[airavata.model.sharing.ttypes.SharingRegistryException] = None,):
        self.success: typing.Optional[bool] = success
        self.sre: typing.Optional[airavata.model.sharing.ttypes.SharingRegistryException] = sre

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.BOOL:
                    self.success = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.sre = airavata.model.sharing.ttypes.SharingRegistryException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('isPermissionExists_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.BOOL, 0)
            oprot.writeBool(self.success)
            oprot.writeFieldEnd()
        if self.sre is not None:
            oprot.writeFieldBegin('sre', TType.STRUCT, 1)
            self.sre.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(isPermissionExists_result)
isPermissionExists_result.thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'sre', [airavata.model.sharing.ttypes.SharingRegistryException, None], None, ),  # 1
)


class deletePermissionType_args(object):
    """
    Attributes:
     - domainId
     - permissionTypeId

    """
    thrift_spec: typing.Any = None


    def __init__(self, domainId: str = None, permissionTypeId: str = None,):
        self.domainId: str = domainId
        self.permissionTypeId: str = permissionTypeId

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.domainId = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.permissionTypeId = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('deletePermissionType_args')
        if self.domainId is not None:
            oprot.writeFieldBegin('domainId', TType.STRING, 1)
            oprot.writeString(self.domainId.encode('utf-8') if sys.version_info[0] == 2 else self.domainId)
            oprot.writeFieldEnd()
        if self.permissionTypeId is not None:
            oprot.writeFieldBegin('permissionTypeId', TType.STRING, 2)
            oprot.writeString(self.permissionTypeId.encode('utf-8') if sys.version_info[0] == 2 else self.permissionTypeId)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.domainId is None:
            raise TProtocolException(message='Required field domainId is unset!')
        if self.permissionTypeId is None:
            raise TProtocolException(message='Required field permissionTypeId is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(deletePermissionType_args)
deletePermissionType_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'domainId', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'permissionTypeId', 'UTF8', None, ),  # 2
)


class deletePermissionType_result(object):
    """
    Attributes:
     - success
     - sre

    """
    thrift_spec: typing.Any = None


    def __init__(self, success: typing.Optional[bool] = None, sre: typing.Optional[airavata.model.sharing.ttypes.SharingRegistryException] = None,):
        self.success: typing.Optional[bool] = success
        self.sre: typing.Optional[airavata.model.sharing.ttypes.SharingRegistryException] = sre

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.BOOL:
                    self.success = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.sre = airavata.model.sharing.ttypes.SharingRegistryException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('deletePermissionType_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.BOOL, 0)
            oprot.writeBool(self.success)
            oprot.writeFieldEnd()
        if self.sre is not None:
            oprot.writeFieldBegin('sre', TType.STRUCT, 1)
            self.sre.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(deletePermissionType_result)
deletePermissionType_result.thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'sre', [airavata.model.sharing.ttypes.SharingRegistryException, None], None, ),  # 1
)


class getPermissionType_args(object):
    """
    Attributes:
     - domainId
     - permissionTypeId

    """
    thrift_spec: typing.Any = None


    def __init__(self, domainId: str = None, permissionTypeId: str = None,):
        self.domainId: str = domainId
        self.permissionTypeId: str = permissionTypeId

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.domainId = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.permissionTypeId = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getPermissionType_args')
        if self.domainId is not None:
            oprot.writeFieldBegin('domainId', TType.STRING, 1)
            oprot.writeString(self.domainId.encode('utf-8') if sys.version_info[0] == 2 else self.domainId)
            oprot.writeFieldEnd()
        if self.permissionTypeId is not None:
            oprot.writeFieldBegin('permissionTypeId', TType.STRING, 2)
            oprot.writeString(self.permissionTypeId.encode('utf-8') if sys.version_info[0] == 2 else self.permissionTypeId)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.domainId is None:
            raise TProtocolException(message='Required field domainId is unset!')
        if self.permissionTypeId is None:
            raise TProtocolException(message='Required field permissionTypeId is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getPermissionType_args)
getPermissionType_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'domainId', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'permissionTypeId', 'UTF8', None, ),  # 2
)


class getPermissionType_result(object):
    """
    Attributes:
     - success
     - sre

    """
    thrift_spec: typing.Any = None


    def __init__(self, success: typing.Optional[airavata.model.sharing.ttypes.PermissionType] = None, sre: typing.Optional[airavata.model.sharing.ttypes.SharingRegistryException] = None,):
        self.success: typing.Optional[airavata.model.sharing.ttypes.PermissionType] = success
        self.sre: typing.Optional[airavata.model.sharing.ttypes.SharingRegistryException] = sre

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = airavata.model.sharing.ttypes.PermissionType()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.sre = airavata.model.sharing.ttypes.SharingRegistryException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getPermissionType_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.sre is not None:
            oprot.writeFieldBegin('sre', TType.STRUCT, 1)
            self.sre.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getPermissionType_result)
getPermissionType_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [airavata.model.sharing.ttypes.PermissionType, None], None, ),  # 0
    (1, TType.STRUCT, 'sre', [airavata.model.sharing.ttypes.SharingRegistryException, None], None, ),  # 1
)


class getPermissionTypes_args(object):
    """
    Attributes:
     - domainId
     - offset
     - limit

    """
    thrift_spec: typing.Any = None


    def __init__(self, domainId: str = None, offset: int = None, limit: int = None,):
        self.domainId: str = domainId
        self.offset: int = offset
        self.limit: int = limit

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.domainId = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.offset = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.limit = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getPermissionTypes_args')
        if self.domainId is not None:
            oprot.writeFieldBegin('domainId', TType.STRING, 1)
            oprot.writeString(self.domainId.encode('utf-8') if sys.version_info[0] == 2 else self.domainId)
            oprot.writeFieldEnd()
        if self.offset is not None:
            oprot.writeFieldBegin('offset', TType.I32, 2)
            oprot.writeI32(self.offset)
            oprot.writeFieldEnd()
        if self.limit is not None:
            oprot.writeFieldBegin('limit', TType.I32, 3)
            oprot.writeI32(self.limit)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.domainId is None:
            raise TProtocolException(message='Required field domainId is unset!')
        if self.offset is None:
            raise TProtocolException(message='Required field offset is unset!')
        if self.limit is None:
            raise TProtocolException(message='Required field limit is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getPermissionTypes_args)
getPermissionTypes_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'domainId', 'UTF8', None, ),  # 1
    (2, TType.I32, 'offset', None, None, ),  # 2
    (3, TType.I32, 'limit', None, None, ),  # 3
)


class getPermissionTypes_result(object):
    """
    Attributes:
     - success
     - sre

    """
    thrift_spec: typing.Any = None


    def __init__(self, success: typing.Optional[list[airavata.model.sharing.ttypes.PermissionType]] = None, sre: typing.Optional[airavata.model.sharing.ttypes.SharingRegistryException] = None,):
        self.success: typing.Optional[list[airavata.model.sharing.ttypes.PermissionType]] = success
        self.sre: typing.Optional[airavata.model.sharing.ttypes.SharingRegistryException] = sre

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype129, _size126) = iprot.readListBegin()
                    for _i130 in range(_size126):
                        _elem131 = airavata.model.sharing.ttypes.PermissionType()
                        _elem131.read(iprot)
                        self.success.append(_elem131)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.sre = airavata.model.sharing.ttypes.SharingRegistryException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getPermissionTypes_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter132 in self.success:
                iter132.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.sre is not None:
            oprot.writeFieldBegin('sre', TType.STRUCT, 1)
            self.sre.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getPermissionTypes_result)
getPermissionTypes_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT, [airavata.model.sharing.ttypes.PermissionType, None], False), None, ),  # 0
    (1, TType.STRUCT, 'sre', [airavata.model.sharing.ttypes.SharingRegistryException, None], None, ),  # 1
)


class shareEntityWithUsers_args(object):
    """
    Attributes:
     - domainId
     - entityId
     - userList
     - permissionTypeId
     - cascadePermission

    """
    thrift_spec: typing.Any = None


    def __init__(self, domainId: str = None, entityId: str = None, userList: list[str] = None, permissionTypeId: str = None, cascadePermission: bool = None,):
        self.domainId: str = domainId
        self.entityId: str = entityId
        self.userList: list[str] = userList
        self.permissionTypeId: str = permissionTypeId
        self.cascadePermission: bool = cascadePermission

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.domainId = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.entityId = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.userList = []
                    (_etype136, _size133) = iprot.readListBegin()
                    for _i137 in range(_size133):
                        _elem138 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.userList.append(_elem138)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.permissionTypeId = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.BOOL:
                    self.cascadePermission = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('shareEntityWithUsers_args')
        if self.domainId is not None:
            oprot.writeFieldBegin('domainId', TType.STRING, 1)
            oprot.writeString(self.domainId.encode('utf-8') if sys.version_info[0] == 2 else self.domainId)
            oprot.writeFieldEnd()
        if self.entityId is not None:
            oprot.writeFieldBegin('entityId', TType.STRING, 2)
            oprot.writeString(self.entityId.encode('utf-8') if sys.version_info[0] == 2 else self.entityId)
            oprot.writeFieldEnd()
        if self.userList is not None:
            oprot.writeFieldBegin('userList', TType.LIST, 3)
            oprot.writeListBegin(TType.STRING, len(self.userList))
            for iter139 in self.userList:
                oprot.writeString(iter139.encode('utf-8') if sys.version_info[0] == 2 else iter139)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.permissionTypeId is not None:
            oprot.writeFieldBegin('permissionTypeId', TType.STRING, 4)
            oprot.writeString(self.permissionTypeId.encode('utf-8') if sys.version_info[0] == 2 else self.permissionTypeId)
            oprot.writeFieldEnd()
        if self.cascadePermission is not None:
            oprot.writeFieldBegin('cascadePermission', TType.BOOL, 5)
            oprot.writeBool(self.cascadePermission)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.domainId is None:
            raise TProtocolException(message='Required field domainId is unset!')
        if self.entityId is None:
            raise TProtocolException(message='Required field entityId is unset!')
        if self.userList is None:
            raise TProtocolException(message='Required field userList is unset!')
        if self.permissionTypeId is None:
            raise TProtocolException(message='Required field permissionTypeId is unset!')
        if self.cascadePermission is None:
            raise TProtocolException(message='Required field cascadePermission is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(shareEntityWithUsers_args)
shareEntityWithUsers_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'domainId', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'entityId', 'UTF8', None, ),  # 2
    (3, TType.LIST, 'userList', (TType.STRING, 'UTF8', False), None, ),  # 3
    (4, TType.STRING, 'permissionTypeId', 'UTF8', None, ),  # 4
    (5, TType.BOOL, 'cascadePermission', None, None, ),  # 5
)


class shareEntityWithUsers_result(object):
    """
    Attributes:
     - success
     - sre

    """
    thrift_spec: typing.Any = None


    def __init__(self, success: typing.Optional[bool] = None, sre: typing.Optional[airavata.model.sharing.ttypes.SharingRegistryException] = None,):
        self.success: typing.Optional[bool] = success
        self.sre: typing.Optional[airavata.model.sharing.ttypes.SharingRegistryException] = sre

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.BOOL:
                    self.success = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.sre = airavata.model.sharing.ttypes.SharingRegistryException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('shareEntityWithUsers_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.BOOL, 0)
            oprot.writeBool(self.success)
            oprot.writeFieldEnd()
        if self.sre is not None:
            oprot.writeFieldBegin('sre', TType.STRUCT, 1)
            self.sre.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(shareEntityWithUsers_result)
shareEntityWithUsers_result.thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'sre', [airavata.model.sharing.ttypes.SharingRegistryException, None], None, ),  # 1
)


class revokeEntitySharingFromUsers_args(object):
    """
    Attributes:
     - domainId
     - entityId
     - userList
     - permissionTypeId

    """
    thrift_spec: typing.Any = None


    def __init__(self, domainId: str = None, entityId: str = None, userList: list[str] = None, permissionTypeId: str = None,):
        self.domainId: str = domainId
        self.entityId: str = entityId
        self.userList: list[str] = userList
        self.permissionTypeId: str = permissionTypeId

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.domainId = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.entityId = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.userList = []
                    (_etype143, _size140) = iprot.readListBegin()
                    for _i144 in range(_size140):
                        _elem145 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.userList.append(_elem145)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.permissionTypeId = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('revokeEntitySharingFromUsers_args')
        if self.domainId is not None:
            oprot.writeFieldBegin('domainId', TType.STRING, 1)
            oprot.writeString(self.domainId.encode('utf-8') if sys.version_info[0] == 2 else self.domainId)
            oprot.writeFieldEnd()
        if self.entityId is not None:
            oprot.writeFieldBegin('entityId', TType.STRING, 2)
            oprot.writeString(self.entityId.encode('utf-8') if sys.version_info[0] == 2 else self.entityId)
            oprot.writeFieldEnd()
        if self.userList is not None:
            oprot.writeFieldBegin('userList', TType.LIST, 3)
            oprot.writeListBegin(TType.STRING, len(self.userList))
            for iter146 in self.userList:
                oprot.writeString(iter146.encode('utf-8') if sys.version_info[0] == 2 else iter146)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.permissionTypeId is not None:
            oprot.writeFieldBegin('permissionTypeId', TType.STRING, 4)
            oprot.writeString(self.permissionTypeId.encode('utf-8') if sys.version_info[0] == 2 else self.permissionTypeId)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.domainId is None:
            raise TProtocolException(message='Required field domainId is unset!')
        if self.entityId is None:
            raise TProtocolException(message='Required field entityId is unset!')
        if self.userList is None:
            raise TProtocolException(message='Required field userList is unset!')
        if self.permissionTypeId is None:
            raise TProtocolException(message='Required field permissionTypeId is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(revokeEntitySharingFromUsers_args)
revokeEntitySharingFromUsers_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'domainId', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'entityId', 'UTF8', None, ),  # 2
    (3, TType.LIST, 'userList', (TType.STRING, 'UTF8', False), None, ),  # 3
    (4, TType.STRING, 'permissionTypeId', 'UTF8', None, ),  # 4
)


class revokeEntitySharingFromUsers_result(object):
    """
    Attributes:
     - success
     - sre

    """
    thrift_spec: typing.Any = None


    def __init__(self, success: typing.Optional[bool] = None, sre: typing.Optional[airavata.model.sharing.ttypes.SharingRegistryException] = None,):
        self.success: typing.Optional[bool] = success
        self.sre: typing.Optional[airavata.model.sharing.ttypes.SharingRegistryException] = sre

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.BOOL:
                    self.success = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.sre = airavata.model.sharing.ttypes.SharingRegistryException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('revokeEntitySharingFromUsers_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.BOOL, 0)
            oprot.writeBool(self.success)
            oprot.writeFieldEnd()
        if self.sre is not None:
            oprot.writeFieldBegin('sre', TType.STRUCT, 1)
            self.sre.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(revokeEntitySharingFromUsers_result)
revokeEntitySharingFromUsers_result.thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'sre', [airavata.model.sharing.ttypes.SharingRegistryException, None], None, ),  # 1
)


class shareEntityWithGroups_args(object):
    """
    Attributes:
     - domainId
     - entityId
     - groupList
     - permissionTypeId
     - cascadePermission

    """
    thrift_spec: typing.Any = None


    def __init__(self, domainId: str = None, entityId: str = None, groupList: list[str] = None, permissionTypeId: str = None, cascadePermission: bool = None,):
        self.domainId: str = domainId
        self.entityId: str = entityId
        self.groupList: list[str] = groupList
        self.permissionTypeId: str = permissionTypeId
        self.cascadePermission: bool = cascadePermission

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.domainId = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.entityId = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.groupList = []
                    (_etype150, _size147) = iprot.readListBegin()
                    for _i151 in range(_size147):
                        _elem152 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.groupList.append(_elem152)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.permissionTypeId = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.BOOL:
                    self.cascadePermission = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('shareEntityWithGroups_args')
        if self.domainId is not None:
            oprot.writeFieldBegin('domainId', TType.STRING, 1)
            oprot.writeString(self.domainId.encode('utf-8') if sys.version_info[0] == 2 else self.domainId)
            oprot.writeFieldEnd()
        if self.entityId is not None:
            oprot.writeFieldBegin('entityId', TType.STRING, 2)
            oprot.writeString(self.entityId.encode('utf-8') if sys.version_info[0] == 2 else self.entityId)
            oprot.writeFieldEnd()
        if self.groupList is not None:
            oprot.writeFieldBegin('groupList', TType.LIST, 3)
            oprot.writeListBegin(TType.STRING, len(self.groupList))
            for iter153 in self.groupList:
                oprot.writeString(iter153.encode('utf-8') if sys.version_info[0] == 2 else iter153)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.permissionTypeId is not None:
            oprot.writeFieldBegin('permissionTypeId', TType.STRING, 4)
            oprot.writeString(self.permissionTypeId.encode('utf-8') if sys.version_info[0] == 2 else self.permissionTypeId)
            oprot.writeFieldEnd()
        if self.cascadePermission is not None:
            oprot.writeFieldBegin('cascadePermission', TType.BOOL, 5)
            oprot.writeBool(self.cascadePermission)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.domainId is None:
            raise TProtocolException(message='Required field domainId is unset!')
        if self.entityId is None:
            raise TProtocolException(message='Required field entityId is unset!')
        if self.groupList is None:
            raise TProtocolException(message='Required field groupList is unset!')
        if self.permissionTypeId is None:
            raise TProtocolException(message='Required field permissionTypeId is unset!')
        if self.cascadePermission is None:
            raise TProtocolException(message='Required field cascadePermission is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(shareEntityWithGroups_args)
shareEntityWithGroups_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'domainId', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'entityId', 'UTF8', None, ),  # 2
    (3, TType.LIST, 'groupList', (TType.STRING, 'UTF8', False), None, ),  # 3
    (4, TType.STRING, 'permissionTypeId', 'UTF8', None, ),  # 4
    (5, TType.BOOL, 'cascadePermission', None, None, ),  # 5
)


class shareEntityWithGroups_result(object):
    """
    Attributes:
     - success
     - sre

    """
    thrift_spec: typing.Any = None


    def __init__(self, success: typing.Optional[bool] = None, sre: typing.Optional[airavata.model.sharing.ttypes.SharingRegistryException] = None,):
        self.success: typing.Optional[bool] = success
        self.sre: typing.Optional[airavata.model.sharing.ttypes.SharingRegistryException] = sre

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.BOOL:
                    self.success = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.sre = airavata.model.sharing.ttypes.SharingRegistryException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('shareEntityWithGroups_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.BOOL, 0)
            oprot.writeBool(self.success)
            oprot.writeFieldEnd()
        if self.sre is not None:
            oprot.writeFieldBegin('sre', TType.STRUCT, 1)
            self.sre.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(shareEntityWithGroups_result)
shareEntityWithGroups_result.thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'sre', [airavata.model.sharing.ttypes.SharingRegistryException, None], None, ),  # 1
)


class revokeEntitySharingFromGroups_args(object):
    """
    Attributes:
     - domainId
     - entityId
     - groupList
     - permissionTypeId

    """
    thrift_spec: typing.Any = None


    def __init__(self, domainId: str = None, entityId: str = None, groupList: list[str] = None, permissionTypeId: str = None,):
        self.domainId: str = domainId
        self.entityId: str = entityId
        self.groupList: list[str] = groupList
        self.permissionTypeId: str = permissionTypeId

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.domainId = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.entityId = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.groupList = []
                    (_etype157, _size154) = iprot.readListBegin()
                    for _i158 in range(_size154):
                        _elem159 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.groupList.append(_elem159)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.permissionTypeId = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('revokeEntitySharingFromGroups_args')
        if self.domainId is not None:
            oprot.writeFieldBegin('domainId', TType.STRING, 1)
            oprot.writeString(self.domainId.encode('utf-8') if sys.version_info[0] == 2 else self.domainId)
            oprot.writeFieldEnd()
        if self.entityId is not None:
            oprot.writeFieldBegin('entityId', TType.STRING, 2)
            oprot.writeString(self.entityId.encode('utf-8') if sys.version_info[0] == 2 else self.entityId)
            oprot.writeFieldEnd()
        if self.groupList is not None:
            oprot.writeFieldBegin('groupList', TType.LIST, 3)
            oprot.writeListBegin(TType.STRING, len(self.groupList))
            for iter160 in self.groupList:
                oprot.writeString(iter160.encode('utf-8') if sys.version_info[0] == 2 else iter160)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.permissionTypeId is not None:
            oprot.writeFieldBegin('permissionTypeId', TType.STRING, 4)
            oprot.writeString(self.permissionTypeId.encode('utf-8') if sys.version_info[0] == 2 else self.permissionTypeId)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.domainId is None:
            raise TProtocolException(message='Required field domainId is unset!')
        if self.entityId is None:
            raise TProtocolException(message='Required field entityId is unset!')
        if self.groupList is None:
            raise TProtocolException(message='Required field groupList is unset!')
        if self.permissionTypeId is None:
            raise TProtocolException(message='Required field permissionTypeId is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(revokeEntitySharingFromGroups_args)
revokeEntitySharingFromGroups_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'domainId', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'entityId', 'UTF8', None, ),  # 2
    (3, TType.LIST, 'groupList', (TType.STRING, 'UTF8', False), None, ),  # 3
    (4, TType.STRING, 'permissionTypeId', 'UTF8', None, ),  # 4
)


class revokeEntitySharingFromGroups_result(object):
    """
    Attributes:
     - success
     - sre

    """
    thrift_spec: typing.Any = None


    def __init__(self, success: typing.Optional[bool] = None, sre: typing.Optional[airavata.model.sharing.ttypes.SharingRegistryException] = None,):
        self.success: typing.Optional[bool] = success
        self.sre: typing.Optional[airavata.model.sharing.ttypes.SharingRegistryException] = sre

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.BOOL:
                    self.success = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.sre = airavata.model.sharing.ttypes.SharingRegistryException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('revokeEntitySharingFromGroups_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.BOOL, 0)
            oprot.writeBool(self.success)
            oprot.writeFieldEnd()
        if self.sre is not None:
            oprot.writeFieldBegin('sre', TType.STRUCT, 1)
            self.sre.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(revokeEntitySharingFromGroups_result)
revokeEntitySharingFromGroups_result.thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'sre', [airavata.model.sharing.ttypes.SharingRegistryException, None], None, ),  # 1
)


class userHasAccess_args(object):
    """
    Attributes:
     - domainId
     - userId
     - entityId
     - permissionTypeId

    """
    thrift_spec: typing.Any = None


    def __init__(self, domainId: str = None, userId: str = None, entityId: str = None, permissionTypeId: str = None,):
        self.domainId: str = domainId
        self.userId: str = userId
        self.entityId: str = entityId
        self.permissionTypeId: str = permissionTypeId

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.domainId = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.userId = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.entityId = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.permissionTypeId = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('userHasAccess_args')
        if self.domainId is not None:
            oprot.writeFieldBegin('domainId', TType.STRING, 1)
            oprot.writeString(self.domainId.encode('utf-8') if sys.version_info[0] == 2 else self.domainId)
            oprot.writeFieldEnd()
        if self.userId is not None:
            oprot.writeFieldBegin('userId', TType.STRING, 2)
            oprot.writeString(self.userId.encode('utf-8') if sys.version_info[0] == 2 else self.userId)
            oprot.writeFieldEnd()
        if self.entityId is not None:
            oprot.writeFieldBegin('entityId', TType.STRING, 3)
            oprot.writeString(self.entityId.encode('utf-8') if sys.version_info[0] == 2 else self.entityId)
            oprot.writeFieldEnd()
        if self.permissionTypeId is not None:
            oprot.writeFieldBegin('permissionTypeId', TType.STRING, 4)
            oprot.writeString(self.permissionTypeId.encode('utf-8') if sys.version_info[0] == 2 else self.permissionTypeId)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.domainId is None:
            raise TProtocolException(message='Required field domainId is unset!')
        if self.userId is None:
            raise TProtocolException(message='Required field userId is unset!')
        if self.entityId is None:
            raise TProtocolException(message='Required field entityId is unset!')
        if self.permissionTypeId is None:
            raise TProtocolException(message='Required field permissionTypeId is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(userHasAccess_args)
userHasAccess_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'domainId', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'userId', 'UTF8', None, ),  # 2
    (3, TType.STRING, 'entityId', 'UTF8', None, ),  # 3
    (4, TType.STRING, 'permissionTypeId', 'UTF8', None, ),  # 4
)


class userHasAccess_result(object):
    """
    Attributes:
     - success
     - sre

    """
    thrift_spec: typing.Any = None


    def __init__(self, success: typing.Optional[bool] = None, sre: typing.Optional[airavata.model.sharing.ttypes.SharingRegistryException] = None,):
        self.success: typing.Optional[bool] = success
        self.sre: typing.Optional[airavata.model.sharing.ttypes.SharingRegistryException] = sre

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.BOOL:
                    self.success = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.sre = airavata.model.sharing.ttypes.SharingRegistryException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('userHasAccess_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.BOOL, 0)
            oprot.writeBool(self.success)
            oprot.writeFieldEnd()
        if self.sre is not None:
            oprot.writeFieldBegin('sre', TType.STRUCT, 1)
            self.sre.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(userHasAccess_result)
userHasAccess_result.thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'sre', [airavata.model.sharing.ttypes.SharingRegistryException, None], None, ),  # 1
)
fix_spec(all_structs)
del all_structs
