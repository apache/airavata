/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Autogenerated by Thrift Compiler (0.10.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#ifndef parser_model_TYPES_H
#define parser_model_TYPES_H

#include <iosfwd>

#include <thrift/Thrift.h>
#include <thrift/TApplicationException.h>
#include <thrift/TBase.h>
#include <thrift/protocol/TProtocol.h>
#include <thrift/transport/TTransport.h>

#include <thrift/cxxfunctional.h>


namespace apache { namespace airavata { namespace model { namespace appcatalog { namespace parser {

struct IOType {
  enum type {
    FILE = 0,
    PROPERTY = 1
  };
};

extern const std::map<int, const char*> _IOType_VALUES_TO_NAMES;

class ParserInput;

class ParserOutput;

class Parser;

class ParserConnectorInput;

class ParserConnector;

class ParsingTemplateInput;

class ParsingTemplate;


class ParserInput : public virtual ::apache::thrift::TBase {
 public:

  ParserInput(const ParserInput&);
  ParserInput& operator=(const ParserInput&);
  ParserInput() : id(), name(), requiredInput(0), parserId(), type((IOType::type)0) {
  }

  virtual ~ParserInput() throw();
  std::string id;
  std::string name;
  bool requiredInput;
  std::string parserId;
  IOType::type type;

  void __set_id(const std::string& val);

  void __set_name(const std::string& val);

  void __set_requiredInput(const bool val);

  void __set_parserId(const std::string& val);

  void __set_type(const IOType::type val);

  bool operator == (const ParserInput & rhs) const
  {
    if (!(id == rhs.id))
      return false;
    if (!(name == rhs.name))
      return false;
    if (!(requiredInput == rhs.requiredInput))
      return false;
    if (!(parserId == rhs.parserId))
      return false;
    if (!(type == rhs.type))
      return false;
    return true;
  }
  bool operator != (const ParserInput &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ParserInput & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(ParserInput &a, ParserInput &b);

inline std::ostream& operator<<(std::ostream& out, const ParserInput& obj)
{
  obj.printTo(out);
  return out;
}


class ParserOutput : public virtual ::apache::thrift::TBase {
 public:

  ParserOutput(const ParserOutput&);
  ParserOutput& operator=(const ParserOutput&);
  ParserOutput() : id(), name(), requiredOutput(0), parserId(), type((IOType::type)0) {
  }

  virtual ~ParserOutput() throw();
  std::string id;
  std::string name;
  bool requiredOutput;
  std::string parserId;
  IOType::type type;

  void __set_id(const std::string& val);

  void __set_name(const std::string& val);

  void __set_requiredOutput(const bool val);

  void __set_parserId(const std::string& val);

  void __set_type(const IOType::type val);

  bool operator == (const ParserOutput & rhs) const
  {
    if (!(id == rhs.id))
      return false;
    if (!(name == rhs.name))
      return false;
    if (!(requiredOutput == rhs.requiredOutput))
      return false;
    if (!(parserId == rhs.parserId))
      return false;
    if (!(type == rhs.type))
      return false;
    return true;
  }
  bool operator != (const ParserOutput &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ParserOutput & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(ParserOutput &a, ParserOutput &b);

inline std::ostream& operator<<(std::ostream& out, const ParserOutput& obj)
{
  obj.printTo(out);
  return out;
}


class Parser : public virtual ::apache::thrift::TBase {
 public:

  Parser(const Parser&);
  Parser& operator=(const Parser&);
  Parser() : id(), imageName(), outputDirPath(), inputDirPath(), executionCommand(), gatewayId() {
  }

  virtual ~Parser() throw();
  std::string id;
  std::string imageName;
  std::string outputDirPath;
  std::string inputDirPath;
  std::string executionCommand;
  std::vector<ParserInput>  inputFiles;
  std::vector<ParserOutput>  outputFiles;
  std::string gatewayId;

  void __set_id(const std::string& val);

  void __set_imageName(const std::string& val);

  void __set_outputDirPath(const std::string& val);

  void __set_inputDirPath(const std::string& val);

  void __set_executionCommand(const std::string& val);

  void __set_inputFiles(const std::vector<ParserInput> & val);

  void __set_outputFiles(const std::vector<ParserOutput> & val);

  void __set_gatewayId(const std::string& val);

  bool operator == (const Parser & rhs) const
  {
    if (!(id == rhs.id))
      return false;
    if (!(imageName == rhs.imageName))
      return false;
    if (!(outputDirPath == rhs.outputDirPath))
      return false;
    if (!(inputDirPath == rhs.inputDirPath))
      return false;
    if (!(executionCommand == rhs.executionCommand))
      return false;
    if (!(inputFiles == rhs.inputFiles))
      return false;
    if (!(outputFiles == rhs.outputFiles))
      return false;
    if (!(gatewayId == rhs.gatewayId))
      return false;
    return true;
  }
  bool operator != (const Parser &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Parser & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(Parser &a, Parser &b);

inline std::ostream& operator<<(std::ostream& out, const Parser& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _ParserConnectorInput__isset {
  _ParserConnectorInput__isset() : parentOutputId(false), value(false) {}
  bool parentOutputId :1;
  bool value :1;
} _ParserConnectorInput__isset;

class ParserConnectorInput : public virtual ::apache::thrift::TBase {
 public:

  ParserConnectorInput(const ParserConnectorInput&);
  ParserConnectorInput& operator=(const ParserConnectorInput&);
  ParserConnectorInput() : id(), inputId(), parentOutputId(), value(), parserConnectorId() {
  }

  virtual ~ParserConnectorInput() throw();
  std::string id;
  std::string inputId;
  std::string parentOutputId;
  std::string value;
  std::string parserConnectorId;

  _ParserConnectorInput__isset __isset;

  void __set_id(const std::string& val);

  void __set_inputId(const std::string& val);

  void __set_parentOutputId(const std::string& val);

  void __set_value(const std::string& val);

  void __set_parserConnectorId(const std::string& val);

  bool operator == (const ParserConnectorInput & rhs) const
  {
    if (!(id == rhs.id))
      return false;
    if (!(inputId == rhs.inputId))
      return false;
    if (!(parentOutputId == rhs.parentOutputId))
      return false;
    if (!(value == rhs.value))
      return false;
    if (!(parserConnectorId == rhs.parserConnectorId))
      return false;
    return true;
  }
  bool operator != (const ParserConnectorInput &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ParserConnectorInput & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(ParserConnectorInput &a, ParserConnectorInput &b);

inline std::ostream& operator<<(std::ostream& out, const ParserConnectorInput& obj)
{
  obj.printTo(out);
  return out;
}


class ParserConnector : public virtual ::apache::thrift::TBase {
 public:

  ParserConnector(const ParserConnector&);
  ParserConnector& operator=(const ParserConnector&);
  ParserConnector() : id(), parentParserId(), childParserId(), parsingTemplateId() {
  }

  virtual ~ParserConnector() throw();
  std::string id;
  std::string parentParserId;
  std::string childParserId;
  std::vector<ParserConnectorInput>  connectorInputs;
  std::string parsingTemplateId;

  void __set_id(const std::string& val);

  void __set_parentParserId(const std::string& val);

  void __set_childParserId(const std::string& val);

  void __set_connectorInputs(const std::vector<ParserConnectorInput> & val);

  void __set_parsingTemplateId(const std::string& val);

  bool operator == (const ParserConnector & rhs) const
  {
    if (!(id == rhs.id))
      return false;
    if (!(parentParserId == rhs.parentParserId))
      return false;
    if (!(childParserId == rhs.childParserId))
      return false;
    if (!(connectorInputs == rhs.connectorInputs))
      return false;
    if (!(parsingTemplateId == rhs.parsingTemplateId))
      return false;
    return true;
  }
  bool operator != (const ParserConnector &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ParserConnector & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(ParserConnector &a, ParserConnector &b);

inline std::ostream& operator<<(std::ostream& out, const ParserConnector& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _ParsingTemplateInput__isset {
  _ParsingTemplateInput__isset() : applicationOutputName(false), value(false) {}
  bool applicationOutputName :1;
  bool value :1;
} _ParsingTemplateInput__isset;

class ParsingTemplateInput : public virtual ::apache::thrift::TBase {
 public:

  ParsingTemplateInput(const ParsingTemplateInput&);
  ParsingTemplateInput& operator=(const ParsingTemplateInput&);
  ParsingTemplateInput() : id(), targetInputId(), applicationOutputName(), value(), parsingTemplateId() {
  }

  virtual ~ParsingTemplateInput() throw();
  std::string id;
  std::string targetInputId;
  std::string applicationOutputName;
  std::string value;
  std::string parsingTemplateId;

  _ParsingTemplateInput__isset __isset;

  void __set_id(const std::string& val);

  void __set_targetInputId(const std::string& val);

  void __set_applicationOutputName(const std::string& val);

  void __set_value(const std::string& val);

  void __set_parsingTemplateId(const std::string& val);

  bool operator == (const ParsingTemplateInput & rhs) const
  {
    if (!(id == rhs.id))
      return false;
    if (!(targetInputId == rhs.targetInputId))
      return false;
    if (!(applicationOutputName == rhs.applicationOutputName))
      return false;
    if (!(value == rhs.value))
      return false;
    if (!(parsingTemplateId == rhs.parsingTemplateId))
      return false;
    return true;
  }
  bool operator != (const ParsingTemplateInput &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ParsingTemplateInput & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(ParsingTemplateInput &a, ParsingTemplateInput &b);

inline std::ostream& operator<<(std::ostream& out, const ParsingTemplateInput& obj)
{
  obj.printTo(out);
  return out;
}


class ParsingTemplate : public virtual ::apache::thrift::TBase {
 public:

  ParsingTemplate(const ParsingTemplate&);
  ParsingTemplate& operator=(const ParsingTemplate&);
  ParsingTemplate() : id(), applicationInterface(), gatewayId() {
  }

  virtual ~ParsingTemplate() throw();
  std::string id;
  std::string applicationInterface;
  std::vector<ParsingTemplateInput>  initialInputs;
  std::vector<ParserConnector>  parserConnections;
  std::string gatewayId;

  void __set_id(const std::string& val);

  void __set_applicationInterface(const std::string& val);

  void __set_initialInputs(const std::vector<ParsingTemplateInput> & val);

  void __set_parserConnections(const std::vector<ParserConnector> & val);

  void __set_gatewayId(const std::string& val);

  bool operator == (const ParsingTemplate & rhs) const
  {
    if (!(id == rhs.id))
      return false;
    if (!(applicationInterface == rhs.applicationInterface))
      return false;
    if (!(initialInputs == rhs.initialInputs))
      return false;
    if (!(parserConnections == rhs.parserConnections))
      return false;
    if (!(gatewayId == rhs.gatewayId))
      return false;
    return true;
  }
  bool operator != (const ParsingTemplate &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ParsingTemplate & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(ParsingTemplate &a, ParsingTemplate &b);

inline std::ostream& operator<<(std::ostream& out, const ParsingTemplate& obj)
{
  obj.printTo(out);
  return out;
}

}}}}} // namespace

#endif
