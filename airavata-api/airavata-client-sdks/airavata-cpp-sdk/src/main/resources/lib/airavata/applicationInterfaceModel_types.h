/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Autogenerated by Thrift Compiler (0.9.1)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#ifndef applicationInterfaceModel_TYPES_H
#define applicationInterfaceModel_TYPES_H

#include <thrift/Thrift.h>
#include <thrift/TApplicationException.h>
#include <thrift/protocol/TProtocol.h>
#include <thrift/transport/TTransport.h>

#include <thrift/cxxfunctional.h>


namespace apache { namespace airavata { namespace model { namespace appcatalog { namespace appinterface {

struct DataType {
  enum type {
    STRING = 0,
    INTEGER = 1,
    FLOAT = 2,
    URI = 3,
    STDOUT = 4,
    STDERR = 5
  };
};

extern const std::map<int, const char*> _DataType_VALUES_TO_NAMES;

struct ValidityType {
  enum type {
    REQUIRED = 0,
    OPTIONAL = 1
  };
};

extern const std::map<int, const char*> _ValidityType_VALUES_TO_NAMES;

struct CommandLineType {
  enum type {
    INCLUSIVE = 0,
    EXCLUSIVE = 1
  };
};

extern const std::map<int, const char*> _CommandLineType_VALUES_TO_NAMES;

struct InputMetadataType {
  enum type {
    MEMORY = 0,
    CPU = 1
  };
};

extern const std::map<int, const char*> _InputMetadataType_VALUES_TO_NAMES;

typedef struct _InputDataObjectType__isset {
  _InputDataObjectType__isset() : value(false), type(false), applicationArgument(false), standardInput(true), userFriendlyDescription(false), metaData(false), inputOrder(false), inputValid(false), addedToCommandLine(false), dataStaged(true) {}
  bool value;
  bool type;
  bool applicationArgument;
  bool standardInput;
  bool userFriendlyDescription;
  bool metaData;
  bool inputOrder;
  bool inputValid;
  bool addedToCommandLine;
  bool dataStaged;
} _InputDataObjectType__isset;

class InputDataObjectType {
 public:

  static const char* ascii_fingerprint; // = "95DCCA621F7BE3FA34349CC6A45329DA";
  static const uint8_t binary_fingerprint[16]; // = {0x95,0xDC,0xCA,0x62,0x1F,0x7B,0xE3,0xFA,0x34,0x34,0x9C,0xC6,0xA4,0x53,0x29,0xDA};

  InputDataObjectType() : name(), value(), type((DataType::type)0), applicationArgument(), standardInput(false), userFriendlyDescription(), metaData(), inputOrder(0), inputValid((ValidityType::type)0), addedToCommandLine((CommandLineType::type)0), dataStaged(false) {
  }

  virtual ~InputDataObjectType() throw() {}

  std::string name;
  std::string value;
  DataType::type type;
  std::string applicationArgument;
  bool standardInput;
  std::string userFriendlyDescription;
  std::string metaData;
  int32_t inputOrder;
  ValidityType::type inputValid;
  CommandLineType::type addedToCommandLine;
  bool dataStaged;

  _InputDataObjectType__isset __isset;

  void __set_name(const std::string& val) {
    name = val;
  }

  void __set_value(const std::string& val) {
    value = val;
    __isset.value = true;
  }

  void __set_type(const DataType::type val) {
    type = val;
    __isset.type = true;
  }

  void __set_applicationArgument(const std::string& val) {
    applicationArgument = val;
    __isset.applicationArgument = true;
  }

  void __set_standardInput(const bool val) {
    standardInput = val;
    __isset.standardInput = true;
  }

  void __set_userFriendlyDescription(const std::string& val) {
    userFriendlyDescription = val;
    __isset.userFriendlyDescription = true;
  }

  void __set_metaData(const std::string& val) {
    metaData = val;
    __isset.metaData = true;
  }

  void __set_inputOrder(const int32_t val) {
    inputOrder = val;
    __isset.inputOrder = true;
  }

  void __set_inputValid(const ValidityType::type val) {
    inputValid = val;
    __isset.inputValid = true;
  }

  void __set_addedToCommandLine(const CommandLineType::type val) {
    addedToCommandLine = val;
    __isset.addedToCommandLine = true;
  }

  void __set_dataStaged(const bool val) {
    dataStaged = val;
    __isset.dataStaged = true;
  }

  bool operator == (const InputDataObjectType & rhs) const
  {
    if (!(name == rhs.name))
      return false;
    if (__isset.value != rhs.__isset.value)
      return false;
    else if (__isset.value && !(value == rhs.value))
      return false;
    if (__isset.type != rhs.__isset.type)
      return false;
    else if (__isset.type && !(type == rhs.type))
      return false;
    if (__isset.applicationArgument != rhs.__isset.applicationArgument)
      return false;
    else if (__isset.applicationArgument && !(applicationArgument == rhs.applicationArgument))
      return false;
    if (__isset.standardInput != rhs.__isset.standardInput)
      return false;
    else if (__isset.standardInput && !(standardInput == rhs.standardInput))
      return false;
    if (__isset.userFriendlyDescription != rhs.__isset.userFriendlyDescription)
      return false;
    else if (__isset.userFriendlyDescription && !(userFriendlyDescription == rhs.userFriendlyDescription))
      return false;
    if (__isset.metaData != rhs.__isset.metaData)
      return false;
    else if (__isset.metaData && !(metaData == rhs.metaData))
      return false;
    if (__isset.inputOrder != rhs.__isset.inputOrder)
      return false;
    else if (__isset.inputOrder && !(inputOrder == rhs.inputOrder))
      return false;
    if (__isset.inputValid != rhs.__isset.inputValid)
      return false;
    else if (__isset.inputValid && !(inputValid == rhs.inputValid))
      return false;
    if (__isset.addedToCommandLine != rhs.__isset.addedToCommandLine)
      return false;
    else if (__isset.addedToCommandLine && !(addedToCommandLine == rhs.addedToCommandLine))
      return false;
    if (__isset.dataStaged != rhs.__isset.dataStaged)
      return false;
    else if (__isset.dataStaged && !(dataStaged == rhs.dataStaged))
      return false;
    return true;
  }
  bool operator != (const InputDataObjectType &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const InputDataObjectType & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(InputDataObjectType &a, InputDataObjectType &b);

typedef struct _OutputDataObjectType__isset {
  _OutputDataObjectType__isset() : value(false), type(false), validityType(false), dataMovement(false), dataNameLocation(false) {}
  bool value;
  bool type;
  bool validityType;
  bool dataMovement;
  bool dataNameLocation;
} _OutputDataObjectType__isset;

class OutputDataObjectType {
 public:

  static const char* ascii_fingerprint; // = "9B8C3AEA43A2028DF0CEF51E90706E3A";
  static const uint8_t binary_fingerprint[16]; // = {0x9B,0x8C,0x3A,0xEA,0x43,0xA2,0x02,0x8D,0xF0,0xCE,0xF5,0x1E,0x90,0x70,0x6E,0x3A};

  OutputDataObjectType() : name(), value(), type((DataType::type)0), validityType((ValidityType::type)0), dataMovement(0), dataNameLocation() {
  }

  virtual ~OutputDataObjectType() throw() {}

  std::string name;
  std::string value;
  DataType::type type;
  ValidityType::type validityType;
  bool dataMovement;
  std::string dataNameLocation;

  _OutputDataObjectType__isset __isset;

  void __set_name(const std::string& val) {
    name = val;
  }

  void __set_value(const std::string& val) {
    value = val;
    __isset.value = true;
  }

  void __set_type(const DataType::type val) {
    type = val;
    __isset.type = true;
  }

  void __set_validityType(const ValidityType::type val) {
    validityType = val;
    __isset.validityType = true;
  }

  void __set_dataMovement(const bool val) {
    dataMovement = val;
    __isset.dataMovement = true;
  }

  void __set_dataNameLocation(const std::string& val) {
    dataNameLocation = val;
    __isset.dataNameLocation = true;
  }

  bool operator == (const OutputDataObjectType & rhs) const
  {
    if (!(name == rhs.name))
      return false;
    if (__isset.value != rhs.__isset.value)
      return false;
    else if (__isset.value && !(value == rhs.value))
      return false;
    if (__isset.type != rhs.__isset.type)
      return false;
    else if (__isset.type && !(type == rhs.type))
      return false;
    if (__isset.validityType != rhs.__isset.validityType)
      return false;
    else if (__isset.validityType && !(validityType == rhs.validityType))
      return false;
    if (__isset.dataMovement != rhs.__isset.dataMovement)
      return false;
    else if (__isset.dataMovement && !(dataMovement == rhs.dataMovement))
      return false;
    if (__isset.dataNameLocation != rhs.__isset.dataNameLocation)
      return false;
    else if (__isset.dataNameLocation && !(dataNameLocation == rhs.dataNameLocation))
      return false;
    return true;
  }
  bool operator != (const OutputDataObjectType &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const OutputDataObjectType & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(OutputDataObjectType &a, OutputDataObjectType &b);

typedef struct _ApplicationInterfaceDescription__isset {
  _ApplicationInterfaceDescription__isset() : applicationDescription(false), applicationModules(false), applicationInputs(false), applicationOutputs(false) {}
  bool applicationDescription;
  bool applicationModules;
  bool applicationInputs;
  bool applicationOutputs;
} _ApplicationInterfaceDescription__isset;

class ApplicationInterfaceDescription {
 public:

  static const char* ascii_fingerprint; // = "CE1749A2DE50827990C3136E0CE4B60D";
  static const uint8_t binary_fingerprint[16]; // = {0xCE,0x17,0x49,0xA2,0xDE,0x50,0x82,0x79,0x90,0xC3,0x13,0x6E,0x0C,0xE4,0xB6,0x0D};

  ApplicationInterfaceDescription() : applicationInterfaceId("DO_NOT_SET_AT_CLIENTS"), applicationName(), applicationDescription() {
  }

  virtual ~ApplicationInterfaceDescription() throw() {}

  std::string applicationInterfaceId;
  std::string applicationName;
  std::string applicationDescription;
  std::vector<std::string>  applicationModules;
  std::vector<InputDataObjectType>  applicationInputs;
  std::vector<OutputDataObjectType>  applicationOutputs;

  _ApplicationInterfaceDescription__isset __isset;

  void __set_applicationInterfaceId(const std::string& val) {
    applicationInterfaceId = val;
  }

  void __set_applicationName(const std::string& val) {
    applicationName = val;
  }

  void __set_applicationDescription(const std::string& val) {
    applicationDescription = val;
    __isset.applicationDescription = true;
  }

  void __set_applicationModules(const std::vector<std::string> & val) {
    applicationModules = val;
    __isset.applicationModules = true;
  }

  void __set_applicationInputs(const std::vector<InputDataObjectType> & val) {
    applicationInputs = val;
    __isset.applicationInputs = true;
  }

  void __set_applicationOutputs(const std::vector<OutputDataObjectType> & val) {
    applicationOutputs = val;
    __isset.applicationOutputs = true;
  }

  bool operator == (const ApplicationInterfaceDescription & rhs) const
  {
    if (!(applicationInterfaceId == rhs.applicationInterfaceId))
      return false;
    if (!(applicationName == rhs.applicationName))
      return false;
    if (__isset.applicationDescription != rhs.__isset.applicationDescription)
      return false;
    else if (__isset.applicationDescription && !(applicationDescription == rhs.applicationDescription))
      return false;
    if (__isset.applicationModules != rhs.__isset.applicationModules)
      return false;
    else if (__isset.applicationModules && !(applicationModules == rhs.applicationModules))
      return false;
    if (__isset.applicationInputs != rhs.__isset.applicationInputs)
      return false;
    else if (__isset.applicationInputs && !(applicationInputs == rhs.applicationInputs))
      return false;
    if (__isset.applicationOutputs != rhs.__isset.applicationOutputs)
      return false;
    else if (__isset.applicationOutputs && !(applicationOutputs == rhs.applicationOutputs))
      return false;
    return true;
  }
  bool operator != (const ApplicationInterfaceDescription &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ApplicationInterfaceDescription & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(ApplicationInterfaceDescription &a, ApplicationInterfaceDescription &b);

}}}}} // namespace

#endif
