/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Autogenerated by Thrift Compiler (0.9.1)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#ifndef applicationInterfaceModel_TYPES_H
#define applicationInterfaceModel_TYPES_H

#include <thrift/Thrift.h>
#include <thrift/TApplicationException.h>
#include <thrift/protocol/TProtocol.h>
#include <thrift/transport/TTransport.h>

#include <thrift/cxxfunctional.h>


namespace apache { namespace airavata { namespace model { namespace appcatalog { namespace appinterface {

struct DataType {
  enum type {
    STRING = 0,
    INTEGER = 1,
    FLOAT = 2,
    URI = 3,
    STDOUT = 4,
    STDERR = 5
  };
};

extern const std::map<int, const char*> _DataType_VALUES_TO_NAMES;

typedef struct _InputDataObjectType__isset {
  _InputDataObjectType__isset() : value(false), type(false), applicationArgument(false), standardInput(true), userFriendlyDescription(false), metaData(false), inputOrder(false) {}
  bool value;
  bool type;
  bool applicationArgument;
  bool standardInput;
  bool userFriendlyDescription;
  bool metaData;
  bool inputOrder;
} _InputDataObjectType__isset;

class InputDataObjectType {
 public:

  static const char* ascii_fingerprint; // = "91FB63C319A494A8E1E6563006402BC7";
  static const uint8_t binary_fingerprint[16]; // = {0x91,0xFB,0x63,0xC3,0x19,0xA4,0x94,0xA8,0xE1,0xE6,0x56,0x30,0x06,0x40,0x2B,0xC7};

  InputDataObjectType() : name(), value(), type((DataType::type)0), applicationArgument(), standardInput(false), userFriendlyDescription(), metaData(), inputOrder(0) {
  }

  virtual ~InputDataObjectType() throw() {}

  std::string name;
  std::string value;
  DataType::type type;
  std::string applicationArgument;
  bool standardInput;
  std::string userFriendlyDescription;
  std::string metaData;
  int32_t inputOrder;

  _InputDataObjectType__isset __isset;

  void __set_name(const std::string& val) {
    name = val;
  }

  void __set_value(const std::string& val) {
    value = val;
    __isset.value = true;
  }

  void __set_type(const DataType::type val) {
    type = val;
    __isset.type = true;
  }

  void __set_applicationArgument(const std::string& val) {
    applicationArgument = val;
    __isset.applicationArgument = true;
  }

  void __set_standardInput(const bool val) {
    standardInput = val;
    __isset.standardInput = true;
  }

  void __set_userFriendlyDescription(const std::string& val) {
    userFriendlyDescription = val;
    __isset.userFriendlyDescription = true;
  }

  void __set_metaData(const std::string& val) {
    metaData = val;
    __isset.metaData = true;
  }

  void __set_inputOrder(const int32_t val) {
    inputOrder = val;
    __isset.inputOrder = true;
  }

  bool operator == (const InputDataObjectType & rhs) const
  {
    if (!(name == rhs.name))
      return false;
    if (__isset.value != rhs.__isset.value)
      return false;
    else if (__isset.value && !(value == rhs.value))
      return false;
    if (__isset.type != rhs.__isset.type)
      return false;
    else if (__isset.type && !(type == rhs.type))
      return false;
    if (__isset.applicationArgument != rhs.__isset.applicationArgument)
      return false;
    else if (__isset.applicationArgument && !(applicationArgument == rhs.applicationArgument))
      return false;
    if (__isset.standardInput != rhs.__isset.standardInput)
      return false;
    else if (__isset.standardInput && !(standardInput == rhs.standardInput))
      return false;
    if (__isset.userFriendlyDescription != rhs.__isset.userFriendlyDescription)
      return false;
    else if (__isset.userFriendlyDescription && !(userFriendlyDescription == rhs.userFriendlyDescription))
      return false;
    if (__isset.metaData != rhs.__isset.metaData)
      return false;
    else if (__isset.metaData && !(metaData == rhs.metaData))
      return false;
    if (__isset.inputOrder != rhs.__isset.inputOrder)
      return false;
    else if (__isset.inputOrder && !(inputOrder == rhs.inputOrder))
      return false;
    return true;
  }
  bool operator != (const InputDataObjectType &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const InputDataObjectType & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(InputDataObjectType &a, InputDataObjectType &b);

typedef struct _OutputDataObjectType__isset {
  _OutputDataObjectType__isset() : value(false), type(false) {}
  bool value;
  bool type;
} _OutputDataObjectType__isset;

class OutputDataObjectType {
 public:

  static const char* ascii_fingerprint; // = "B33AE596EF78C48424CF96BCA5D1DF99";
  static const uint8_t binary_fingerprint[16]; // = {0xB3,0x3A,0xE5,0x96,0xEF,0x78,0xC4,0x84,0x24,0xCF,0x96,0xBC,0xA5,0xD1,0xDF,0x99};

  OutputDataObjectType() : name(), value(), type((DataType::type)0) {
  }

  virtual ~OutputDataObjectType() throw() {}

  std::string name;
  std::string value;
  DataType::type type;

  _OutputDataObjectType__isset __isset;

  void __set_name(const std::string& val) {
    name = val;
  }

  void __set_value(const std::string& val) {
    value = val;
    __isset.value = true;
  }

  void __set_type(const DataType::type val) {
    type = val;
    __isset.type = true;
  }

  bool operator == (const OutputDataObjectType & rhs) const
  {
    if (!(name == rhs.name))
      return false;
    if (__isset.value != rhs.__isset.value)
      return false;
    else if (__isset.value && !(value == rhs.value))
      return false;
    if (__isset.type != rhs.__isset.type)
      return false;
    else if (__isset.type && !(type == rhs.type))
      return false;
    return true;
  }
  bool operator != (const OutputDataObjectType &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const OutputDataObjectType & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(OutputDataObjectType &a, OutputDataObjectType &b);

typedef struct _ApplicationInterfaceDescription__isset {
  _ApplicationInterfaceDescription__isset() : applicationDescription(false), applicationModules(false), applicationInputs(false), applicationOutputs(false) {}
  bool applicationDescription;
  bool applicationModules;
  bool applicationInputs;
  bool applicationOutputs;
} _ApplicationInterfaceDescription__isset;

class ApplicationInterfaceDescription {
 public:

  static const char* ascii_fingerprint; // = "F2FFD013708A2D0DA86FD5438F17268E";
  static const uint8_t binary_fingerprint[16]; // = {0xF2,0xFF,0xD0,0x13,0x70,0x8A,0x2D,0x0D,0xA8,0x6F,0xD5,0x43,0x8F,0x17,0x26,0x8E};

  ApplicationInterfaceDescription() : applicationInterfaceId("DO_NOT_SET_AT_CLIENTS"), applicationName(), applicationDescription() {
  }

  virtual ~ApplicationInterfaceDescription() throw() {}

  std::string applicationInterfaceId;
  std::string applicationName;
  std::string applicationDescription;
  std::vector<std::string>  applicationModules;
  std::vector<InputDataObjectType>  applicationInputs;
  std::vector<OutputDataObjectType>  applicationOutputs;

  _ApplicationInterfaceDescription__isset __isset;

  void __set_applicationInterfaceId(const std::string& val) {
    applicationInterfaceId = val;
  }

  void __set_applicationName(const std::string& val) {
    applicationName = val;
  }

  void __set_applicationDescription(const std::string& val) {
    applicationDescription = val;
    __isset.applicationDescription = true;
  }

  void __set_applicationModules(const std::vector<std::string> & val) {
    applicationModules = val;
    __isset.applicationModules = true;
  }

  void __set_applicationInputs(const std::vector<InputDataObjectType> & val) {
    applicationInputs = val;
    __isset.applicationInputs = true;
  }

  void __set_applicationOutputs(const std::vector<OutputDataObjectType> & val) {
    applicationOutputs = val;
    __isset.applicationOutputs = true;
  }

  bool operator == (const ApplicationInterfaceDescription & rhs) const
  {
    if (!(applicationInterfaceId == rhs.applicationInterfaceId))
      return false;
    if (!(applicationName == rhs.applicationName))
      return false;
    if (__isset.applicationDescription != rhs.__isset.applicationDescription)
      return false;
    else if (__isset.applicationDescription && !(applicationDescription == rhs.applicationDescription))
      return false;
    if (__isset.applicationModules != rhs.__isset.applicationModules)
      return false;
    else if (__isset.applicationModules && !(applicationModules == rhs.applicationModules))
      return false;
    if (__isset.applicationInputs != rhs.__isset.applicationInputs)
      return false;
    else if (__isset.applicationInputs && !(applicationInputs == rhs.applicationInputs))
      return false;
    if (__isset.applicationOutputs != rhs.__isset.applicationOutputs)
      return false;
    else if (__isset.applicationOutputs && !(applicationOutputs == rhs.applicationOutputs))
      return false;
    return true;
  }
  bool operator != (const ApplicationInterfaceDescription &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ApplicationInterfaceDescription & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(ApplicationInterfaceDescription &a, ApplicationInterfaceDescription &b);

}}}}} // namespace

#endif
