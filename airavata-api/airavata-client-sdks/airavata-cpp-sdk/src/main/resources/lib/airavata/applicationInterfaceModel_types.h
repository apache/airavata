/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Autogenerated by Thrift Compiler (0.9.1)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#ifndef applicationInterfaceModel_TYPES_H
#define applicationInterfaceModel_TYPES_H

#include <thrift/Thrift.h>
#include <thrift/TApplicationException.h>
#include <thrift/protocol/TProtocol.h>
#include <thrift/transport/TTransport.h>

#include <thrift/cxxfunctional.h>


namespace apache { namespace airavata { namespace model { namespace appcatalog { namespace appinterface {

struct DataType {
  enum type {
    STRING = 0,
    INTEGER = 1,
    FLOAT = 2,
    URI = 3,
    STDOUT = 4,
    STDERR = 5
  };
};

extern const std::map<int, const char*> _DataType_VALUES_TO_NAMES;

typedef struct _InputDataObjectType__isset {
  _InputDataObjectType__isset() : value(false), type(false), applicationArgument(false), standardInput(true), userFriendlyDescription(false), metaData(false), inputOrder(false), isRequired(false), requiredToAddedToCommandLine(false), dataStaged(true) {}
  bool value;
  bool type;
  bool applicationArgument;
  bool standardInput;
  bool userFriendlyDescription;
  bool metaData;
  bool inputOrder;
  bool isRequired;
  bool requiredToAddedToCommandLine;
  bool dataStaged;
} _InputDataObjectType__isset;

class InputDataObjectType {
 public:

  static const char* ascii_fingerprint; // = "22DB8CAA7C1FBBFDD0CA6E19790BA799";
  static const uint8_t binary_fingerprint[16]; // = {0x22,0xDB,0x8C,0xAA,0x7C,0x1F,0xBB,0xFD,0xD0,0xCA,0x6E,0x19,0x79,0x0B,0xA7,0x99};

  InputDataObjectType() : name(), value(), type((DataType::type)0), applicationArgument(), standardInput(false), userFriendlyDescription(), metaData(), inputOrder(0), isRequired(0), requiredToAddedToCommandLine(0), dataStaged(false) {
  }

  virtual ~InputDataObjectType() throw() {}

  std::string name;
  std::string value;
  DataType::type type;
  std::string applicationArgument;
  bool standardInput;
  std::string userFriendlyDescription;
  std::string metaData;
  int32_t inputOrder;
  bool isRequired;
  bool requiredToAddedToCommandLine;
  bool dataStaged;

  _InputDataObjectType__isset __isset;

  void __set_name(const std::string& val) {
    name = val;
  }

  void __set_value(const std::string& val) {
    value = val;
    __isset.value = true;
  }

  void __set_type(const DataType::type val) {
    type = val;
    __isset.type = true;
  }

  void __set_applicationArgument(const std::string& val) {
    applicationArgument = val;
    __isset.applicationArgument = true;
  }

  void __set_standardInput(const bool val) {
    standardInput = val;
    __isset.standardInput = true;
  }

  void __set_userFriendlyDescription(const std::string& val) {
    userFriendlyDescription = val;
    __isset.userFriendlyDescription = true;
  }

  void __set_metaData(const std::string& val) {
    metaData = val;
    __isset.metaData = true;
  }

  void __set_inputOrder(const int32_t val) {
    inputOrder = val;
    __isset.inputOrder = true;
  }

  void __set_isRequired(const bool val) {
    isRequired = val;
    __isset.isRequired = true;
  }

  void __set_requiredToAddedToCommandLine(const bool val) {
    requiredToAddedToCommandLine = val;
    __isset.requiredToAddedToCommandLine = true;
  }

  void __set_dataStaged(const bool val) {
    dataStaged = val;
    __isset.dataStaged = true;
  }

  bool operator == (const InputDataObjectType & rhs) const
  {
    if (!(name == rhs.name))
      return false;
    if (__isset.value != rhs.__isset.value)
      return false;
    else if (__isset.value && !(value == rhs.value))
      return false;
    if (__isset.type != rhs.__isset.type)
      return false;
    else if (__isset.type && !(type == rhs.type))
      return false;
    if (__isset.applicationArgument != rhs.__isset.applicationArgument)
      return false;
    else if (__isset.applicationArgument && !(applicationArgument == rhs.applicationArgument))
      return false;
    if (__isset.standardInput != rhs.__isset.standardInput)
      return false;
    else if (__isset.standardInput && !(standardInput == rhs.standardInput))
      return false;
    if (__isset.userFriendlyDescription != rhs.__isset.userFriendlyDescription)
      return false;
    else if (__isset.userFriendlyDescription && !(userFriendlyDescription == rhs.userFriendlyDescription))
      return false;
    if (__isset.metaData != rhs.__isset.metaData)
      return false;
    else if (__isset.metaData && !(metaData == rhs.metaData))
      return false;
    if (__isset.inputOrder != rhs.__isset.inputOrder)
      return false;
    else if (__isset.inputOrder && !(inputOrder == rhs.inputOrder))
      return false;
    if (__isset.isRequired != rhs.__isset.isRequired)
      return false;
    else if (__isset.isRequired && !(isRequired == rhs.isRequired))
      return false;
    if (__isset.requiredToAddedToCommandLine != rhs.__isset.requiredToAddedToCommandLine)
      return false;
    else if (__isset.requiredToAddedToCommandLine && !(requiredToAddedToCommandLine == rhs.requiredToAddedToCommandLine))
      return false;
    if (__isset.dataStaged != rhs.__isset.dataStaged)
      return false;
    else if (__isset.dataStaged && !(dataStaged == rhs.dataStaged))
      return false;
    return true;
  }
  bool operator != (const InputDataObjectType &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const InputDataObjectType & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(InputDataObjectType &a, InputDataObjectType &b);

typedef struct _OutputDataObjectType__isset {
  _OutputDataObjectType__isset() : value(false), type(false), isRequired(false), requiredToAddedToCommandLine(false), dataMovement(false), dataNameLocation(false) {}
  bool value;
  bool type;
  bool isRequired;
  bool requiredToAddedToCommandLine;
  bool dataMovement;
  bool dataNameLocation;
} _OutputDataObjectType__isset;

class OutputDataObjectType {
 public:

  static const char* ascii_fingerprint; // = "E4852521B22B693B0FFBEBAE57AA4F8A";
  static const uint8_t binary_fingerprint[16]; // = {0xE4,0x85,0x25,0x21,0xB2,0x2B,0x69,0x3B,0x0F,0xFB,0xEB,0xAE,0x57,0xAA,0x4F,0x8A};

  OutputDataObjectType() : name(), value(), type((DataType::type)0), isRequired(0), requiredToAddedToCommandLine(0), dataMovement(0), dataNameLocation() {
  }

  virtual ~OutputDataObjectType() throw() {}

  std::string name;
  std::string value;
  DataType::type type;
  bool isRequired;
  bool requiredToAddedToCommandLine;
  bool dataMovement;
  std::string dataNameLocation;

  _OutputDataObjectType__isset __isset;

  void __set_name(const std::string& val) {
    name = val;
  }

  void __set_value(const std::string& val) {
    value = val;
    __isset.value = true;
  }

  void __set_type(const DataType::type val) {
    type = val;
    __isset.type = true;
  }

  void __set_isRequired(const bool val) {
    isRequired = val;
    __isset.isRequired = true;
  }

  void __set_requiredToAddedToCommandLine(const bool val) {
    requiredToAddedToCommandLine = val;
    __isset.requiredToAddedToCommandLine = true;
  }

  void __set_dataMovement(const bool val) {
    dataMovement = val;
    __isset.dataMovement = true;
  }

  void __set_dataNameLocation(const std::string& val) {
    dataNameLocation = val;
    __isset.dataNameLocation = true;
  }

  bool operator == (const OutputDataObjectType & rhs) const
  {
    if (!(name == rhs.name))
      return false;
    if (__isset.value != rhs.__isset.value)
      return false;
    else if (__isset.value && !(value == rhs.value))
      return false;
    if (__isset.type != rhs.__isset.type)
      return false;
    else if (__isset.type && !(type == rhs.type))
      return false;
    if (__isset.isRequired != rhs.__isset.isRequired)
      return false;
    else if (__isset.isRequired && !(isRequired == rhs.isRequired))
      return false;
    if (__isset.requiredToAddedToCommandLine != rhs.__isset.requiredToAddedToCommandLine)
      return false;
    else if (__isset.requiredToAddedToCommandLine && !(requiredToAddedToCommandLine == rhs.requiredToAddedToCommandLine))
      return false;
    if (__isset.dataMovement != rhs.__isset.dataMovement)
      return false;
    else if (__isset.dataMovement && !(dataMovement == rhs.dataMovement))
      return false;
    if (__isset.dataNameLocation != rhs.__isset.dataNameLocation)
      return false;
    else if (__isset.dataNameLocation && !(dataNameLocation == rhs.dataNameLocation))
      return false;
    return true;
  }
  bool operator != (const OutputDataObjectType &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const OutputDataObjectType & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(OutputDataObjectType &a, OutputDataObjectType &b);

typedef struct _ApplicationInterfaceDescription__isset {
  _ApplicationInterfaceDescription__isset() : applicationDescription(false), applicationModules(false), applicationInputs(false), applicationOutputs(false) {}
  bool applicationDescription;
  bool applicationModules;
  bool applicationInputs;
  bool applicationOutputs;
} _ApplicationInterfaceDescription__isset;

class ApplicationInterfaceDescription {
 public:

  static const char* ascii_fingerprint; // = "29D39A862EDAA850C0484542CD39F4A3";
  static const uint8_t binary_fingerprint[16]; // = {0x29,0xD3,0x9A,0x86,0x2E,0xDA,0xA8,0x50,0xC0,0x48,0x45,0x42,0xCD,0x39,0xF4,0xA3};

  ApplicationInterfaceDescription() : applicationInterfaceId("DO_NOT_SET_AT_CLIENTS"), applicationName(), applicationDescription() {
  }

  virtual ~ApplicationInterfaceDescription() throw() {}

  std::string applicationInterfaceId;
  std::string applicationName;
  std::string applicationDescription;
  std::vector<std::string>  applicationModules;
  std::vector<InputDataObjectType>  applicationInputs;
  std::vector<OutputDataObjectType>  applicationOutputs;

  _ApplicationInterfaceDescription__isset __isset;

  void __set_applicationInterfaceId(const std::string& val) {
    applicationInterfaceId = val;
  }

  void __set_applicationName(const std::string& val) {
    applicationName = val;
  }

  void __set_applicationDescription(const std::string& val) {
    applicationDescription = val;
    __isset.applicationDescription = true;
  }

  void __set_applicationModules(const std::vector<std::string> & val) {
    applicationModules = val;
    __isset.applicationModules = true;
  }

  void __set_applicationInputs(const std::vector<InputDataObjectType> & val) {
    applicationInputs = val;
    __isset.applicationInputs = true;
  }

  void __set_applicationOutputs(const std::vector<OutputDataObjectType> & val) {
    applicationOutputs = val;
    __isset.applicationOutputs = true;
  }

  bool operator == (const ApplicationInterfaceDescription & rhs) const
  {
    if (!(applicationInterfaceId == rhs.applicationInterfaceId))
      return false;
    if (!(applicationName == rhs.applicationName))
      return false;
    if (__isset.applicationDescription != rhs.__isset.applicationDescription)
      return false;
    else if (__isset.applicationDescription && !(applicationDescription == rhs.applicationDescription))
      return false;
    if (__isset.applicationModules != rhs.__isset.applicationModules)
      return false;
    else if (__isset.applicationModules && !(applicationModules == rhs.applicationModules))
      return false;
    if (__isset.applicationInputs != rhs.__isset.applicationInputs)
      return false;
    else if (__isset.applicationInputs && !(applicationInputs == rhs.applicationInputs))
      return false;
    if (__isset.applicationOutputs != rhs.__isset.applicationOutputs)
      return false;
    else if (__isset.applicationOutputs && !(applicationOutputs == rhs.applicationOutputs))
      return false;
    return true;
  }
  bool operator != (const ApplicationInterfaceDescription &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ApplicationInterfaceDescription & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(ApplicationInterfaceDescription &a, ApplicationInterfaceDescription &b);

}}}}} // namespace

#endif
