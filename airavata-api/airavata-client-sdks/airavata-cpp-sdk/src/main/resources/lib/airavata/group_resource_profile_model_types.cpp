/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Autogenerated by Thrift Compiler (0.10.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#include "group_resource_profile_model_types.h"

#include <algorithm>
#include <ostream>

#include <thrift/TToString.h>

namespace apache { namespace airavata { namespace model { namespace appcatalog { namespace groupresourceprofile {


GroupAccountSSHProvisionerConfig::~GroupAccountSSHProvisionerConfig() throw() {
}


void GroupAccountSSHProvisionerConfig::__set_resourceId(const std::string& val) {
  this->resourceId = val;
}

void GroupAccountSSHProvisionerConfig::__set_groupResourceProfileId(const std::string& val) {
  this->groupResourceProfileId = val;
}

void GroupAccountSSHProvisionerConfig::__set_configName(const std::string& val) {
  this->configName = val;
}

void GroupAccountSSHProvisionerConfig::__set_configValue(const std::string& val) {
  this->configValue = val;
__isset.configValue = true;
}

uint32_t GroupAccountSSHProvisionerConfig::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_resourceId = false;
  bool isset_groupResourceProfileId = false;
  bool isset_configName = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->resourceId);
          isset_resourceId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->groupResourceProfileId);
          isset_groupResourceProfileId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->configName);
          isset_configName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->configValue);
          this->__isset.configValue = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_resourceId)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_groupResourceProfileId)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_configName)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t GroupAccountSSHProvisionerConfig::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("GroupAccountSSHProvisionerConfig");

  xfer += oprot->writeFieldBegin("resourceId", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->resourceId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("groupResourceProfileId", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->groupResourceProfileId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("configName", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->configName);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.configValue) {
    xfer += oprot->writeFieldBegin("configValue", ::apache::thrift::protocol::T_STRING, 4);
    xfer += oprot->writeString(this->configValue);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(GroupAccountSSHProvisionerConfig &a, GroupAccountSSHProvisionerConfig &b) {
  using ::std::swap;
  swap(a.resourceId, b.resourceId);
  swap(a.groupResourceProfileId, b.groupResourceProfileId);
  swap(a.configName, b.configName);
  swap(a.configValue, b.configValue);
  swap(a.__isset, b.__isset);
}

GroupAccountSSHProvisionerConfig::GroupAccountSSHProvisionerConfig(const GroupAccountSSHProvisionerConfig& other0) {
  resourceId = other0.resourceId;
  groupResourceProfileId = other0.groupResourceProfileId;
  configName = other0.configName;
  configValue = other0.configValue;
  __isset = other0.__isset;
}
GroupAccountSSHProvisionerConfig& GroupAccountSSHProvisionerConfig::operator=(const GroupAccountSSHProvisionerConfig& other1) {
  resourceId = other1.resourceId;
  groupResourceProfileId = other1.groupResourceProfileId;
  configName = other1.configName;
  configValue = other1.configValue;
  __isset = other1.__isset;
  return *this;
}
void GroupAccountSSHProvisionerConfig::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "GroupAccountSSHProvisionerConfig(";
  out << "resourceId=" << to_string(resourceId);
  out << ", " << "groupResourceProfileId=" << to_string(groupResourceProfileId);
  out << ", " << "configName=" << to_string(configName);
  out << ", " << "configValue="; (__isset.configValue ? (out << to_string(configValue)) : (out << "<null>"));
  out << ")";
}


ComputeResourceReservation::~ComputeResourceReservation() throw() {
}


void ComputeResourceReservation::__set_reservationId(const std::string& val) {
  this->reservationId = val;
}

void ComputeResourceReservation::__set_reservationName(const std::string& val) {
  this->reservationName = val;
}

void ComputeResourceReservation::__set_queueNames(const std::vector<std::string> & val) {
  this->queueNames = val;
}

void ComputeResourceReservation::__set_startTime(const int64_t val) {
  this->startTime = val;
}

void ComputeResourceReservation::__set_endTime(const int64_t val) {
  this->endTime = val;
}

uint32_t ComputeResourceReservation::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_reservationId = false;
  bool isset_reservationName = false;
  bool isset_queueNames = false;
  bool isset_startTime = false;
  bool isset_endTime = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->reservationId);
          isset_reservationId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->reservationName);
          isset_reservationName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->queueNames.clear();
            uint32_t _size2;
            ::apache::thrift::protocol::TType _etype5;
            xfer += iprot->readListBegin(_etype5, _size2);
            this->queueNames.resize(_size2);
            uint32_t _i6;
            for (_i6 = 0; _i6 < _size2; ++_i6)
            {
              xfer += iprot->readString(this->queueNames[_i6]);
            }
            xfer += iprot->readListEnd();
          }
          isset_queueNames = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->startTime);
          isset_startTime = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->endTime);
          isset_endTime = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_reservationId)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_reservationName)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_queueNames)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_startTime)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_endTime)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t ComputeResourceReservation::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ComputeResourceReservation");

  xfer += oprot->writeFieldBegin("reservationId", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->reservationId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("reservationName", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->reservationName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("queueNames", ::apache::thrift::protocol::T_LIST, 3);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->queueNames.size()));
    std::vector<std::string> ::const_iterator _iter7;
    for (_iter7 = this->queueNames.begin(); _iter7 != this->queueNames.end(); ++_iter7)
    {
      xfer += oprot->writeString((*_iter7));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("startTime", ::apache::thrift::protocol::T_I64, 4);
  xfer += oprot->writeI64(this->startTime);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("endTime", ::apache::thrift::protocol::T_I64, 5);
  xfer += oprot->writeI64(this->endTime);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ComputeResourceReservation &a, ComputeResourceReservation &b) {
  using ::std::swap;
  swap(a.reservationId, b.reservationId);
  swap(a.reservationName, b.reservationName);
  swap(a.queueNames, b.queueNames);
  swap(a.startTime, b.startTime);
  swap(a.endTime, b.endTime);
}

ComputeResourceReservation::ComputeResourceReservation(const ComputeResourceReservation& other8) {
  reservationId = other8.reservationId;
  reservationName = other8.reservationName;
  queueNames = other8.queueNames;
  startTime = other8.startTime;
  endTime = other8.endTime;
}
ComputeResourceReservation& ComputeResourceReservation::operator=(const ComputeResourceReservation& other9) {
  reservationId = other9.reservationId;
  reservationName = other9.reservationName;
  queueNames = other9.queueNames;
  startTime = other9.startTime;
  endTime = other9.endTime;
  return *this;
}
void ComputeResourceReservation::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "ComputeResourceReservation(";
  out << "reservationId=" << to_string(reservationId);
  out << ", " << "reservationName=" << to_string(reservationName);
  out << ", " << "queueNames=" << to_string(queueNames);
  out << ", " << "startTime=" << to_string(startTime);
  out << ", " << "endTime=" << to_string(endTime);
  out << ")";
}


GroupComputeResourcePreference::~GroupComputeResourcePreference() throw() {
}


void GroupComputeResourcePreference::__set_computeResourceId(const std::string& val) {
  this->computeResourceId = val;
}

void GroupComputeResourcePreference::__set_groupResourceProfileId(const std::string& val) {
  this->groupResourceProfileId = val;
}

void GroupComputeResourcePreference::__set_overridebyAiravata(const bool val) {
  this->overridebyAiravata = val;
}

void GroupComputeResourcePreference::__set_loginUserName(const std::string& val) {
  this->loginUserName = val;
__isset.loginUserName = true;
}

void GroupComputeResourcePreference::__set_preferredJobSubmissionProtocol(const  ::apache::airavata::model::appcatalog::computeresource::JobSubmissionProtocol::type val) {
  this->preferredJobSubmissionProtocol = val;
__isset.preferredJobSubmissionProtocol = true;
}

void GroupComputeResourcePreference::__set_preferredDataMovementProtocol(const  ::apache::airavata::model::data::movement::DataMovementProtocol::type val) {
  this->preferredDataMovementProtocol = val;
__isset.preferredDataMovementProtocol = true;
}

void GroupComputeResourcePreference::__set_preferredBatchQueue(const std::string& val) {
  this->preferredBatchQueue = val;
__isset.preferredBatchQueue = true;
}

void GroupComputeResourcePreference::__set_scratchLocation(const std::string& val) {
  this->scratchLocation = val;
__isset.scratchLocation = true;
}

void GroupComputeResourcePreference::__set_allocationProjectNumber(const std::string& val) {
  this->allocationProjectNumber = val;
__isset.allocationProjectNumber = true;
}

void GroupComputeResourcePreference::__set_resourceSpecificCredentialStoreToken(const std::string& val) {
  this->resourceSpecificCredentialStoreToken = val;
__isset.resourceSpecificCredentialStoreToken = true;
}

void GroupComputeResourcePreference::__set_usageReportingGatewayId(const std::string& val) {
  this->usageReportingGatewayId = val;
__isset.usageReportingGatewayId = true;
}

void GroupComputeResourcePreference::__set_qualityOfService(const std::string& val) {
  this->qualityOfService = val;
__isset.qualityOfService = true;
}

void GroupComputeResourcePreference::__set_sshAccountProvisioner(const std::string& val) {
  this->sshAccountProvisioner = val;
__isset.sshAccountProvisioner = true;
}

void GroupComputeResourcePreference::__set_groupSSHAccountProvisionerConfigs(const std::vector<GroupAccountSSHProvisionerConfig> & val) {
  this->groupSSHAccountProvisionerConfigs = val;
__isset.groupSSHAccountProvisionerConfigs = true;
}

void GroupComputeResourcePreference::__set_sshAccountProvisionerAdditionalInfo(const std::string& val) {
  this->sshAccountProvisionerAdditionalInfo = val;
__isset.sshAccountProvisionerAdditionalInfo = true;
}

void GroupComputeResourcePreference::__set_reservations(const std::vector<ComputeResourceReservation> & val) {
  this->reservations = val;
__isset.reservations = true;
}

uint32_t GroupComputeResourcePreference::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_computeResourceId = false;
  bool isset_groupResourceProfileId = false;
  bool isset_overridebyAiravata = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->computeResourceId);
          isset_computeResourceId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->groupResourceProfileId);
          isset_groupResourceProfileId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->overridebyAiravata);
          isset_overridebyAiravata = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->loginUserName);
          this->__isset.loginUserName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast10;
          xfer += iprot->readI32(ecast10);
          this->preferredJobSubmissionProtocol = ( ::apache::airavata::model::appcatalog::computeresource::JobSubmissionProtocol::type)ecast10;
          this->__isset.preferredJobSubmissionProtocol = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast11;
          xfer += iprot->readI32(ecast11);
          this->preferredDataMovementProtocol = ( ::apache::airavata::model::data::movement::DataMovementProtocol::type)ecast11;
          this->__isset.preferredDataMovementProtocol = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->preferredBatchQueue);
          this->__isset.preferredBatchQueue = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->scratchLocation);
          this->__isset.scratchLocation = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->allocationProjectNumber);
          this->__isset.allocationProjectNumber = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->resourceSpecificCredentialStoreToken);
          this->__isset.resourceSpecificCredentialStoreToken = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 11:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->usageReportingGatewayId);
          this->__isset.usageReportingGatewayId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 12:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->qualityOfService);
          this->__isset.qualityOfService = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 16:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->sshAccountProvisioner);
          this->__isset.sshAccountProvisioner = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 17:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->groupSSHAccountProvisionerConfigs.clear();
            uint32_t _size12;
            ::apache::thrift::protocol::TType _etype15;
            xfer += iprot->readListBegin(_etype15, _size12);
            this->groupSSHAccountProvisionerConfigs.resize(_size12);
            uint32_t _i16;
            for (_i16 = 0; _i16 < _size12; ++_i16)
            {
              xfer += this->groupSSHAccountProvisionerConfigs[_i16].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.groupSSHAccountProvisionerConfigs = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 18:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->sshAccountProvisionerAdditionalInfo);
          this->__isset.sshAccountProvisionerAdditionalInfo = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 19:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->reservations.clear();
            uint32_t _size17;
            ::apache::thrift::protocol::TType _etype20;
            xfer += iprot->readListBegin(_etype20, _size17);
            this->reservations.resize(_size17);
            uint32_t _i21;
            for (_i21 = 0; _i21 < _size17; ++_i21)
            {
              xfer += this->reservations[_i21].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.reservations = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_computeResourceId)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_groupResourceProfileId)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_overridebyAiravata)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t GroupComputeResourcePreference::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("GroupComputeResourcePreference");

  xfer += oprot->writeFieldBegin("computeResourceId", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->computeResourceId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("groupResourceProfileId", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->groupResourceProfileId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("overridebyAiravata", ::apache::thrift::protocol::T_BOOL, 3);
  xfer += oprot->writeBool(this->overridebyAiravata);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.loginUserName) {
    xfer += oprot->writeFieldBegin("loginUserName", ::apache::thrift::protocol::T_STRING, 4);
    xfer += oprot->writeString(this->loginUserName);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.preferredJobSubmissionProtocol) {
    xfer += oprot->writeFieldBegin("preferredJobSubmissionProtocol", ::apache::thrift::protocol::T_I32, 5);
    xfer += oprot->writeI32((int32_t)this->preferredJobSubmissionProtocol);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.preferredDataMovementProtocol) {
    xfer += oprot->writeFieldBegin("preferredDataMovementProtocol", ::apache::thrift::protocol::T_I32, 6);
    xfer += oprot->writeI32((int32_t)this->preferredDataMovementProtocol);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.preferredBatchQueue) {
    xfer += oprot->writeFieldBegin("preferredBatchQueue", ::apache::thrift::protocol::T_STRING, 7);
    xfer += oprot->writeString(this->preferredBatchQueue);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.scratchLocation) {
    xfer += oprot->writeFieldBegin("scratchLocation", ::apache::thrift::protocol::T_STRING, 8);
    xfer += oprot->writeString(this->scratchLocation);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.allocationProjectNumber) {
    xfer += oprot->writeFieldBegin("allocationProjectNumber", ::apache::thrift::protocol::T_STRING, 9);
    xfer += oprot->writeString(this->allocationProjectNumber);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.resourceSpecificCredentialStoreToken) {
    xfer += oprot->writeFieldBegin("resourceSpecificCredentialStoreToken", ::apache::thrift::protocol::T_STRING, 10);
    xfer += oprot->writeString(this->resourceSpecificCredentialStoreToken);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.usageReportingGatewayId) {
    xfer += oprot->writeFieldBegin("usageReportingGatewayId", ::apache::thrift::protocol::T_STRING, 11);
    xfer += oprot->writeString(this->usageReportingGatewayId);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.qualityOfService) {
    xfer += oprot->writeFieldBegin("qualityOfService", ::apache::thrift::protocol::T_STRING, 12);
    xfer += oprot->writeString(this->qualityOfService);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.sshAccountProvisioner) {
    xfer += oprot->writeFieldBegin("sshAccountProvisioner", ::apache::thrift::protocol::T_STRING, 16);
    xfer += oprot->writeString(this->sshAccountProvisioner);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.groupSSHAccountProvisionerConfigs) {
    xfer += oprot->writeFieldBegin("groupSSHAccountProvisionerConfigs", ::apache::thrift::protocol::T_LIST, 17);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->groupSSHAccountProvisionerConfigs.size()));
      std::vector<GroupAccountSSHProvisionerConfig> ::const_iterator _iter22;
      for (_iter22 = this->groupSSHAccountProvisionerConfigs.begin(); _iter22 != this->groupSSHAccountProvisionerConfigs.end(); ++_iter22)
      {
        xfer += (*_iter22).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.sshAccountProvisionerAdditionalInfo) {
    xfer += oprot->writeFieldBegin("sshAccountProvisionerAdditionalInfo", ::apache::thrift::protocol::T_STRING, 18);
    xfer += oprot->writeString(this->sshAccountProvisionerAdditionalInfo);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.reservations) {
    xfer += oprot->writeFieldBegin("reservations", ::apache::thrift::protocol::T_LIST, 19);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->reservations.size()));
      std::vector<ComputeResourceReservation> ::const_iterator _iter23;
      for (_iter23 = this->reservations.begin(); _iter23 != this->reservations.end(); ++_iter23)
      {
        xfer += (*_iter23).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(GroupComputeResourcePreference &a, GroupComputeResourcePreference &b) {
  using ::std::swap;
  swap(a.computeResourceId, b.computeResourceId);
  swap(a.groupResourceProfileId, b.groupResourceProfileId);
  swap(a.overridebyAiravata, b.overridebyAiravata);
  swap(a.loginUserName, b.loginUserName);
  swap(a.preferredJobSubmissionProtocol, b.preferredJobSubmissionProtocol);
  swap(a.preferredDataMovementProtocol, b.preferredDataMovementProtocol);
  swap(a.preferredBatchQueue, b.preferredBatchQueue);
  swap(a.scratchLocation, b.scratchLocation);
  swap(a.allocationProjectNumber, b.allocationProjectNumber);
  swap(a.resourceSpecificCredentialStoreToken, b.resourceSpecificCredentialStoreToken);
  swap(a.usageReportingGatewayId, b.usageReportingGatewayId);
  swap(a.qualityOfService, b.qualityOfService);
  swap(a.sshAccountProvisioner, b.sshAccountProvisioner);
  swap(a.groupSSHAccountProvisionerConfigs, b.groupSSHAccountProvisionerConfigs);
  swap(a.sshAccountProvisionerAdditionalInfo, b.sshAccountProvisionerAdditionalInfo);
  swap(a.reservations, b.reservations);
  swap(a.__isset, b.__isset);
}

GroupComputeResourcePreference::GroupComputeResourcePreference(const GroupComputeResourcePreference& other24) {
  computeResourceId = other24.computeResourceId;
  groupResourceProfileId = other24.groupResourceProfileId;
  overridebyAiravata = other24.overridebyAiravata;
  loginUserName = other24.loginUserName;
  preferredJobSubmissionProtocol = other24.preferredJobSubmissionProtocol;
  preferredDataMovementProtocol = other24.preferredDataMovementProtocol;
  preferredBatchQueue = other24.preferredBatchQueue;
  scratchLocation = other24.scratchLocation;
  allocationProjectNumber = other24.allocationProjectNumber;
  resourceSpecificCredentialStoreToken = other24.resourceSpecificCredentialStoreToken;
  usageReportingGatewayId = other24.usageReportingGatewayId;
  qualityOfService = other24.qualityOfService;
  sshAccountProvisioner = other24.sshAccountProvisioner;
  groupSSHAccountProvisionerConfigs = other24.groupSSHAccountProvisionerConfigs;
  sshAccountProvisionerAdditionalInfo = other24.sshAccountProvisionerAdditionalInfo;
  reservations = other24.reservations;
  __isset = other24.__isset;
}
GroupComputeResourcePreference& GroupComputeResourcePreference::operator=(const GroupComputeResourcePreference& other25) {
  computeResourceId = other25.computeResourceId;
  groupResourceProfileId = other25.groupResourceProfileId;
  overridebyAiravata = other25.overridebyAiravata;
  loginUserName = other25.loginUserName;
  preferredJobSubmissionProtocol = other25.preferredJobSubmissionProtocol;
  preferredDataMovementProtocol = other25.preferredDataMovementProtocol;
  preferredBatchQueue = other25.preferredBatchQueue;
  scratchLocation = other25.scratchLocation;
  allocationProjectNumber = other25.allocationProjectNumber;
  resourceSpecificCredentialStoreToken = other25.resourceSpecificCredentialStoreToken;
  usageReportingGatewayId = other25.usageReportingGatewayId;
  qualityOfService = other25.qualityOfService;
  sshAccountProvisioner = other25.sshAccountProvisioner;
  groupSSHAccountProvisionerConfigs = other25.groupSSHAccountProvisionerConfigs;
  sshAccountProvisionerAdditionalInfo = other25.sshAccountProvisionerAdditionalInfo;
  reservations = other25.reservations;
  __isset = other25.__isset;
  return *this;
}
void GroupComputeResourcePreference::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "GroupComputeResourcePreference(";
  out << "computeResourceId=" << to_string(computeResourceId);
  out << ", " << "groupResourceProfileId=" << to_string(groupResourceProfileId);
  out << ", " << "overridebyAiravata=" << to_string(overridebyAiravata);
  out << ", " << "loginUserName="; (__isset.loginUserName ? (out << to_string(loginUserName)) : (out << "<null>"));
  out << ", " << "preferredJobSubmissionProtocol="; (__isset.preferredJobSubmissionProtocol ? (out << to_string(preferredJobSubmissionProtocol)) : (out << "<null>"));
  out << ", " << "preferredDataMovementProtocol="; (__isset.preferredDataMovementProtocol ? (out << to_string(preferredDataMovementProtocol)) : (out << "<null>"));
  out << ", " << "preferredBatchQueue="; (__isset.preferredBatchQueue ? (out << to_string(preferredBatchQueue)) : (out << "<null>"));
  out << ", " << "scratchLocation="; (__isset.scratchLocation ? (out << to_string(scratchLocation)) : (out << "<null>"));
  out << ", " << "allocationProjectNumber="; (__isset.allocationProjectNumber ? (out << to_string(allocationProjectNumber)) : (out << "<null>"));
  out << ", " << "resourceSpecificCredentialStoreToken="; (__isset.resourceSpecificCredentialStoreToken ? (out << to_string(resourceSpecificCredentialStoreToken)) : (out << "<null>"));
  out << ", " << "usageReportingGatewayId="; (__isset.usageReportingGatewayId ? (out << to_string(usageReportingGatewayId)) : (out << "<null>"));
  out << ", " << "qualityOfService="; (__isset.qualityOfService ? (out << to_string(qualityOfService)) : (out << "<null>"));
  out << ", " << "sshAccountProvisioner="; (__isset.sshAccountProvisioner ? (out << to_string(sshAccountProvisioner)) : (out << "<null>"));
  out << ", " << "groupSSHAccountProvisionerConfigs="; (__isset.groupSSHAccountProvisionerConfigs ? (out << to_string(groupSSHAccountProvisionerConfigs)) : (out << "<null>"));
  out << ", " << "sshAccountProvisionerAdditionalInfo="; (__isset.sshAccountProvisionerAdditionalInfo ? (out << to_string(sshAccountProvisionerAdditionalInfo)) : (out << "<null>"));
  out << ", " << "reservations="; (__isset.reservations ? (out << to_string(reservations)) : (out << "<null>"));
  out << ")";
}


ComputeResourcePolicy::~ComputeResourcePolicy() throw() {
}


void ComputeResourcePolicy::__set_resourcePolicyId(const std::string& val) {
  this->resourcePolicyId = val;
}

void ComputeResourcePolicy::__set_computeResourceId(const std::string& val) {
  this->computeResourceId = val;
}

void ComputeResourcePolicy::__set_groupResourceProfileId(const std::string& val) {
  this->groupResourceProfileId = val;
}

void ComputeResourcePolicy::__set_allowedBatchQueues(const std::vector<std::string> & val) {
  this->allowedBatchQueues = val;
__isset.allowedBatchQueues = true;
}

uint32_t ComputeResourcePolicy::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_resourcePolicyId = false;
  bool isset_computeResourceId = false;
  bool isset_groupResourceProfileId = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->resourcePolicyId);
          isset_resourcePolicyId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->computeResourceId);
          isset_computeResourceId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->groupResourceProfileId);
          isset_groupResourceProfileId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->allowedBatchQueues.clear();
            uint32_t _size26;
            ::apache::thrift::protocol::TType _etype29;
            xfer += iprot->readListBegin(_etype29, _size26);
            this->allowedBatchQueues.resize(_size26);
            uint32_t _i30;
            for (_i30 = 0; _i30 < _size26; ++_i30)
            {
              xfer += iprot->readString(this->allowedBatchQueues[_i30]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.allowedBatchQueues = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_resourcePolicyId)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_computeResourceId)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_groupResourceProfileId)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t ComputeResourcePolicy::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ComputeResourcePolicy");

  xfer += oprot->writeFieldBegin("resourcePolicyId", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->resourcePolicyId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("computeResourceId", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->computeResourceId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("groupResourceProfileId", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->groupResourceProfileId);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.allowedBatchQueues) {
    xfer += oprot->writeFieldBegin("allowedBatchQueues", ::apache::thrift::protocol::T_LIST, 4);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->allowedBatchQueues.size()));
      std::vector<std::string> ::const_iterator _iter31;
      for (_iter31 = this->allowedBatchQueues.begin(); _iter31 != this->allowedBatchQueues.end(); ++_iter31)
      {
        xfer += oprot->writeString((*_iter31));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ComputeResourcePolicy &a, ComputeResourcePolicy &b) {
  using ::std::swap;
  swap(a.resourcePolicyId, b.resourcePolicyId);
  swap(a.computeResourceId, b.computeResourceId);
  swap(a.groupResourceProfileId, b.groupResourceProfileId);
  swap(a.allowedBatchQueues, b.allowedBatchQueues);
  swap(a.__isset, b.__isset);
}

ComputeResourcePolicy::ComputeResourcePolicy(const ComputeResourcePolicy& other32) {
  resourcePolicyId = other32.resourcePolicyId;
  computeResourceId = other32.computeResourceId;
  groupResourceProfileId = other32.groupResourceProfileId;
  allowedBatchQueues = other32.allowedBatchQueues;
  __isset = other32.__isset;
}
ComputeResourcePolicy& ComputeResourcePolicy::operator=(const ComputeResourcePolicy& other33) {
  resourcePolicyId = other33.resourcePolicyId;
  computeResourceId = other33.computeResourceId;
  groupResourceProfileId = other33.groupResourceProfileId;
  allowedBatchQueues = other33.allowedBatchQueues;
  __isset = other33.__isset;
  return *this;
}
void ComputeResourcePolicy::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "ComputeResourcePolicy(";
  out << "resourcePolicyId=" << to_string(resourcePolicyId);
  out << ", " << "computeResourceId=" << to_string(computeResourceId);
  out << ", " << "groupResourceProfileId=" << to_string(groupResourceProfileId);
  out << ", " << "allowedBatchQueues="; (__isset.allowedBatchQueues ? (out << to_string(allowedBatchQueues)) : (out << "<null>"));
  out << ")";
}


BatchQueueResourcePolicy::~BatchQueueResourcePolicy() throw() {
}


void BatchQueueResourcePolicy::__set_resourcePolicyId(const std::string& val) {
  this->resourcePolicyId = val;
}

void BatchQueueResourcePolicy::__set_computeResourceId(const std::string& val) {
  this->computeResourceId = val;
}

void BatchQueueResourcePolicy::__set_groupResourceProfileId(const std::string& val) {
  this->groupResourceProfileId = val;
}

void BatchQueueResourcePolicy::__set_queuename(const std::string& val) {
  this->queuename = val;
__isset.queuename = true;
}

void BatchQueueResourcePolicy::__set_maxAllowedNodes(const int32_t val) {
  this->maxAllowedNodes = val;
__isset.maxAllowedNodes = true;
}

void BatchQueueResourcePolicy::__set_maxAllowedCores(const int32_t val) {
  this->maxAllowedCores = val;
__isset.maxAllowedCores = true;
}

void BatchQueueResourcePolicy::__set_maxAllowedWalltime(const int32_t val) {
  this->maxAllowedWalltime = val;
__isset.maxAllowedWalltime = true;
}

uint32_t BatchQueueResourcePolicy::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_resourcePolicyId = false;
  bool isset_computeResourceId = false;
  bool isset_groupResourceProfileId = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->resourcePolicyId);
          isset_resourcePolicyId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->computeResourceId);
          isset_computeResourceId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->groupResourceProfileId);
          isset_groupResourceProfileId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->queuename);
          this->__isset.queuename = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->maxAllowedNodes);
          this->__isset.maxAllowedNodes = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->maxAllowedCores);
          this->__isset.maxAllowedCores = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->maxAllowedWalltime);
          this->__isset.maxAllowedWalltime = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_resourcePolicyId)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_computeResourceId)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_groupResourceProfileId)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t BatchQueueResourcePolicy::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("BatchQueueResourcePolicy");

  xfer += oprot->writeFieldBegin("resourcePolicyId", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->resourcePolicyId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("computeResourceId", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->computeResourceId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("groupResourceProfileId", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->groupResourceProfileId);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.queuename) {
    xfer += oprot->writeFieldBegin("queuename", ::apache::thrift::protocol::T_STRING, 4);
    xfer += oprot->writeString(this->queuename);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.maxAllowedNodes) {
    xfer += oprot->writeFieldBegin("maxAllowedNodes", ::apache::thrift::protocol::T_I32, 5);
    xfer += oprot->writeI32(this->maxAllowedNodes);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.maxAllowedCores) {
    xfer += oprot->writeFieldBegin("maxAllowedCores", ::apache::thrift::protocol::T_I32, 6);
    xfer += oprot->writeI32(this->maxAllowedCores);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.maxAllowedWalltime) {
    xfer += oprot->writeFieldBegin("maxAllowedWalltime", ::apache::thrift::protocol::T_I32, 7);
    xfer += oprot->writeI32(this->maxAllowedWalltime);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(BatchQueueResourcePolicy &a, BatchQueueResourcePolicy &b) {
  using ::std::swap;
  swap(a.resourcePolicyId, b.resourcePolicyId);
  swap(a.computeResourceId, b.computeResourceId);
  swap(a.groupResourceProfileId, b.groupResourceProfileId);
  swap(a.queuename, b.queuename);
  swap(a.maxAllowedNodes, b.maxAllowedNodes);
  swap(a.maxAllowedCores, b.maxAllowedCores);
  swap(a.maxAllowedWalltime, b.maxAllowedWalltime);
  swap(a.__isset, b.__isset);
}

BatchQueueResourcePolicy::BatchQueueResourcePolicy(const BatchQueueResourcePolicy& other34) {
  resourcePolicyId = other34.resourcePolicyId;
  computeResourceId = other34.computeResourceId;
  groupResourceProfileId = other34.groupResourceProfileId;
  queuename = other34.queuename;
  maxAllowedNodes = other34.maxAllowedNodes;
  maxAllowedCores = other34.maxAllowedCores;
  maxAllowedWalltime = other34.maxAllowedWalltime;
  __isset = other34.__isset;
}
BatchQueueResourcePolicy& BatchQueueResourcePolicy::operator=(const BatchQueueResourcePolicy& other35) {
  resourcePolicyId = other35.resourcePolicyId;
  computeResourceId = other35.computeResourceId;
  groupResourceProfileId = other35.groupResourceProfileId;
  queuename = other35.queuename;
  maxAllowedNodes = other35.maxAllowedNodes;
  maxAllowedCores = other35.maxAllowedCores;
  maxAllowedWalltime = other35.maxAllowedWalltime;
  __isset = other35.__isset;
  return *this;
}
void BatchQueueResourcePolicy::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "BatchQueueResourcePolicy(";
  out << "resourcePolicyId=" << to_string(resourcePolicyId);
  out << ", " << "computeResourceId=" << to_string(computeResourceId);
  out << ", " << "groupResourceProfileId=" << to_string(groupResourceProfileId);
  out << ", " << "queuename="; (__isset.queuename ? (out << to_string(queuename)) : (out << "<null>"));
  out << ", " << "maxAllowedNodes="; (__isset.maxAllowedNodes ? (out << to_string(maxAllowedNodes)) : (out << "<null>"));
  out << ", " << "maxAllowedCores="; (__isset.maxAllowedCores ? (out << to_string(maxAllowedCores)) : (out << "<null>"));
  out << ", " << "maxAllowedWalltime="; (__isset.maxAllowedWalltime ? (out << to_string(maxAllowedWalltime)) : (out << "<null>"));
  out << ")";
}


GroupResourceProfile::~GroupResourceProfile() throw() {
}


void GroupResourceProfile::__set_gatewayId(const std::string& val) {
  this->gatewayId = val;
}

void GroupResourceProfile::__set_groupResourceProfileId(const std::string& val) {
  this->groupResourceProfileId = val;
}

void GroupResourceProfile::__set_groupResourceProfileName(const std::string& val) {
  this->groupResourceProfileName = val;
__isset.groupResourceProfileName = true;
}

void GroupResourceProfile::__set_computePreferences(const std::vector<GroupComputeResourcePreference> & val) {
  this->computePreferences = val;
__isset.computePreferences = true;
}

void GroupResourceProfile::__set_computeResourcePolicies(const std::vector<ComputeResourcePolicy> & val) {
  this->computeResourcePolicies = val;
__isset.computeResourcePolicies = true;
}

void GroupResourceProfile::__set_batchQueueResourcePolicies(const std::vector<BatchQueueResourcePolicy> & val) {
  this->batchQueueResourcePolicies = val;
__isset.batchQueueResourcePolicies = true;
}

void GroupResourceProfile::__set_creationTime(const int64_t val) {
  this->creationTime = val;
__isset.creationTime = true;
}

void GroupResourceProfile::__set_updatedTime(const int64_t val) {
  this->updatedTime = val;
__isset.updatedTime = true;
}

void GroupResourceProfile::__set_defaultCredentialStoreToken(const std::string& val) {
  this->defaultCredentialStoreToken = val;
__isset.defaultCredentialStoreToken = true;
}

uint32_t GroupResourceProfile::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_gatewayId = false;
  bool isset_groupResourceProfileId = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->gatewayId);
          isset_gatewayId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->groupResourceProfileId);
          isset_groupResourceProfileId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->groupResourceProfileName);
          this->__isset.groupResourceProfileName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->computePreferences.clear();
            uint32_t _size36;
            ::apache::thrift::protocol::TType _etype39;
            xfer += iprot->readListBegin(_etype39, _size36);
            this->computePreferences.resize(_size36);
            uint32_t _i40;
            for (_i40 = 0; _i40 < _size36; ++_i40)
            {
              xfer += this->computePreferences[_i40].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.computePreferences = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->computeResourcePolicies.clear();
            uint32_t _size41;
            ::apache::thrift::protocol::TType _etype44;
            xfer += iprot->readListBegin(_etype44, _size41);
            this->computeResourcePolicies.resize(_size41);
            uint32_t _i45;
            for (_i45 = 0; _i45 < _size41; ++_i45)
            {
              xfer += this->computeResourcePolicies[_i45].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.computeResourcePolicies = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->batchQueueResourcePolicies.clear();
            uint32_t _size46;
            ::apache::thrift::protocol::TType _etype49;
            xfer += iprot->readListBegin(_etype49, _size46);
            this->batchQueueResourcePolicies.resize(_size46);
            uint32_t _i50;
            for (_i50 = 0; _i50 < _size46; ++_i50)
            {
              xfer += this->batchQueueResourcePolicies[_i50].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.batchQueueResourcePolicies = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->creationTime);
          this->__isset.creationTime = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->updatedTime);
          this->__isset.updatedTime = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->defaultCredentialStoreToken);
          this->__isset.defaultCredentialStoreToken = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_gatewayId)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_groupResourceProfileId)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t GroupResourceProfile::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("GroupResourceProfile");

  xfer += oprot->writeFieldBegin("gatewayId", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->gatewayId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("groupResourceProfileId", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->groupResourceProfileId);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.groupResourceProfileName) {
    xfer += oprot->writeFieldBegin("groupResourceProfileName", ::apache::thrift::protocol::T_STRING, 3);
    xfer += oprot->writeString(this->groupResourceProfileName);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.computePreferences) {
    xfer += oprot->writeFieldBegin("computePreferences", ::apache::thrift::protocol::T_LIST, 4);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->computePreferences.size()));
      std::vector<GroupComputeResourcePreference> ::const_iterator _iter51;
      for (_iter51 = this->computePreferences.begin(); _iter51 != this->computePreferences.end(); ++_iter51)
      {
        xfer += (*_iter51).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.computeResourcePolicies) {
    xfer += oprot->writeFieldBegin("computeResourcePolicies", ::apache::thrift::protocol::T_LIST, 5);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->computeResourcePolicies.size()));
      std::vector<ComputeResourcePolicy> ::const_iterator _iter52;
      for (_iter52 = this->computeResourcePolicies.begin(); _iter52 != this->computeResourcePolicies.end(); ++_iter52)
      {
        xfer += (*_iter52).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.batchQueueResourcePolicies) {
    xfer += oprot->writeFieldBegin("batchQueueResourcePolicies", ::apache::thrift::protocol::T_LIST, 6);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->batchQueueResourcePolicies.size()));
      std::vector<BatchQueueResourcePolicy> ::const_iterator _iter53;
      for (_iter53 = this->batchQueueResourcePolicies.begin(); _iter53 != this->batchQueueResourcePolicies.end(); ++_iter53)
      {
        xfer += (*_iter53).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.creationTime) {
    xfer += oprot->writeFieldBegin("creationTime", ::apache::thrift::protocol::T_I64, 7);
    xfer += oprot->writeI64(this->creationTime);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.updatedTime) {
    xfer += oprot->writeFieldBegin("updatedTime", ::apache::thrift::protocol::T_I64, 8);
    xfer += oprot->writeI64(this->updatedTime);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.defaultCredentialStoreToken) {
    xfer += oprot->writeFieldBegin("defaultCredentialStoreToken", ::apache::thrift::protocol::T_STRING, 9);
    xfer += oprot->writeString(this->defaultCredentialStoreToken);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(GroupResourceProfile &a, GroupResourceProfile &b) {
  using ::std::swap;
  swap(a.gatewayId, b.gatewayId);
  swap(a.groupResourceProfileId, b.groupResourceProfileId);
  swap(a.groupResourceProfileName, b.groupResourceProfileName);
  swap(a.computePreferences, b.computePreferences);
  swap(a.computeResourcePolicies, b.computeResourcePolicies);
  swap(a.batchQueueResourcePolicies, b.batchQueueResourcePolicies);
  swap(a.creationTime, b.creationTime);
  swap(a.updatedTime, b.updatedTime);
  swap(a.defaultCredentialStoreToken, b.defaultCredentialStoreToken);
  swap(a.__isset, b.__isset);
}

GroupResourceProfile::GroupResourceProfile(const GroupResourceProfile& other54) {
  gatewayId = other54.gatewayId;
  groupResourceProfileId = other54.groupResourceProfileId;
  groupResourceProfileName = other54.groupResourceProfileName;
  computePreferences = other54.computePreferences;
  computeResourcePolicies = other54.computeResourcePolicies;
  batchQueueResourcePolicies = other54.batchQueueResourcePolicies;
  creationTime = other54.creationTime;
  updatedTime = other54.updatedTime;
  defaultCredentialStoreToken = other54.defaultCredentialStoreToken;
  __isset = other54.__isset;
}
GroupResourceProfile& GroupResourceProfile::operator=(const GroupResourceProfile& other55) {
  gatewayId = other55.gatewayId;
  groupResourceProfileId = other55.groupResourceProfileId;
  groupResourceProfileName = other55.groupResourceProfileName;
  computePreferences = other55.computePreferences;
  computeResourcePolicies = other55.computeResourcePolicies;
  batchQueueResourcePolicies = other55.batchQueueResourcePolicies;
  creationTime = other55.creationTime;
  updatedTime = other55.updatedTime;
  defaultCredentialStoreToken = other55.defaultCredentialStoreToken;
  __isset = other55.__isset;
  return *this;
}
void GroupResourceProfile::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "GroupResourceProfile(";
  out << "gatewayId=" << to_string(gatewayId);
  out << ", " << "groupResourceProfileId=" << to_string(groupResourceProfileId);
  out << ", " << "groupResourceProfileName="; (__isset.groupResourceProfileName ? (out << to_string(groupResourceProfileName)) : (out << "<null>"));
  out << ", " << "computePreferences="; (__isset.computePreferences ? (out << to_string(computePreferences)) : (out << "<null>"));
  out << ", " << "computeResourcePolicies="; (__isset.computeResourcePolicies ? (out << to_string(computeResourcePolicies)) : (out << "<null>"));
  out << ", " << "batchQueueResourcePolicies="; (__isset.batchQueueResourcePolicies ? (out << to_string(batchQueueResourcePolicies)) : (out << "<null>"));
  out << ", " << "creationTime="; (__isset.creationTime ? (out << to_string(creationTime)) : (out << "<null>"));
  out << ", " << "updatedTime="; (__isset.updatedTime ? (out << to_string(updatedTime)) : (out << "<null>"));
  out << ", " << "defaultCredentialStoreToken="; (__isset.defaultCredentialStoreToken ? (out << to_string(defaultCredentialStoreToken)) : (out << "<null>"));
  out << ")";
}

}}}}} // namespace
