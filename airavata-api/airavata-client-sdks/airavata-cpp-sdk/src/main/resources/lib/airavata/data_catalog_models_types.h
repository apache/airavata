/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Autogenerated by Thrift Compiler (0.9.3)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#ifndef data_catalog_models_TYPES_H
#define data_catalog_models_TYPES_H

#include <iosfwd>

#include <thrift/Thrift.h>
#include <thrift/TApplicationException.h>
#include <thrift/protocol/TProtocol.h>
#include <thrift/transport/TTransport.h>

#include <thrift/cxxfunctional.h>


namespace apache { namespace airavata { namespace model { namespace data { namespace product {

struct ReplicaLocationCategory {
  enum type {
    GATEWAY_DATA_STORE = 0,
    COMPUTE_RESOURCE = 1,
    LONG_TERM_STORAGE_RESOURCE = 2,
    OTHER = 3
  };
};

extern const std::map<int, const char*> _ReplicaLocationCategory_VALUES_TO_NAMES;

struct ReplicaPersistentType {
  enum type {
    TRANSIENT = 0,
    PERSISTENT = 1
  };
};

extern const std::map<int, const char*> _ReplicaPersistentType_VALUES_TO_NAMES;

struct DataProductType {
  enum type {
    DIR = 0,
    FILE = 1,
    COLLECTION = 2
  };
};

extern const std::map<int, const char*> _DataProductType_VALUES_TO_NAMES;

class DataProductModel;

class DataReplicaLocationModel;

typedef struct _DataProductModel__isset {
  _DataProductModel__isset() : productUri(false), gatewayId(false), parentProductUri(false), logicalPath(false), productName(false), productDescription(false), ownerName(false), dataProductType(false), productSize(false), creationTime(false), lastModifiedTime(false), productMetadata(false), replicaLocations(false), childProducts(false) {}
  bool productUri :1;
  bool gatewayId :1;
  bool parentProductUri :1;
  bool logicalPath :1;
  bool productName :1;
  bool productDescription :1;
  bool ownerName :1;
  bool dataProductType :1;
  bool productSize :1;
  bool creationTime :1;
  bool lastModifiedTime :1;
  bool productMetadata :1;
  bool replicaLocations :1;
  bool childProducts :1;
} _DataProductModel__isset;

class DataProductModel {
 public:

  DataProductModel(const DataProductModel&);
  DataProductModel& operator=(const DataProductModel&);
  DataProductModel() : productUri(), gatewayId(), parentProductUri(), logicalPath(), productName(), productDescription(), ownerName(), dataProductType((DataProductType::type)0), productSize(0), creationTime(0), lastModifiedTime(0) {
  }

  virtual ~DataProductModel() throw();
  std::string productUri;
  std::string gatewayId;
  std::string parentProductUri;
  std::string logicalPath;
  std::string productName;
  std::string productDescription;
  std::string ownerName;
  DataProductType::type dataProductType;
  int32_t productSize;
  int64_t creationTime;
  int64_t lastModifiedTime;
  std::map<std::string, std::string>  productMetadata;
  std::vector<DataReplicaLocationModel>  replicaLocations;
  std::vector<DataProductModel>  childProducts;

  _DataProductModel__isset __isset;

  void __set_productUri(const std::string& val);

  void __set_gatewayId(const std::string& val);

  void __set_parentProductUri(const std::string& val);

  void __set_logicalPath(const std::string& val);

  void __set_productName(const std::string& val);

  void __set_productDescription(const std::string& val);

  void __set_ownerName(const std::string& val);

  void __set_dataProductType(const DataProductType::type val);

  void __set_productSize(const int32_t val);

  void __set_creationTime(const int64_t val);

  void __set_lastModifiedTime(const int64_t val);

  void __set_productMetadata(const std::map<std::string, std::string> & val);

  void __set_replicaLocations(const std::vector<DataReplicaLocationModel> & val);

  void __set_childProducts(const std::vector<DataProductModel> & val);

  bool operator == (const DataProductModel & rhs) const
  {
    if (__isset.productUri != rhs.__isset.productUri)
      return false;
    else if (__isset.productUri && !(productUri == rhs.productUri))
      return false;
    if (__isset.gatewayId != rhs.__isset.gatewayId)
      return false;
    else if (__isset.gatewayId && !(gatewayId == rhs.gatewayId))
      return false;
    if (__isset.parentProductUri != rhs.__isset.parentProductUri)
      return false;
    else if (__isset.parentProductUri && !(parentProductUri == rhs.parentProductUri))
      return false;
    if (__isset.logicalPath != rhs.__isset.logicalPath)
      return false;
    else if (__isset.logicalPath && !(logicalPath == rhs.logicalPath))
      return false;
    if (__isset.productName != rhs.__isset.productName)
      return false;
    else if (__isset.productName && !(productName == rhs.productName))
      return false;
    if (__isset.productDescription != rhs.__isset.productDescription)
      return false;
    else if (__isset.productDescription && !(productDescription == rhs.productDescription))
      return false;
    if (__isset.ownerName != rhs.__isset.ownerName)
      return false;
    else if (__isset.ownerName && !(ownerName == rhs.ownerName))
      return false;
    if (__isset.dataProductType != rhs.__isset.dataProductType)
      return false;
    else if (__isset.dataProductType && !(dataProductType == rhs.dataProductType))
      return false;
    if (__isset.productSize != rhs.__isset.productSize)
      return false;
    else if (__isset.productSize && !(productSize == rhs.productSize))
      return false;
    if (__isset.creationTime != rhs.__isset.creationTime)
      return false;
    else if (__isset.creationTime && !(creationTime == rhs.creationTime))
      return false;
    if (__isset.lastModifiedTime != rhs.__isset.lastModifiedTime)
      return false;
    else if (__isset.lastModifiedTime && !(lastModifiedTime == rhs.lastModifiedTime))
      return false;
    if (__isset.productMetadata != rhs.__isset.productMetadata)
      return false;
    else if (__isset.productMetadata && !(productMetadata == rhs.productMetadata))
      return false;
    if (__isset.replicaLocations != rhs.__isset.replicaLocations)
      return false;
    else if (__isset.replicaLocations && !(replicaLocations == rhs.replicaLocations))
      return false;
    if (__isset.childProducts != rhs.__isset.childProducts)
      return false;
    else if (__isset.childProducts && !(childProducts == rhs.childProducts))
      return false;
    return true;
  }
  bool operator != (const DataProductModel &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const DataProductModel & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(DataProductModel &a, DataProductModel &b);

inline std::ostream& operator<<(std::ostream& out, const DataProductModel& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _DataReplicaLocationModel__isset {
  _DataReplicaLocationModel__isset() : replicaId(false), productUri(false), replicaName(false), replicaDescription(false), creationTime(false), lastModifiedTime(false), validUntilTime(false), replicaLocationCategory(false), replicaPersistentType(false), storageResourceId(false), filePath(false), replicaMetadata(false) {}
  bool replicaId :1;
  bool productUri :1;
  bool replicaName :1;
  bool replicaDescription :1;
  bool creationTime :1;
  bool lastModifiedTime :1;
  bool validUntilTime :1;
  bool replicaLocationCategory :1;
  bool replicaPersistentType :1;
  bool storageResourceId :1;
  bool filePath :1;
  bool replicaMetadata :1;
} _DataReplicaLocationModel__isset;

class DataReplicaLocationModel {
 public:

  DataReplicaLocationModel(const DataReplicaLocationModel&);
  DataReplicaLocationModel& operator=(const DataReplicaLocationModel&);
  DataReplicaLocationModel() : replicaId(), productUri(), replicaName(), replicaDescription(), creationTime(0), lastModifiedTime(0), validUntilTime(0), replicaLocationCategory((ReplicaLocationCategory::type)0), replicaPersistentType((ReplicaPersistentType::type)0), storageResourceId(), filePath() {
  }

  virtual ~DataReplicaLocationModel() throw();
  std::string replicaId;
  std::string productUri;
  std::string replicaName;
  std::string replicaDescription;
  int64_t creationTime;
  int64_t lastModifiedTime;
  int64_t validUntilTime;
  ReplicaLocationCategory::type replicaLocationCategory;
  ReplicaPersistentType::type replicaPersistentType;
  std::string storageResourceId;
  std::string filePath;
  std::map<std::string, std::string>  replicaMetadata;

  _DataReplicaLocationModel__isset __isset;

  void __set_replicaId(const std::string& val);

  void __set_productUri(const std::string& val);

  void __set_replicaName(const std::string& val);

  void __set_replicaDescription(const std::string& val);

  void __set_creationTime(const int64_t val);

  void __set_lastModifiedTime(const int64_t val);

  void __set_validUntilTime(const int64_t val);

  void __set_replicaLocationCategory(const ReplicaLocationCategory::type val);

  void __set_replicaPersistentType(const ReplicaPersistentType::type val);

  void __set_storageResourceId(const std::string& val);

  void __set_filePath(const std::string& val);

  void __set_replicaMetadata(const std::map<std::string, std::string> & val);

  bool operator == (const DataReplicaLocationModel & rhs) const
  {
    if (__isset.replicaId != rhs.__isset.replicaId)
      return false;
    else if (__isset.replicaId && !(replicaId == rhs.replicaId))
      return false;
    if (__isset.productUri != rhs.__isset.productUri)
      return false;
    else if (__isset.productUri && !(productUri == rhs.productUri))
      return false;
    if (__isset.replicaName != rhs.__isset.replicaName)
      return false;
    else if (__isset.replicaName && !(replicaName == rhs.replicaName))
      return false;
    if (__isset.replicaDescription != rhs.__isset.replicaDescription)
      return false;
    else if (__isset.replicaDescription && !(replicaDescription == rhs.replicaDescription))
      return false;
    if (__isset.creationTime != rhs.__isset.creationTime)
      return false;
    else if (__isset.creationTime && !(creationTime == rhs.creationTime))
      return false;
    if (__isset.lastModifiedTime != rhs.__isset.lastModifiedTime)
      return false;
    else if (__isset.lastModifiedTime && !(lastModifiedTime == rhs.lastModifiedTime))
      return false;
    if (__isset.validUntilTime != rhs.__isset.validUntilTime)
      return false;
    else if (__isset.validUntilTime && !(validUntilTime == rhs.validUntilTime))
      return false;
    if (__isset.replicaLocationCategory != rhs.__isset.replicaLocationCategory)
      return false;
    else if (__isset.replicaLocationCategory && !(replicaLocationCategory == rhs.replicaLocationCategory))
      return false;
    if (__isset.replicaPersistentType != rhs.__isset.replicaPersistentType)
      return false;
    else if (__isset.replicaPersistentType && !(replicaPersistentType == rhs.replicaPersistentType))
      return false;
    if (__isset.storageResourceId != rhs.__isset.storageResourceId)
      return false;
    else if (__isset.storageResourceId && !(storageResourceId == rhs.storageResourceId))
      return false;
    if (__isset.filePath != rhs.__isset.filePath)
      return false;
    else if (__isset.filePath && !(filePath == rhs.filePath))
      return false;
    if (__isset.replicaMetadata != rhs.__isset.replicaMetadata)
      return false;
    else if (__isset.replicaMetadata && !(replicaMetadata == rhs.replicaMetadata))
      return false;
    return true;
  }
  bool operator != (const DataReplicaLocationModel &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const DataReplicaLocationModel & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(DataReplicaLocationModel &a, DataReplicaLocationModel &b);

inline std::ostream& operator<<(std::ostream& out, const DataReplicaLocationModel& obj)
{
  obj.printTo(out);
  return out;
}

}}}}} // namespace

#endif
