/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Autogenerated by Thrift Compiler (0.10.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#ifndef group_resource_profile_model_TYPES_H
#define group_resource_profile_model_TYPES_H

#include <iosfwd>

#include <thrift/Thrift.h>
#include <thrift/TApplicationException.h>
#include <thrift/TBase.h>
#include <thrift/protocol/TProtocol.h>
#include <thrift/transport/TTransport.h>

#include <thrift/cxxfunctional.h>
#include "airavata_commons_types.h"
#include "compute_resource_model_types.h"
#include "data_movement_models_types.h"


namespace apache { namespace airavata { namespace model { namespace appcatalog { namespace groupresourceprofile {

class GroupAccountSSHProvisionerConfig;

class GroupComputeResourcePreference;

class ComputeResourcePolicy;

class BatchQueueResourcePolicy;

class GroupResourceProfile;

typedef struct _GroupAccountSSHProvisionerConfig__isset {
  _GroupAccountSSHProvisionerConfig__isset() : configValue(false) {}
  bool configValue :1;
} _GroupAccountSSHProvisionerConfig__isset;

class GroupAccountSSHProvisionerConfig : public virtual ::apache::thrift::TBase {
 public:

  GroupAccountSSHProvisionerConfig(const GroupAccountSSHProvisionerConfig&);
  GroupAccountSSHProvisionerConfig& operator=(const GroupAccountSSHProvisionerConfig&);
  GroupAccountSSHProvisionerConfig() : resourceId(), groupResourceProfileId("DO_NOT_SET_AT_CLIENTS"), configName(), configValue() {
  }

  virtual ~GroupAccountSSHProvisionerConfig() throw();
  std::string resourceId;
  std::string groupResourceProfileId;
  std::string configName;
  std::string configValue;

  _GroupAccountSSHProvisionerConfig__isset __isset;

  void __set_resourceId(const std::string& val);

  void __set_groupResourceProfileId(const std::string& val);

  void __set_configName(const std::string& val);

  void __set_configValue(const std::string& val);

  bool operator == (const GroupAccountSSHProvisionerConfig & rhs) const
  {
    if (!(resourceId == rhs.resourceId))
      return false;
    if (!(groupResourceProfileId == rhs.groupResourceProfileId))
      return false;
    if (!(configName == rhs.configName))
      return false;
    if (__isset.configValue != rhs.__isset.configValue)
      return false;
    else if (__isset.configValue && !(configValue == rhs.configValue))
      return false;
    return true;
  }
  bool operator != (const GroupAccountSSHProvisionerConfig &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const GroupAccountSSHProvisionerConfig & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(GroupAccountSSHProvisionerConfig &a, GroupAccountSSHProvisionerConfig &b);

inline std::ostream& operator<<(std::ostream& out, const GroupAccountSSHProvisionerConfig& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _GroupComputeResourcePreference__isset {
  _GroupComputeResourcePreference__isset() : loginUserName(false), preferredJobSubmissionProtocol(false), preferredDataMovementProtocol(false), preferredBatchQueue(false), scratchLocation(false), allocationProjectNumber(false), resourceSpecificCredentialStoreToken(false), usageReportingGatewayId(false), qualityOfService(false), reservation(false), reservationStartTime(false), reservationEndTime(false), sshAccountProvisioner(false), groupSSHAccountProvisionerConfigs(false), sshAccountProvisionerAdditionalInfo(false) {}
  bool loginUserName :1;
  bool preferredJobSubmissionProtocol :1;
  bool preferredDataMovementProtocol :1;
  bool preferredBatchQueue :1;
  bool scratchLocation :1;
  bool allocationProjectNumber :1;
  bool resourceSpecificCredentialStoreToken :1;
  bool usageReportingGatewayId :1;
  bool qualityOfService :1;
  bool reservation :1;
  bool reservationStartTime :1;
  bool reservationEndTime :1;
  bool sshAccountProvisioner :1;
  bool groupSSHAccountProvisionerConfigs :1;
  bool sshAccountProvisionerAdditionalInfo :1;
} _GroupComputeResourcePreference__isset;

class GroupComputeResourcePreference : public virtual ::apache::thrift::TBase {
 public:

  GroupComputeResourcePreference(const GroupComputeResourcePreference&);
  GroupComputeResourcePreference& operator=(const GroupComputeResourcePreference&);
  GroupComputeResourcePreference() : computeResourceId(), groupResourceProfileId("DO_NOT_SET_AT_CLIENTS"), overridebyAiravata(true), loginUserName(), preferredJobSubmissionProtocol(( ::apache::airavata::model::appcatalog::computeresource::JobSubmissionProtocol::type)0), preferredDataMovementProtocol(( ::apache::airavata::model::data::movement::DataMovementProtocol::type)0), preferredBatchQueue(), scratchLocation(), allocationProjectNumber(), resourceSpecificCredentialStoreToken(), usageReportingGatewayId(), qualityOfService(), reservation(), reservationStartTime(0), reservationEndTime(0), sshAccountProvisioner(), sshAccountProvisionerAdditionalInfo() {
  }

  virtual ~GroupComputeResourcePreference() throw();
  std::string computeResourceId;
  std::string groupResourceProfileId;
  bool overridebyAiravata;
  std::string loginUserName;
   ::apache::airavata::model::appcatalog::computeresource::JobSubmissionProtocol::type preferredJobSubmissionProtocol;
   ::apache::airavata::model::data::movement::DataMovementProtocol::type preferredDataMovementProtocol;
  std::string preferredBatchQueue;
  std::string scratchLocation;
  std::string allocationProjectNumber;
  std::string resourceSpecificCredentialStoreToken;
  std::string usageReportingGatewayId;
  std::string qualityOfService;
  std::string reservation;
  int64_t reservationStartTime;
  int64_t reservationEndTime;
  std::string sshAccountProvisioner;
  std::vector<GroupAccountSSHProvisionerConfig>  groupSSHAccountProvisionerConfigs;
  std::string sshAccountProvisionerAdditionalInfo;

  _GroupComputeResourcePreference__isset __isset;

  void __set_computeResourceId(const std::string& val);

  void __set_groupResourceProfileId(const std::string& val);

  void __set_overridebyAiravata(const bool val);

  void __set_loginUserName(const std::string& val);

  void __set_preferredJobSubmissionProtocol(const  ::apache::airavata::model::appcatalog::computeresource::JobSubmissionProtocol::type val);

  void __set_preferredDataMovementProtocol(const  ::apache::airavata::model::data::movement::DataMovementProtocol::type val);

  void __set_preferredBatchQueue(const std::string& val);

  void __set_scratchLocation(const std::string& val);

  void __set_allocationProjectNumber(const std::string& val);

  void __set_resourceSpecificCredentialStoreToken(const std::string& val);

  void __set_usageReportingGatewayId(const std::string& val);

  void __set_qualityOfService(const std::string& val);

  void __set_reservation(const std::string& val);

  void __set_reservationStartTime(const int64_t val);

  void __set_reservationEndTime(const int64_t val);

  void __set_sshAccountProvisioner(const std::string& val);

  void __set_groupSSHAccountProvisionerConfigs(const std::vector<GroupAccountSSHProvisionerConfig> & val);

  void __set_sshAccountProvisionerAdditionalInfo(const std::string& val);

  bool operator == (const GroupComputeResourcePreference & rhs) const
  {
    if (!(computeResourceId == rhs.computeResourceId))
      return false;
    if (!(groupResourceProfileId == rhs.groupResourceProfileId))
      return false;
    if (!(overridebyAiravata == rhs.overridebyAiravata))
      return false;
    if (__isset.loginUserName != rhs.__isset.loginUserName)
      return false;
    else if (__isset.loginUserName && !(loginUserName == rhs.loginUserName))
      return false;
    if (__isset.preferredJobSubmissionProtocol != rhs.__isset.preferredJobSubmissionProtocol)
      return false;
    else if (__isset.preferredJobSubmissionProtocol && !(preferredJobSubmissionProtocol == rhs.preferredJobSubmissionProtocol))
      return false;
    if (__isset.preferredDataMovementProtocol != rhs.__isset.preferredDataMovementProtocol)
      return false;
    else if (__isset.preferredDataMovementProtocol && !(preferredDataMovementProtocol == rhs.preferredDataMovementProtocol))
      return false;
    if (__isset.preferredBatchQueue != rhs.__isset.preferredBatchQueue)
      return false;
    else if (__isset.preferredBatchQueue && !(preferredBatchQueue == rhs.preferredBatchQueue))
      return false;
    if (__isset.scratchLocation != rhs.__isset.scratchLocation)
      return false;
    else if (__isset.scratchLocation && !(scratchLocation == rhs.scratchLocation))
      return false;
    if (__isset.allocationProjectNumber != rhs.__isset.allocationProjectNumber)
      return false;
    else if (__isset.allocationProjectNumber && !(allocationProjectNumber == rhs.allocationProjectNumber))
      return false;
    if (__isset.resourceSpecificCredentialStoreToken != rhs.__isset.resourceSpecificCredentialStoreToken)
      return false;
    else if (__isset.resourceSpecificCredentialStoreToken && !(resourceSpecificCredentialStoreToken == rhs.resourceSpecificCredentialStoreToken))
      return false;
    if (__isset.usageReportingGatewayId != rhs.__isset.usageReportingGatewayId)
      return false;
    else if (__isset.usageReportingGatewayId && !(usageReportingGatewayId == rhs.usageReportingGatewayId))
      return false;
    if (__isset.qualityOfService != rhs.__isset.qualityOfService)
      return false;
    else if (__isset.qualityOfService && !(qualityOfService == rhs.qualityOfService))
      return false;
    if (__isset.reservation != rhs.__isset.reservation)
      return false;
    else if (__isset.reservation && !(reservation == rhs.reservation))
      return false;
    if (__isset.reservationStartTime != rhs.__isset.reservationStartTime)
      return false;
    else if (__isset.reservationStartTime && !(reservationStartTime == rhs.reservationStartTime))
      return false;
    if (__isset.reservationEndTime != rhs.__isset.reservationEndTime)
      return false;
    else if (__isset.reservationEndTime && !(reservationEndTime == rhs.reservationEndTime))
      return false;
    if (__isset.sshAccountProvisioner != rhs.__isset.sshAccountProvisioner)
      return false;
    else if (__isset.sshAccountProvisioner && !(sshAccountProvisioner == rhs.sshAccountProvisioner))
      return false;
    if (__isset.groupSSHAccountProvisionerConfigs != rhs.__isset.groupSSHAccountProvisionerConfigs)
      return false;
    else if (__isset.groupSSHAccountProvisionerConfigs && !(groupSSHAccountProvisionerConfigs == rhs.groupSSHAccountProvisionerConfigs))
      return false;
    if (__isset.sshAccountProvisionerAdditionalInfo != rhs.__isset.sshAccountProvisionerAdditionalInfo)
      return false;
    else if (__isset.sshAccountProvisionerAdditionalInfo && !(sshAccountProvisionerAdditionalInfo == rhs.sshAccountProvisionerAdditionalInfo))
      return false;
    return true;
  }
  bool operator != (const GroupComputeResourcePreference &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const GroupComputeResourcePreference & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(GroupComputeResourcePreference &a, GroupComputeResourcePreference &b);

inline std::ostream& operator<<(std::ostream& out, const GroupComputeResourcePreference& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _ComputeResourcePolicy__isset {
  _ComputeResourcePolicy__isset() : allowedBatchQueues(false) {}
  bool allowedBatchQueues :1;
} _ComputeResourcePolicy__isset;

class ComputeResourcePolicy : public virtual ::apache::thrift::TBase {
 public:

  ComputeResourcePolicy(const ComputeResourcePolicy&);
  ComputeResourcePolicy& operator=(const ComputeResourcePolicy&);
  ComputeResourcePolicy() : resourcePolicyId("DO_NOT_SET_AT_CLIENTS"), computeResourceId(), groupResourceProfileId("DO_NOT_SET_AT_CLIENTS") {
  }

  virtual ~ComputeResourcePolicy() throw();
  std::string resourcePolicyId;
  std::string computeResourceId;
  std::string groupResourceProfileId;
  std::vector<std::string>  allowedBatchQueues;

  _ComputeResourcePolicy__isset __isset;

  void __set_resourcePolicyId(const std::string& val);

  void __set_computeResourceId(const std::string& val);

  void __set_groupResourceProfileId(const std::string& val);

  void __set_allowedBatchQueues(const std::vector<std::string> & val);

  bool operator == (const ComputeResourcePolicy & rhs) const
  {
    if (!(resourcePolicyId == rhs.resourcePolicyId))
      return false;
    if (!(computeResourceId == rhs.computeResourceId))
      return false;
    if (!(groupResourceProfileId == rhs.groupResourceProfileId))
      return false;
    if (__isset.allowedBatchQueues != rhs.__isset.allowedBatchQueues)
      return false;
    else if (__isset.allowedBatchQueues && !(allowedBatchQueues == rhs.allowedBatchQueues))
      return false;
    return true;
  }
  bool operator != (const ComputeResourcePolicy &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ComputeResourcePolicy & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(ComputeResourcePolicy &a, ComputeResourcePolicy &b);

inline std::ostream& operator<<(std::ostream& out, const ComputeResourcePolicy& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _BatchQueueResourcePolicy__isset {
  _BatchQueueResourcePolicy__isset() : queuename(false), maxAllowedNodes(false), maxAllowedCores(false), maxAllowedWalltime(false) {}
  bool queuename :1;
  bool maxAllowedNodes :1;
  bool maxAllowedCores :1;
  bool maxAllowedWalltime :1;
} _BatchQueueResourcePolicy__isset;

class BatchQueueResourcePolicy : public virtual ::apache::thrift::TBase {
 public:

  BatchQueueResourcePolicy(const BatchQueueResourcePolicy&);
  BatchQueueResourcePolicy& operator=(const BatchQueueResourcePolicy&);
  BatchQueueResourcePolicy() : resourcePolicyId("DO_NOT_SET_AT_CLIENTS"), computeResourceId(), groupResourceProfileId("DO_NOT_SET_AT_CLIENTS"), queuename(), maxAllowedNodes(0), maxAllowedCores(0), maxAllowedWalltime(0) {
  }

  virtual ~BatchQueueResourcePolicy() throw();
  std::string resourcePolicyId;
  std::string computeResourceId;
  std::string groupResourceProfileId;
  std::string queuename;
  int32_t maxAllowedNodes;
  int32_t maxAllowedCores;
  int32_t maxAllowedWalltime;

  _BatchQueueResourcePolicy__isset __isset;

  void __set_resourcePolicyId(const std::string& val);

  void __set_computeResourceId(const std::string& val);

  void __set_groupResourceProfileId(const std::string& val);

  void __set_queuename(const std::string& val);

  void __set_maxAllowedNodes(const int32_t val);

  void __set_maxAllowedCores(const int32_t val);

  void __set_maxAllowedWalltime(const int32_t val);

  bool operator == (const BatchQueueResourcePolicy & rhs) const
  {
    if (!(resourcePolicyId == rhs.resourcePolicyId))
      return false;
    if (!(computeResourceId == rhs.computeResourceId))
      return false;
    if (!(groupResourceProfileId == rhs.groupResourceProfileId))
      return false;
    if (__isset.queuename != rhs.__isset.queuename)
      return false;
    else if (__isset.queuename && !(queuename == rhs.queuename))
      return false;
    if (__isset.maxAllowedNodes != rhs.__isset.maxAllowedNodes)
      return false;
    else if (__isset.maxAllowedNodes && !(maxAllowedNodes == rhs.maxAllowedNodes))
      return false;
    if (__isset.maxAllowedCores != rhs.__isset.maxAllowedCores)
      return false;
    else if (__isset.maxAllowedCores && !(maxAllowedCores == rhs.maxAllowedCores))
      return false;
    if (__isset.maxAllowedWalltime != rhs.__isset.maxAllowedWalltime)
      return false;
    else if (__isset.maxAllowedWalltime && !(maxAllowedWalltime == rhs.maxAllowedWalltime))
      return false;
    return true;
  }
  bool operator != (const BatchQueueResourcePolicy &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const BatchQueueResourcePolicy & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(BatchQueueResourcePolicy &a, BatchQueueResourcePolicy &b);

inline std::ostream& operator<<(std::ostream& out, const BatchQueueResourcePolicy& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _GroupResourceProfile__isset {
  _GroupResourceProfile__isset() : groupResourceProfileName(false), computePreferences(false), computeResourcePolicies(false), batchQueueResourcePolicies(false), creationTime(false), updatedTime(false), defaultCredentialStoreToken(false) {}
  bool groupResourceProfileName :1;
  bool computePreferences :1;
  bool computeResourcePolicies :1;
  bool batchQueueResourcePolicies :1;
  bool creationTime :1;
  bool updatedTime :1;
  bool defaultCredentialStoreToken :1;
} _GroupResourceProfile__isset;

class GroupResourceProfile : public virtual ::apache::thrift::TBase {
 public:

  GroupResourceProfile(const GroupResourceProfile&);
  GroupResourceProfile& operator=(const GroupResourceProfile&);
  GroupResourceProfile() : gatewayId(), groupResourceProfileId("DO_NOT_SET_AT_CLIENTS"), groupResourceProfileName(), creationTime(0), updatedTime(0), defaultCredentialStoreToken() {
  }

  virtual ~GroupResourceProfile() throw();
  std::string gatewayId;
  std::string groupResourceProfileId;
  std::string groupResourceProfileName;
  std::vector<GroupComputeResourcePreference>  computePreferences;
  std::vector<ComputeResourcePolicy>  computeResourcePolicies;
  std::vector<BatchQueueResourcePolicy>  batchQueueResourcePolicies;
  int64_t creationTime;
  int64_t updatedTime;
  std::string defaultCredentialStoreToken;

  _GroupResourceProfile__isset __isset;

  void __set_gatewayId(const std::string& val);

  void __set_groupResourceProfileId(const std::string& val);

  void __set_groupResourceProfileName(const std::string& val);

  void __set_computePreferences(const std::vector<GroupComputeResourcePreference> & val);

  void __set_computeResourcePolicies(const std::vector<ComputeResourcePolicy> & val);

  void __set_batchQueueResourcePolicies(const std::vector<BatchQueueResourcePolicy> & val);

  void __set_creationTime(const int64_t val);

  void __set_updatedTime(const int64_t val);

  void __set_defaultCredentialStoreToken(const std::string& val);

  bool operator == (const GroupResourceProfile & rhs) const
  {
    if (!(gatewayId == rhs.gatewayId))
      return false;
    if (!(groupResourceProfileId == rhs.groupResourceProfileId))
      return false;
    if (__isset.groupResourceProfileName != rhs.__isset.groupResourceProfileName)
      return false;
    else if (__isset.groupResourceProfileName && !(groupResourceProfileName == rhs.groupResourceProfileName))
      return false;
    if (__isset.computePreferences != rhs.__isset.computePreferences)
      return false;
    else if (__isset.computePreferences && !(computePreferences == rhs.computePreferences))
      return false;
    if (__isset.computeResourcePolicies != rhs.__isset.computeResourcePolicies)
      return false;
    else if (__isset.computeResourcePolicies && !(computeResourcePolicies == rhs.computeResourcePolicies))
      return false;
    if (__isset.batchQueueResourcePolicies != rhs.__isset.batchQueueResourcePolicies)
      return false;
    else if (__isset.batchQueueResourcePolicies && !(batchQueueResourcePolicies == rhs.batchQueueResourcePolicies))
      return false;
    if (__isset.creationTime != rhs.__isset.creationTime)
      return false;
    else if (__isset.creationTime && !(creationTime == rhs.creationTime))
      return false;
    if (__isset.updatedTime != rhs.__isset.updatedTime)
      return false;
    else if (__isset.updatedTime && !(updatedTime == rhs.updatedTime))
      return false;
    if (__isset.defaultCredentialStoreToken != rhs.__isset.defaultCredentialStoreToken)
      return false;
    else if (__isset.defaultCredentialStoreToken && !(defaultCredentialStoreToken == rhs.defaultCredentialStoreToken))
      return false;
    return true;
  }
  bool operator != (const GroupResourceProfile &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const GroupResourceProfile & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(GroupResourceProfile &a, GroupResourceProfile &b);

inline std::ostream& operator<<(std::ostream& out, const GroupResourceProfile& obj)
{
  obj.printTo(out);
  return out;
}

}}}}} // namespace

#endif
