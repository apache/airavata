/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Autogenerated by Thrift Compiler (0.9.3)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#include "replica_catalog_models_types.h"

#include <algorithm>
#include <ostream>

#include <thrift/TToString.h>

namespace apache { namespace airavata { namespace model { namespace data { namespace resource {

int _kReplicaLocationCategoryValues[] = {
  ReplicaLocationCategory::GATEWAY_DATA_STORE,
  ReplicaLocationCategory::COMPUTE_RESOURCE,
  ReplicaLocationCategory::LONG_TERM_STORAGE_RESOURCE,
  ReplicaLocationCategory::OTHER
};
const char* _kReplicaLocationCategoryNames[] = {
  "GATEWAY_DATA_STORE",
  "COMPUTE_RESOURCE",
  "LONG_TERM_STORAGE_RESOURCE",
  "OTHER"
};
const std::map<int, const char*> _ReplicaLocationCategory_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(4, _kReplicaLocationCategoryValues, _kReplicaLocationCategoryNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kReplicaPersistentTypeValues[] = {
  ReplicaPersistentType::TRANSIENT,
  ReplicaPersistentType::PERSISTENT
};
const char* _kReplicaPersistentTypeNames[] = {
  "TRANSIENT",
  "PERSISTENT"
};
const std::map<int, const char*> _ReplicaPersistentType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(2, _kReplicaPersistentTypeValues, _kReplicaPersistentTypeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kDataResourceTypeValues[] = {
  DataResourceType::COLLECTION,
  DataResourceType::FILE
};
const char* _kDataResourceTypeNames[] = {
  "COLLECTION",
  "FILE"
};
const std::map<int, const char*> _DataResourceType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(2, _kDataResourceTypeValues, _kDataResourceTypeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));


DataResourceModel::~DataResourceModel() throw() {
}


void DataResourceModel::__set_resourceId(const std::string& val) {
  this->resourceId = val;
__isset.resourceId = true;
}

void DataResourceModel::__set_gatewayId(const std::string& val) {
  this->gatewayId = val;
__isset.gatewayId = true;
}

void DataResourceModel::__set_parentResourceId(const std::string& val) {
  this->parentResourceId = val;
__isset.parentResourceId = true;
}

void DataResourceModel::__set_resourceName(const std::string& val) {
  this->resourceName = val;
__isset.resourceName = true;
}

void DataResourceModel::__set_resourceDescription(const std::string& val) {
  this->resourceDescription = val;
__isset.resourceDescription = true;
}

void DataResourceModel::__set_ownerName(const std::string& val) {
  this->ownerName = val;
__isset.ownerName = true;
}

void DataResourceModel::__set_dataResourceType(const DataResourceType::type val) {
  this->dataResourceType = val;
__isset.dataResourceType = true;
}

void DataResourceModel::__set_resourceSize(const int32_t val) {
  this->resourceSize = val;
__isset.resourceSize = true;
}

void DataResourceModel::__set_creationTime(const int64_t val) {
  this->creationTime = val;
__isset.creationTime = true;
}

void DataResourceModel::__set_lastModifiedTime(const int64_t val) {
  this->lastModifiedTime = val;
__isset.lastModifiedTime = true;
}

void DataResourceModel::__set_resourceMetadata(const std::map<std::string, std::string> & val) {
  this->resourceMetadata = val;
__isset.resourceMetadata = true;
}

void DataResourceModel::__set_replicaLocations(const std::vector<DataReplicaLocationModel> & val) {
  this->replicaLocations = val;
__isset.replicaLocations = true;
}

void DataResourceModel::__set_childResources(const std::vector<DataResourceModel> & val) {
  this->childResources = val;
__isset.childResources = true;
}

uint32_t DataResourceModel::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->resourceId);
          this->__isset.resourceId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->gatewayId);
          this->__isset.gatewayId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->parentResourceId);
          this->__isset.parentResourceId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->resourceName);
          this->__isset.resourceName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->resourceDescription);
          this->__isset.resourceDescription = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->ownerName);
          this->__isset.ownerName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast0;
          xfer += iprot->readI32(ecast0);
          this->dataResourceType = (DataResourceType::type)ecast0;
          this->__isset.dataResourceType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->resourceSize);
          this->__isset.resourceSize = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->creationTime);
          this->__isset.creationTime = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->lastModifiedTime);
          this->__isset.lastModifiedTime = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 11:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->resourceMetadata.clear();
            uint32_t _size1;
            ::apache::thrift::protocol::TType _ktype2;
            ::apache::thrift::protocol::TType _vtype3;
            xfer += iprot->readMapBegin(_ktype2, _vtype3, _size1);
            uint32_t _i5;
            for (_i5 = 0; _i5 < _size1; ++_i5)
            {
              std::string _key6;
              xfer += iprot->readString(_key6);
              std::string& _val7 = this->resourceMetadata[_key6];
              xfer += iprot->readString(_val7);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.resourceMetadata = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 12:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->replicaLocations.clear();
            uint32_t _size8;
            ::apache::thrift::protocol::TType _etype11;
            xfer += iprot->readListBegin(_etype11, _size8);
            this->replicaLocations.resize(_size8);
            uint32_t _i12;
            for (_i12 = 0; _i12 < _size8; ++_i12)
            {
              xfer += this->replicaLocations[_i12].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.replicaLocations = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 13:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->childResources.clear();
            uint32_t _size13;
            ::apache::thrift::protocol::TType _etype16;
            xfer += iprot->readListBegin(_etype16, _size13);
            this->childResources.resize(_size13);
            uint32_t _i17;
            for (_i17 = 0; _i17 < _size13; ++_i17)
            {
              xfer += this->childResources[_i17].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.childResources = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t DataResourceModel::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("DataResourceModel");

  if (this->__isset.resourceId) {
    xfer += oprot->writeFieldBegin("resourceId", ::apache::thrift::protocol::T_STRING, 1);
    xfer += oprot->writeString(this->resourceId);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.gatewayId) {
    xfer += oprot->writeFieldBegin("gatewayId", ::apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeString(this->gatewayId);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.parentResourceId) {
    xfer += oprot->writeFieldBegin("parentResourceId", ::apache::thrift::protocol::T_STRING, 3);
    xfer += oprot->writeString(this->parentResourceId);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.resourceName) {
    xfer += oprot->writeFieldBegin("resourceName", ::apache::thrift::protocol::T_STRING, 4);
    xfer += oprot->writeString(this->resourceName);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.resourceDescription) {
    xfer += oprot->writeFieldBegin("resourceDescription", ::apache::thrift::protocol::T_STRING, 5);
    xfer += oprot->writeString(this->resourceDescription);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.ownerName) {
    xfer += oprot->writeFieldBegin("ownerName", ::apache::thrift::protocol::T_STRING, 6);
    xfer += oprot->writeString(this->ownerName);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.dataResourceType) {
    xfer += oprot->writeFieldBegin("dataResourceType", ::apache::thrift::protocol::T_I32, 7);
    xfer += oprot->writeI32((int32_t)this->dataResourceType);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.resourceSize) {
    xfer += oprot->writeFieldBegin("resourceSize", ::apache::thrift::protocol::T_I32, 8);
    xfer += oprot->writeI32(this->resourceSize);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.creationTime) {
    xfer += oprot->writeFieldBegin("creationTime", ::apache::thrift::protocol::T_I64, 9);
    xfer += oprot->writeI64(this->creationTime);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.lastModifiedTime) {
    xfer += oprot->writeFieldBegin("lastModifiedTime", ::apache::thrift::protocol::T_I64, 10);
    xfer += oprot->writeI64(this->lastModifiedTime);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.resourceMetadata) {
    xfer += oprot->writeFieldBegin("resourceMetadata", ::apache::thrift::protocol::T_MAP, 11);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->resourceMetadata.size()));
      std::map<std::string, std::string> ::const_iterator _iter18;
      for (_iter18 = this->resourceMetadata.begin(); _iter18 != this->resourceMetadata.end(); ++_iter18)
      {
        xfer += oprot->writeString(_iter18->first);
        xfer += oprot->writeString(_iter18->second);
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.replicaLocations) {
    xfer += oprot->writeFieldBegin("replicaLocations", ::apache::thrift::protocol::T_LIST, 12);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->replicaLocations.size()));
      std::vector<DataReplicaLocationModel> ::const_iterator _iter19;
      for (_iter19 = this->replicaLocations.begin(); _iter19 != this->replicaLocations.end(); ++_iter19)
      {
        xfer += (*_iter19).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.childResources) {
    xfer += oprot->writeFieldBegin("childResources", ::apache::thrift::protocol::T_LIST, 13);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->childResources.size()));
      std::vector<DataResourceModel> ::const_iterator _iter20;
      for (_iter20 = this->childResources.begin(); _iter20 != this->childResources.end(); ++_iter20)
      {
        xfer += (*_iter20).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(DataResourceModel &a, DataResourceModel &b) {
  using ::std::swap;
  swap(a.resourceId, b.resourceId);
  swap(a.gatewayId, b.gatewayId);
  swap(a.parentResourceId, b.parentResourceId);
  swap(a.resourceName, b.resourceName);
  swap(a.resourceDescription, b.resourceDescription);
  swap(a.ownerName, b.ownerName);
  swap(a.dataResourceType, b.dataResourceType);
  swap(a.resourceSize, b.resourceSize);
  swap(a.creationTime, b.creationTime);
  swap(a.lastModifiedTime, b.lastModifiedTime);
  swap(a.resourceMetadata, b.resourceMetadata);
  swap(a.replicaLocations, b.replicaLocations);
  swap(a.childResources, b.childResources);
  swap(a.__isset, b.__isset);
}

DataResourceModel::DataResourceModel(const DataResourceModel& other21) {
  resourceId = other21.resourceId;
  gatewayId = other21.gatewayId;
  parentResourceId = other21.parentResourceId;
  resourceName = other21.resourceName;
  resourceDescription = other21.resourceDescription;
  ownerName = other21.ownerName;
  dataResourceType = other21.dataResourceType;
  resourceSize = other21.resourceSize;
  creationTime = other21.creationTime;
  lastModifiedTime = other21.lastModifiedTime;
  resourceMetadata = other21.resourceMetadata;
  replicaLocations = other21.replicaLocations;
  childResources = other21.childResources;
  __isset = other21.__isset;
}
DataResourceModel& DataResourceModel::operator=(const DataResourceModel& other22) {
  resourceId = other22.resourceId;
  gatewayId = other22.gatewayId;
  parentResourceId = other22.parentResourceId;
  resourceName = other22.resourceName;
  resourceDescription = other22.resourceDescription;
  ownerName = other22.ownerName;
  dataResourceType = other22.dataResourceType;
  resourceSize = other22.resourceSize;
  creationTime = other22.creationTime;
  lastModifiedTime = other22.lastModifiedTime;
  resourceMetadata = other22.resourceMetadata;
  replicaLocations = other22.replicaLocations;
  childResources = other22.childResources;
  __isset = other22.__isset;
  return *this;
}
void DataResourceModel::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "DataResourceModel(";
  out << "resourceId="; (__isset.resourceId ? (out << to_string(resourceId)) : (out << "<null>"));
  out << ", " << "gatewayId="; (__isset.gatewayId ? (out << to_string(gatewayId)) : (out << "<null>"));
  out << ", " << "parentResourceId="; (__isset.parentResourceId ? (out << to_string(parentResourceId)) : (out << "<null>"));
  out << ", " << "resourceName="; (__isset.resourceName ? (out << to_string(resourceName)) : (out << "<null>"));
  out << ", " << "resourceDescription="; (__isset.resourceDescription ? (out << to_string(resourceDescription)) : (out << "<null>"));
  out << ", " << "ownerName="; (__isset.ownerName ? (out << to_string(ownerName)) : (out << "<null>"));
  out << ", " << "dataResourceType="; (__isset.dataResourceType ? (out << to_string(dataResourceType)) : (out << "<null>"));
  out << ", " << "resourceSize="; (__isset.resourceSize ? (out << to_string(resourceSize)) : (out << "<null>"));
  out << ", " << "creationTime="; (__isset.creationTime ? (out << to_string(creationTime)) : (out << "<null>"));
  out << ", " << "lastModifiedTime="; (__isset.lastModifiedTime ? (out << to_string(lastModifiedTime)) : (out << "<null>"));
  out << ", " << "resourceMetadata="; (__isset.resourceMetadata ? (out << to_string(resourceMetadata)) : (out << "<null>"));
  out << ", " << "replicaLocations="; (__isset.replicaLocations ? (out << to_string(replicaLocations)) : (out << "<null>"));
  out << ", " << "childResources="; (__isset.childResources ? (out << to_string(childResources)) : (out << "<null>"));
  out << ")";
}


DataReplicaLocationModel::~DataReplicaLocationModel() throw() {
}


void DataReplicaLocationModel::__set_replicaId(const std::string& val) {
  this->replicaId = val;
__isset.replicaId = true;
}

void DataReplicaLocationModel::__set_resourceId(const std::string& val) {
  this->resourceId = val;
__isset.resourceId = true;
}

void DataReplicaLocationModel::__set_replicaName(const std::string& val) {
  this->replicaName = val;
__isset.replicaName = true;
}

void DataReplicaLocationModel::__set_replicaDescription(const std::string& val) {
  this->replicaDescription = val;
__isset.replicaDescription = true;
}

void DataReplicaLocationModel::__set_creationTime(const int64_t val) {
  this->creationTime = val;
__isset.creationTime = true;
}

void DataReplicaLocationModel::__set_lastModifiedTime(const int64_t val) {
  this->lastModifiedTime = val;
__isset.lastModifiedTime = true;
}

void DataReplicaLocationModel::__set_replicaLocationCategory(const ReplicaLocationCategory::type val) {
  this->replicaLocationCategory = val;
__isset.replicaLocationCategory = true;
}

void DataReplicaLocationModel::__set_replicaPersistentType(const ReplicaPersistentType::type val) {
  this->replicaPersistentType = val;
__isset.replicaPersistentType = true;
}

void DataReplicaLocationModel::__set_storageResourceId(const std::string& val) {
  this->storageResourceId = val;
__isset.storageResourceId = true;
}

void DataReplicaLocationModel::__set_storageResourceHostName(const std::string& val) {
  this->storageResourceHostName = val;
__isset.storageResourceHostName = true;
}

void DataReplicaLocationModel::__set_dataMovementProtocol(const  ::apache::airavata::model::data::movement::DataMovementProtocol::type val) {
  this->dataMovementProtocol = val;
__isset.dataMovementProtocol = true;
}

void DataReplicaLocationModel::__set_hostPort(const int64_t val) {
  this->hostPort = val;
__isset.hostPort = true;
}

void DataReplicaLocationModel::__set_filePath(const std::string& val) {
  this->filePath = val;
__isset.filePath = true;
}

void DataReplicaLocationModel::__set_replicaUrl(const std::string& val) {
  this->replicaUrl = val;
__isset.replicaUrl = true;
}

void DataReplicaLocationModel::__set_replicaMetadata(const std::map<std::string, std::string> & val) {
  this->replicaMetadata = val;
__isset.replicaMetadata = true;
}

uint32_t DataReplicaLocationModel::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->replicaId);
          this->__isset.replicaId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->resourceId);
          this->__isset.resourceId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->replicaName);
          this->__isset.replicaName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->replicaDescription);
          this->__isset.replicaDescription = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->creationTime);
          this->__isset.creationTime = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->lastModifiedTime);
          this->__isset.lastModifiedTime = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast23;
          xfer += iprot->readI32(ecast23);
          this->replicaLocationCategory = (ReplicaLocationCategory::type)ecast23;
          this->__isset.replicaLocationCategory = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast24;
          xfer += iprot->readI32(ecast24);
          this->replicaPersistentType = (ReplicaPersistentType::type)ecast24;
          this->__isset.replicaPersistentType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->storageResourceId);
          this->__isset.storageResourceId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->storageResourceHostName);
          this->__isset.storageResourceHostName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 11:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast25;
          xfer += iprot->readI32(ecast25);
          this->dataMovementProtocol = ( ::apache::airavata::model::data::movement::DataMovementProtocol::type)ecast25;
          this->__isset.dataMovementProtocol = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 12:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->hostPort);
          this->__isset.hostPort = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 13:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->filePath);
          this->__isset.filePath = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 14:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->replicaUrl);
          this->__isset.replicaUrl = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 15:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->replicaMetadata.clear();
            uint32_t _size26;
            ::apache::thrift::protocol::TType _ktype27;
            ::apache::thrift::protocol::TType _vtype28;
            xfer += iprot->readMapBegin(_ktype27, _vtype28, _size26);
            uint32_t _i30;
            for (_i30 = 0; _i30 < _size26; ++_i30)
            {
              std::string _key31;
              xfer += iprot->readString(_key31);
              std::string& _val32 = this->replicaMetadata[_key31];
              xfer += iprot->readString(_val32);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.replicaMetadata = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t DataReplicaLocationModel::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("DataReplicaLocationModel");

  if (this->__isset.replicaId) {
    xfer += oprot->writeFieldBegin("replicaId", ::apache::thrift::protocol::T_STRING, 1);
    xfer += oprot->writeString(this->replicaId);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.resourceId) {
    xfer += oprot->writeFieldBegin("resourceId", ::apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeString(this->resourceId);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.replicaName) {
    xfer += oprot->writeFieldBegin("replicaName", ::apache::thrift::protocol::T_STRING, 3);
    xfer += oprot->writeString(this->replicaName);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.replicaDescription) {
    xfer += oprot->writeFieldBegin("replicaDescription", ::apache::thrift::protocol::T_STRING, 4);
    xfer += oprot->writeString(this->replicaDescription);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.creationTime) {
    xfer += oprot->writeFieldBegin("creationTime", ::apache::thrift::protocol::T_I64, 5);
    xfer += oprot->writeI64(this->creationTime);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.lastModifiedTime) {
    xfer += oprot->writeFieldBegin("lastModifiedTime", ::apache::thrift::protocol::T_I64, 6);
    xfer += oprot->writeI64(this->lastModifiedTime);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.replicaLocationCategory) {
    xfer += oprot->writeFieldBegin("replicaLocationCategory", ::apache::thrift::protocol::T_I32, 7);
    xfer += oprot->writeI32((int32_t)this->replicaLocationCategory);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.replicaPersistentType) {
    xfer += oprot->writeFieldBegin("replicaPersistentType", ::apache::thrift::protocol::T_I32, 8);
    xfer += oprot->writeI32((int32_t)this->replicaPersistentType);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.storageResourceId) {
    xfer += oprot->writeFieldBegin("storageResourceId", ::apache::thrift::protocol::T_STRING, 9);
    xfer += oprot->writeString(this->storageResourceId);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.storageResourceHostName) {
    xfer += oprot->writeFieldBegin("storageResourceHostName", ::apache::thrift::protocol::T_STRING, 10);
    xfer += oprot->writeString(this->storageResourceHostName);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.dataMovementProtocol) {
    xfer += oprot->writeFieldBegin("dataMovementProtocol", ::apache::thrift::protocol::T_I32, 11);
    xfer += oprot->writeI32((int32_t)this->dataMovementProtocol);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.hostPort) {
    xfer += oprot->writeFieldBegin("hostPort", ::apache::thrift::protocol::T_I64, 12);
    xfer += oprot->writeI64(this->hostPort);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.filePath) {
    xfer += oprot->writeFieldBegin("filePath", ::apache::thrift::protocol::T_STRING, 13);
    xfer += oprot->writeString(this->filePath);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.replicaUrl) {
    xfer += oprot->writeFieldBegin("replicaUrl", ::apache::thrift::protocol::T_STRING, 14);
    xfer += oprot->writeString(this->replicaUrl);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.replicaMetadata) {
    xfer += oprot->writeFieldBegin("replicaMetadata", ::apache::thrift::protocol::T_MAP, 15);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->replicaMetadata.size()));
      std::map<std::string, std::string> ::const_iterator _iter33;
      for (_iter33 = this->replicaMetadata.begin(); _iter33 != this->replicaMetadata.end(); ++_iter33)
      {
        xfer += oprot->writeString(_iter33->first);
        xfer += oprot->writeString(_iter33->second);
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(DataReplicaLocationModel &a, DataReplicaLocationModel &b) {
  using ::std::swap;
  swap(a.replicaId, b.replicaId);
  swap(a.resourceId, b.resourceId);
  swap(a.replicaName, b.replicaName);
  swap(a.replicaDescription, b.replicaDescription);
  swap(a.creationTime, b.creationTime);
  swap(a.lastModifiedTime, b.lastModifiedTime);
  swap(a.replicaLocationCategory, b.replicaLocationCategory);
  swap(a.replicaPersistentType, b.replicaPersistentType);
  swap(a.storageResourceId, b.storageResourceId);
  swap(a.storageResourceHostName, b.storageResourceHostName);
  swap(a.dataMovementProtocol, b.dataMovementProtocol);
  swap(a.hostPort, b.hostPort);
  swap(a.filePath, b.filePath);
  swap(a.replicaUrl, b.replicaUrl);
  swap(a.replicaMetadata, b.replicaMetadata);
  swap(a.__isset, b.__isset);
}

DataReplicaLocationModel::DataReplicaLocationModel(const DataReplicaLocationModel& other34) {
  replicaId = other34.replicaId;
  resourceId = other34.resourceId;
  replicaName = other34.replicaName;
  replicaDescription = other34.replicaDescription;
  creationTime = other34.creationTime;
  lastModifiedTime = other34.lastModifiedTime;
  replicaLocationCategory = other34.replicaLocationCategory;
  replicaPersistentType = other34.replicaPersistentType;
  storageResourceId = other34.storageResourceId;
  storageResourceHostName = other34.storageResourceHostName;
  dataMovementProtocol = other34.dataMovementProtocol;
  hostPort = other34.hostPort;
  filePath = other34.filePath;
  replicaUrl = other34.replicaUrl;
  replicaMetadata = other34.replicaMetadata;
  __isset = other34.__isset;
}
DataReplicaLocationModel& DataReplicaLocationModel::operator=(const DataReplicaLocationModel& other35) {
  replicaId = other35.replicaId;
  resourceId = other35.resourceId;
  replicaName = other35.replicaName;
  replicaDescription = other35.replicaDescription;
  creationTime = other35.creationTime;
  lastModifiedTime = other35.lastModifiedTime;
  replicaLocationCategory = other35.replicaLocationCategory;
  replicaPersistentType = other35.replicaPersistentType;
  storageResourceId = other35.storageResourceId;
  storageResourceHostName = other35.storageResourceHostName;
  dataMovementProtocol = other35.dataMovementProtocol;
  hostPort = other35.hostPort;
  filePath = other35.filePath;
  replicaUrl = other35.replicaUrl;
  replicaMetadata = other35.replicaMetadata;
  __isset = other35.__isset;
  return *this;
}
void DataReplicaLocationModel::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "DataReplicaLocationModel(";
  out << "replicaId="; (__isset.replicaId ? (out << to_string(replicaId)) : (out << "<null>"));
  out << ", " << "resourceId="; (__isset.resourceId ? (out << to_string(resourceId)) : (out << "<null>"));
  out << ", " << "replicaName="; (__isset.replicaName ? (out << to_string(replicaName)) : (out << "<null>"));
  out << ", " << "replicaDescription="; (__isset.replicaDescription ? (out << to_string(replicaDescription)) : (out << "<null>"));
  out << ", " << "creationTime="; (__isset.creationTime ? (out << to_string(creationTime)) : (out << "<null>"));
  out << ", " << "lastModifiedTime="; (__isset.lastModifiedTime ? (out << to_string(lastModifiedTime)) : (out << "<null>"));
  out << ", " << "replicaLocationCategory="; (__isset.replicaLocationCategory ? (out << to_string(replicaLocationCategory)) : (out << "<null>"));
  out << ", " << "replicaPersistentType="; (__isset.replicaPersistentType ? (out << to_string(replicaPersistentType)) : (out << "<null>"));
  out << ", " << "storageResourceId="; (__isset.storageResourceId ? (out << to_string(storageResourceId)) : (out << "<null>"));
  out << ", " << "storageResourceHostName="; (__isset.storageResourceHostName ? (out << to_string(storageResourceHostName)) : (out << "<null>"));
  out << ", " << "dataMovementProtocol="; (__isset.dataMovementProtocol ? (out << to_string(dataMovementProtocol)) : (out << "<null>"));
  out << ", " << "hostPort="; (__isset.hostPort ? (out << to_string(hostPort)) : (out << "<null>"));
  out << ", " << "filePath="; (__isset.filePath ? (out << to_string(filePath)) : (out << "<null>"));
  out << ", " << "replicaUrl="; (__isset.replicaUrl ? (out << to_string(replicaUrl)) : (out << "<null>"));
  out << ", " << "replicaMetadata="; (__isset.replicaMetadata ? (out << to_string(replicaMetadata)) : (out << "<null>"));
  out << ")";
}

}}}}} // namespace
