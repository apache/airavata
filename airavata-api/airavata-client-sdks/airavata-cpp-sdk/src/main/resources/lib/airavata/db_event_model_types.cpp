/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Autogenerated by Thrift Compiler (0.10.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#include "db_event_model_types.h"

#include <algorithm>
#include <ostream>

#include <thrift/TToString.h>



int _kCrudTypeValues[] = {
  CrudType::CREATE,
  CrudType::READ,
  CrudType::UPDATE,
  CrudType::DELETE
};
const char* _kCrudTypeNames[] = {
  "CREATE",
  "READ",
  "UPDATE",
  "DELETE"
};
const std::map<int, const char*> _CrudType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(4, _kCrudTypeValues, _kCrudTypeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kEntityTypeValues[] = {
  EntityType::USER_PROFILE,
  EntityType::TENANT,
  EntityType::GROUP,
  EntityType::PROJECT,
  EntityType::EXPERIMENT,
  EntityType::APPLICATION,
  EntityType::SHARING,
  EntityType::REGISTRY
};
const char* _kEntityTypeNames[] = {
  "USER_PROFILE",
  "TENANT",
  "GROUP",
  "PROJECT",
  "EXPERIMENT",
  "APPLICATION",
  "SHARING",
  "REGISTRY"
};
const std::map<int, const char*> _EntityType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(8, _kEntityTypeValues, _kEntityTypeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kDBEventTypeValues[] = {
  DBEventType::PUBLISHER,
  DBEventType::SUBSCRIBER
};
const char* _kDBEventTypeNames[] = {
  "PUBLISHER",
  "SUBSCRIBER"
};
const std::map<int, const char*> _DBEventType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(2, _kDBEventTypeValues, _kDBEventTypeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));


DBEventPublisherContext::~DBEventPublisherContext() throw() {
}


void DBEventPublisherContext::__set_crudType(const CrudType::type val) {
  this->crudType = val;
}

void DBEventPublisherContext::__set_entityType(const EntityType::type val) {
  this->entityType = val;
}

void DBEventPublisherContext::__set_entityDataModel(const std::string& val) {
  this->entityDataModel = val;
}

uint32_t DBEventPublisherContext::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_crudType = false;
  bool isset_entityType = false;
  bool isset_entityDataModel = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast0;
          xfer += iprot->readI32(ecast0);
          this->crudType = (CrudType::type)ecast0;
          isset_crudType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast1;
          xfer += iprot->readI32(ecast1);
          this->entityType = (EntityType::type)ecast1;
          isset_entityType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->entityDataModel);
          isset_entityDataModel = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_crudType)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_entityType)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_entityDataModel)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t DBEventPublisherContext::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("DBEventPublisherContext");

  xfer += oprot->writeFieldBegin("crudType", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((int32_t)this->crudType);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("entityType", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32((int32_t)this->entityType);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("entityDataModel", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeBinary(this->entityDataModel);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(DBEventPublisherContext &a, DBEventPublisherContext &b) {
  using ::std::swap;
  swap(a.crudType, b.crudType);
  swap(a.entityType, b.entityType);
  swap(a.entityDataModel, b.entityDataModel);
}

DBEventPublisherContext::DBEventPublisherContext(const DBEventPublisherContext& other2) {
  crudType = other2.crudType;
  entityType = other2.entityType;
  entityDataModel = other2.entityDataModel;
}
DBEventPublisherContext& DBEventPublisherContext::operator=(const DBEventPublisherContext& other3) {
  crudType = other3.crudType;
  entityType = other3.entityType;
  entityDataModel = other3.entityDataModel;
  return *this;
}
void DBEventPublisherContext::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "DBEventPublisherContext(";
  out << "crudType=" << to_string(crudType);
  out << ", " << "entityType=" << to_string(entityType);
  out << ", " << "entityDataModel=" << to_string(entityDataModel);
  out << ")";
}


DBEventPublisher::~DBEventPublisher() throw() {
}


void DBEventPublisher::__set_publisherContext(const DBEventPublisherContext& val) {
  this->publisherContext = val;
}

uint32_t DBEventPublisher::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_publisherContext = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->publisherContext.read(iprot);
          isset_publisherContext = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_publisherContext)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t DBEventPublisher::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("DBEventPublisher");

  xfer += oprot->writeFieldBegin("publisherContext", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->publisherContext.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(DBEventPublisher &a, DBEventPublisher &b) {
  using ::std::swap;
  swap(a.publisherContext, b.publisherContext);
}

DBEventPublisher::DBEventPublisher(const DBEventPublisher& other4) {
  publisherContext = other4.publisherContext;
}
DBEventPublisher& DBEventPublisher::operator=(const DBEventPublisher& other5) {
  publisherContext = other5.publisherContext;
  return *this;
}
void DBEventPublisher::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "DBEventPublisher(";
  out << "publisherContext=" << to_string(publisherContext);
  out << ")";
}


DBEventSubscriber::~DBEventSubscriber() throw() {
}


void DBEventSubscriber::__set_subscriberService(const std::string& val) {
  this->subscriberService = val;
}

uint32_t DBEventSubscriber::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_subscriberService = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->subscriberService);
          isset_subscriberService = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_subscriberService)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t DBEventSubscriber::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("DBEventSubscriber");

  xfer += oprot->writeFieldBegin("subscriberService", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->subscriberService);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(DBEventSubscriber &a, DBEventSubscriber &b) {
  using ::std::swap;
  swap(a.subscriberService, b.subscriberService);
}

DBEventSubscriber::DBEventSubscriber(const DBEventSubscriber& other6) {
  subscriberService = other6.subscriberService;
}
DBEventSubscriber& DBEventSubscriber::operator=(const DBEventSubscriber& other7) {
  subscriberService = other7.subscriberService;
  return *this;
}
void DBEventSubscriber::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "DBEventSubscriber(";
  out << "subscriberService=" << to_string(subscriberService);
  out << ")";
}


DBEventMessageContext::~DBEventMessageContext() throw() {
}


void DBEventMessageContext::__set_publisher(const DBEventPublisher& val) {
  this->publisher = val;
__isset.publisher = true;
}

void DBEventMessageContext::__set_subscriber(const DBEventSubscriber& val) {
  this->subscriber = val;
__isset.subscriber = true;
}

uint32_t DBEventMessageContext::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->publisher.read(iprot);
          this->__isset.publisher = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->subscriber.read(iprot);
          this->__isset.subscriber = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t DBEventMessageContext::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("DBEventMessageContext");

  if (this->__isset.publisher) {
    xfer += oprot->writeFieldBegin("publisher", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->publisher.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.subscriber) {
    xfer += oprot->writeFieldBegin("subscriber", ::apache::thrift::protocol::T_STRUCT, 2);
    xfer += this->subscriber.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(DBEventMessageContext &a, DBEventMessageContext &b) {
  using ::std::swap;
  swap(a.publisher, b.publisher);
  swap(a.subscriber, b.subscriber);
  swap(a.__isset, b.__isset);
}

DBEventMessageContext::DBEventMessageContext(const DBEventMessageContext& other8) {
  publisher = other8.publisher;
  subscriber = other8.subscriber;
  __isset = other8.__isset;
}
DBEventMessageContext& DBEventMessageContext::operator=(const DBEventMessageContext& other9) {
  publisher = other9.publisher;
  subscriber = other9.subscriber;
  __isset = other9.__isset;
  return *this;
}
void DBEventMessageContext::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "DBEventMessageContext(";
  out << "publisher="; (__isset.publisher ? (out << to_string(publisher)) : (out << "<null>"));
  out << ", " << "subscriber="; (__isset.subscriber ? (out << to_string(subscriber)) : (out << "<null>"));
  out << ")";
}


DBEventMessage::~DBEventMessage() throw() {
}


void DBEventMessage::__set_dbEventType(const DBEventType::type val) {
  this->dbEventType = val;
}

void DBEventMessage::__set_messageContext(const DBEventMessageContext& val) {
  this->messageContext = val;
}

void DBEventMessage::__set_publisherService(const std::string& val) {
  this->publisherService = val;
}

uint32_t DBEventMessage::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_dbEventType = false;
  bool isset_messageContext = false;
  bool isset_publisherService = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast10;
          xfer += iprot->readI32(ecast10);
          this->dbEventType = (DBEventType::type)ecast10;
          isset_dbEventType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->messageContext.read(iprot);
          isset_messageContext = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->publisherService);
          isset_publisherService = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_dbEventType)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_messageContext)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_publisherService)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t DBEventMessage::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("DBEventMessage");

  xfer += oprot->writeFieldBegin("dbEventType", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((int32_t)this->dbEventType);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("messageContext", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->messageContext.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("publisherService", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->publisherService);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(DBEventMessage &a, DBEventMessage &b) {
  using ::std::swap;
  swap(a.dbEventType, b.dbEventType);
  swap(a.messageContext, b.messageContext);
  swap(a.publisherService, b.publisherService);
}

DBEventMessage::DBEventMessage(const DBEventMessage& other11) {
  dbEventType = other11.dbEventType;
  messageContext = other11.messageContext;
  publisherService = other11.publisherService;
}
DBEventMessage& DBEventMessage::operator=(const DBEventMessage& other12) {
  dbEventType = other12.dbEventType;
  messageContext = other12.messageContext;
  publisherService = other12.publisherService;
  return *this;
}
void DBEventMessage::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "DBEventMessage(";
  out << "dbEventType=" << to_string(dbEventType);
  out << ", " << "messageContext=" << to_string(messageContext);
  out << ", " << "publisherService=" << to_string(publisherService);
  out << ")";
}


