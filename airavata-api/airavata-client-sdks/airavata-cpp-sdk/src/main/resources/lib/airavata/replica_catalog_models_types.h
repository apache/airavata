/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Autogenerated by Thrift Compiler (0.9.3)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#ifndef replica_catalog_models_TYPES_H
#define replica_catalog_models_TYPES_H

#include <iosfwd>

#include <thrift/Thrift.h>
#include <thrift/TApplicationException.h>
#include <thrift/protocol/TProtocol.h>
#include <thrift/transport/TTransport.h>

#include <thrift/cxxfunctional.h>
#include "data_movement_models_types.h"


namespace apache { namespace airavata { namespace model { namespace data { namespace resource {

struct ReplicaLocationCategory {
  enum type {
    GATEWAY_DATA_STORE = 0,
    COMPUTE_RESOURCE = 1,
    LONG_TERM_STORAGE_RESOURCE = 2,
    OTHER = 3
  };
};

extern const std::map<int, const char*> _ReplicaLocationCategory_VALUES_TO_NAMES;

struct ReplicaPersistentType {
  enum type {
    TRANSIENT = 0,
    PERSISTENT = 1
  };
};

extern const std::map<int, const char*> _ReplicaPersistentType_VALUES_TO_NAMES;

struct DataResourceType {
  enum type {
    COLLECTION = 0,
    FILE = 1
  };
};

extern const std::map<int, const char*> _DataResourceType_VALUES_TO_NAMES;

class DataResourceModel;

class DataReplicaLocationModel;

typedef struct _DataResourceModel__isset {
  _DataResourceModel__isset() : resourceId(false), gatewayId(false), parentResourceId(false), resourceName(false), resourceDescription(false), ownerName(false), dataResourceType(false), resourceSize(false), creationTime(false), lastModifiedTime(false), resourceMetadata(false), replicaLocations(false), childResources(false) {}
  bool resourceId :1;
  bool gatewayId :1;
  bool parentResourceId :1;
  bool resourceName :1;
  bool resourceDescription :1;
  bool ownerName :1;
  bool dataResourceType :1;
  bool resourceSize :1;
  bool creationTime :1;
  bool lastModifiedTime :1;
  bool resourceMetadata :1;
  bool replicaLocations :1;
  bool childResources :1;
} _DataResourceModel__isset;

class DataResourceModel {
 public:

  DataResourceModel(const DataResourceModel&);
  DataResourceModel& operator=(const DataResourceModel&);
  DataResourceModel() : resourceId(), gatewayId(), parentResourceId(), resourceName(), resourceDescription(), ownerName(), dataResourceType((DataResourceType::type)0), resourceSize(0), creationTime(0), lastModifiedTime(0) {
  }

  virtual ~DataResourceModel() throw();
  std::string resourceId;
  std::string gatewayId;
  std::string parentResourceId;
  std::string resourceName;
  std::string resourceDescription;
  std::string ownerName;
  DataResourceType::type dataResourceType;
  int32_t resourceSize;
  int64_t creationTime;
  int64_t lastModifiedTime;
  std::map<std::string, std::string>  resourceMetadata;
  std::vector<DataReplicaLocationModel>  replicaLocations;
  std::vector<DataResourceModel>  childResources;

  _DataResourceModel__isset __isset;

  void __set_resourceId(const std::string& val);

  void __set_gatewayId(const std::string& val);

  void __set_parentResourceId(const std::string& val);

  void __set_resourceName(const std::string& val);

  void __set_resourceDescription(const std::string& val);

  void __set_ownerName(const std::string& val);

  void __set_dataResourceType(const DataResourceType::type val);

  void __set_resourceSize(const int32_t val);

  void __set_creationTime(const int64_t val);

  void __set_lastModifiedTime(const int64_t val);

  void __set_resourceMetadata(const std::map<std::string, std::string> & val);

  void __set_replicaLocations(const std::vector<DataReplicaLocationModel> & val);

  void __set_childResources(const std::vector<DataResourceModel> & val);

  bool operator == (const DataResourceModel & rhs) const
  {
    if (__isset.resourceId != rhs.__isset.resourceId)
      return false;
    else if (__isset.resourceId && !(resourceId == rhs.resourceId))
      return false;
    if (__isset.gatewayId != rhs.__isset.gatewayId)
      return false;
    else if (__isset.gatewayId && !(gatewayId == rhs.gatewayId))
      return false;
    if (__isset.parentResourceId != rhs.__isset.parentResourceId)
      return false;
    else if (__isset.parentResourceId && !(parentResourceId == rhs.parentResourceId))
      return false;
    if (__isset.resourceName != rhs.__isset.resourceName)
      return false;
    else if (__isset.resourceName && !(resourceName == rhs.resourceName))
      return false;
    if (__isset.resourceDescription != rhs.__isset.resourceDescription)
      return false;
    else if (__isset.resourceDescription && !(resourceDescription == rhs.resourceDescription))
      return false;
    if (__isset.ownerName != rhs.__isset.ownerName)
      return false;
    else if (__isset.ownerName && !(ownerName == rhs.ownerName))
      return false;
    if (__isset.dataResourceType != rhs.__isset.dataResourceType)
      return false;
    else if (__isset.dataResourceType && !(dataResourceType == rhs.dataResourceType))
      return false;
    if (__isset.resourceSize != rhs.__isset.resourceSize)
      return false;
    else if (__isset.resourceSize && !(resourceSize == rhs.resourceSize))
      return false;
    if (__isset.creationTime != rhs.__isset.creationTime)
      return false;
    else if (__isset.creationTime && !(creationTime == rhs.creationTime))
      return false;
    if (__isset.lastModifiedTime != rhs.__isset.lastModifiedTime)
      return false;
    else if (__isset.lastModifiedTime && !(lastModifiedTime == rhs.lastModifiedTime))
      return false;
    if (__isset.resourceMetadata != rhs.__isset.resourceMetadata)
      return false;
    else if (__isset.resourceMetadata && !(resourceMetadata == rhs.resourceMetadata))
      return false;
    if (__isset.replicaLocations != rhs.__isset.replicaLocations)
      return false;
    else if (__isset.replicaLocations && !(replicaLocations == rhs.replicaLocations))
      return false;
    if (__isset.childResources != rhs.__isset.childResources)
      return false;
    else if (__isset.childResources && !(childResources == rhs.childResources))
      return false;
    return true;
  }
  bool operator != (const DataResourceModel &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const DataResourceModel & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(DataResourceModel &a, DataResourceModel &b);

inline std::ostream& operator<<(std::ostream& out, const DataResourceModel& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _DataReplicaLocationModel__isset {
  _DataReplicaLocationModel__isset() : replicaId(false), resourceId(false), replicaName(false), replicaDescription(false), creationTime(false), lastModifiedTime(false), replicaLocationCategory(false), replicaPersistentType(false), storageResourceId(false), storageResourceHostName(false), dataMovementProtocol(false), hostPort(false), filePath(false), replicaUrl(false), replicaMetadata(false) {}
  bool replicaId :1;
  bool resourceId :1;
  bool replicaName :1;
  bool replicaDescription :1;
  bool creationTime :1;
  bool lastModifiedTime :1;
  bool replicaLocationCategory :1;
  bool replicaPersistentType :1;
  bool storageResourceId :1;
  bool storageResourceHostName :1;
  bool dataMovementProtocol :1;
  bool hostPort :1;
  bool filePath :1;
  bool replicaUrl :1;
  bool replicaMetadata :1;
} _DataReplicaLocationModel__isset;

class DataReplicaLocationModel {
 public:

  DataReplicaLocationModel(const DataReplicaLocationModel&);
  DataReplicaLocationModel& operator=(const DataReplicaLocationModel&);
  DataReplicaLocationModel() : replicaId(), resourceId(), replicaName(), replicaDescription(), creationTime(0), lastModifiedTime(0), replicaLocationCategory((ReplicaLocationCategory::type)0), replicaPersistentType((ReplicaPersistentType::type)0), storageResourceId(), storageResourceHostName(), dataMovementProtocol(( ::apache::airavata::model::data::movement::DataMovementProtocol::type)0), hostPort(0), filePath(), replicaUrl() {
  }

  virtual ~DataReplicaLocationModel() throw();
  std::string replicaId;
  std::string resourceId;
  std::string replicaName;
  std::string replicaDescription;
  int64_t creationTime;
  int64_t lastModifiedTime;
  ReplicaLocationCategory::type replicaLocationCategory;
  ReplicaPersistentType::type replicaPersistentType;
  std::string storageResourceId;
  std::string storageResourceHostName;
   ::apache::airavata::model::data::movement::DataMovementProtocol::type dataMovementProtocol;
  int64_t hostPort;
  std::string filePath;
  std::string replicaUrl;
  std::map<std::string, std::string>  replicaMetadata;

  _DataReplicaLocationModel__isset __isset;

  void __set_replicaId(const std::string& val);

  void __set_resourceId(const std::string& val);

  void __set_replicaName(const std::string& val);

  void __set_replicaDescription(const std::string& val);

  void __set_creationTime(const int64_t val);

  void __set_lastModifiedTime(const int64_t val);

  void __set_replicaLocationCategory(const ReplicaLocationCategory::type val);

  void __set_replicaPersistentType(const ReplicaPersistentType::type val);

  void __set_storageResourceId(const std::string& val);

  void __set_storageResourceHostName(const std::string& val);

  void __set_dataMovementProtocol(const  ::apache::airavata::model::data::movement::DataMovementProtocol::type val);

  void __set_hostPort(const int64_t val);

  void __set_filePath(const std::string& val);

  void __set_replicaUrl(const std::string& val);

  void __set_replicaMetadata(const std::map<std::string, std::string> & val);

  bool operator == (const DataReplicaLocationModel & rhs) const
  {
    if (__isset.replicaId != rhs.__isset.replicaId)
      return false;
    else if (__isset.replicaId && !(replicaId == rhs.replicaId))
      return false;
    if (__isset.resourceId != rhs.__isset.resourceId)
      return false;
    else if (__isset.resourceId && !(resourceId == rhs.resourceId))
      return false;
    if (__isset.replicaName != rhs.__isset.replicaName)
      return false;
    else if (__isset.replicaName && !(replicaName == rhs.replicaName))
      return false;
    if (__isset.replicaDescription != rhs.__isset.replicaDescription)
      return false;
    else if (__isset.replicaDescription && !(replicaDescription == rhs.replicaDescription))
      return false;
    if (__isset.creationTime != rhs.__isset.creationTime)
      return false;
    else if (__isset.creationTime && !(creationTime == rhs.creationTime))
      return false;
    if (__isset.lastModifiedTime != rhs.__isset.lastModifiedTime)
      return false;
    else if (__isset.lastModifiedTime && !(lastModifiedTime == rhs.lastModifiedTime))
      return false;
    if (__isset.replicaLocationCategory != rhs.__isset.replicaLocationCategory)
      return false;
    else if (__isset.replicaLocationCategory && !(replicaLocationCategory == rhs.replicaLocationCategory))
      return false;
    if (__isset.replicaPersistentType != rhs.__isset.replicaPersistentType)
      return false;
    else if (__isset.replicaPersistentType && !(replicaPersistentType == rhs.replicaPersistentType))
      return false;
    if (__isset.storageResourceId != rhs.__isset.storageResourceId)
      return false;
    else if (__isset.storageResourceId && !(storageResourceId == rhs.storageResourceId))
      return false;
    if (__isset.storageResourceHostName != rhs.__isset.storageResourceHostName)
      return false;
    else if (__isset.storageResourceHostName && !(storageResourceHostName == rhs.storageResourceHostName))
      return false;
    if (__isset.dataMovementProtocol != rhs.__isset.dataMovementProtocol)
      return false;
    else if (__isset.dataMovementProtocol && !(dataMovementProtocol == rhs.dataMovementProtocol))
      return false;
    if (__isset.hostPort != rhs.__isset.hostPort)
      return false;
    else if (__isset.hostPort && !(hostPort == rhs.hostPort))
      return false;
    if (__isset.filePath != rhs.__isset.filePath)
      return false;
    else if (__isset.filePath && !(filePath == rhs.filePath))
      return false;
    if (__isset.replicaUrl != rhs.__isset.replicaUrl)
      return false;
    else if (__isset.replicaUrl && !(replicaUrl == rhs.replicaUrl))
      return false;
    if (__isset.replicaMetadata != rhs.__isset.replicaMetadata)
      return false;
    else if (__isset.replicaMetadata && !(replicaMetadata == rhs.replicaMetadata))
      return false;
    return true;
  }
  bool operator != (const DataReplicaLocationModel &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const DataReplicaLocationModel & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(DataReplicaLocationModel &a, DataReplicaLocationModel &b);

inline std::ostream& operator<<(std::ostream& out, const DataReplicaLocationModel& obj)
{
  obj.printTo(out);
  return out;
}

}}}}} // namespace

#endif
