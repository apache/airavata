/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Autogenerated by Thrift Compiler (0.9.2)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#ifndef data_movement_models_TYPES_H
#define data_movement_models_TYPES_H

#include <iosfwd>

#include <thrift/Thrift.h>
#include <thrift/TApplicationException.h>
#include <thrift/protocol/TProtocol.h>
#include <thrift/transport/TTransport.h>

#include <thrift/cxxfunctional.h>
#include "airavata_commons_types.h"


namespace apache { namespace airavata { namespace model { namespace data { namespace movement {

struct DMType {
  enum type {
    COMPUTE_RESOURCE = 0,
    STORAGE_RESOURCE = 1
  };
};

extern const std::map<int, const char*> _DMType_VALUES_TO_NAMES;

struct SecurityProtocol {
  enum type {
    USERNAME_PASSWORD = 0,
    SSH_KEYS = 1,
    GSI = 2,
    KERBEROS = 3,
    OAUTH = 4,
    LOCAL = 5
  };
};

extern const std::map<int, const char*> _SecurityProtocol_VALUES_TO_NAMES;

struct DataMovementProtocol {
  enum type {
    LOCAL = 0,
    SCP = 1,
    SFTP = 2,
    GridFTP = 3,
    UNICORE_STORAGE_SERVICE = 4
  };
};

extern const std::map<int, const char*> _DataMovementProtocol_VALUES_TO_NAMES;

class SCPDataMovement;

class GridFTPDataMovement;

class UnicoreDataMovement;

class LOCALDataMovement;

class DataMovementInterface;

typedef struct _SCPDataMovement__isset {
  _SCPDataMovement__isset() : alternativeSCPHostName(false), sshPort(true) {}
  bool alternativeSCPHostName :1;
  bool sshPort :1;
} _SCPDataMovement__isset;

class SCPDataMovement {
 public:

  static const char* ascii_fingerprint; // = "63CAE6EE336A7DBD91CCCD6E22628F4A";
  static const uint8_t binary_fingerprint[16]; // = {0x63,0xCA,0xE6,0xEE,0x33,0x6A,0x7D,0xBD,0x91,0xCC,0xCD,0x6E,0x22,0x62,0x8F,0x4A};

  SCPDataMovement(const SCPDataMovement&);
  SCPDataMovement& operator=(const SCPDataMovement&);
  SCPDataMovement() : dataMovementInterfaceId("DO_NOT_SET_AT_CLIENTS"), securityProtocol((SecurityProtocol::type)0), alternativeSCPHostName(), sshPort(22) {
  }

  virtual ~SCPDataMovement() throw();
  std::string dataMovementInterfaceId;
  SecurityProtocol::type securityProtocol;
  std::string alternativeSCPHostName;
  int32_t sshPort;

  _SCPDataMovement__isset __isset;

  void __set_dataMovementInterfaceId(const std::string& val);

  void __set_securityProtocol(const SecurityProtocol::type val);

  void __set_alternativeSCPHostName(const std::string& val);

  void __set_sshPort(const int32_t val);

  bool operator == (const SCPDataMovement & rhs) const
  {
    if (!(dataMovementInterfaceId == rhs.dataMovementInterfaceId))
      return false;
    if (!(securityProtocol == rhs.securityProtocol))
      return false;
    if (__isset.alternativeSCPHostName != rhs.__isset.alternativeSCPHostName)
      return false;
    else if (__isset.alternativeSCPHostName && !(alternativeSCPHostName == rhs.alternativeSCPHostName))
      return false;
    if (__isset.sshPort != rhs.__isset.sshPort)
      return false;
    else if (__isset.sshPort && !(sshPort == rhs.sshPort))
      return false;
    return true;
  }
  bool operator != (const SCPDataMovement &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const SCPDataMovement & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const SCPDataMovement& obj);
};

void swap(SCPDataMovement &a, SCPDataMovement &b);


class GridFTPDataMovement {
 public:

  static const char* ascii_fingerprint; // = "790EE8B1D56A3B9B76C41DD063726E75";
  static const uint8_t binary_fingerprint[16]; // = {0x79,0x0E,0xE8,0xB1,0xD5,0x6A,0x3B,0x9B,0x76,0xC4,0x1D,0xD0,0x63,0x72,0x6E,0x75};

  GridFTPDataMovement(const GridFTPDataMovement&);
  GridFTPDataMovement& operator=(const GridFTPDataMovement&);
  GridFTPDataMovement() : dataMovementInterfaceId("DO_NOT_SET_AT_CLIENTS"), securityProtocol((SecurityProtocol::type)0) {
  }

  virtual ~GridFTPDataMovement() throw();
  std::string dataMovementInterfaceId;
  SecurityProtocol::type securityProtocol;
  std::vector<std::string>  gridFTPEndPoints;

  void __set_dataMovementInterfaceId(const std::string& val);

  void __set_securityProtocol(const SecurityProtocol::type val);

  void __set_gridFTPEndPoints(const std::vector<std::string> & val);

  bool operator == (const GridFTPDataMovement & rhs) const
  {
    if (!(dataMovementInterfaceId == rhs.dataMovementInterfaceId))
      return false;
    if (!(securityProtocol == rhs.securityProtocol))
      return false;
    if (!(gridFTPEndPoints == rhs.gridFTPEndPoints))
      return false;
    return true;
  }
  bool operator != (const GridFTPDataMovement &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const GridFTPDataMovement & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const GridFTPDataMovement& obj);
};

void swap(GridFTPDataMovement &a, GridFTPDataMovement &b);


class UnicoreDataMovement {
 public:

  static const char* ascii_fingerprint; // = "D9F4CFE2F293A8B1052FD3031DD2C847";
  static const uint8_t binary_fingerprint[16]; // = {0xD9,0xF4,0xCF,0xE2,0xF2,0x93,0xA8,0xB1,0x05,0x2F,0xD3,0x03,0x1D,0xD2,0xC8,0x47};

  UnicoreDataMovement(const UnicoreDataMovement&);
  UnicoreDataMovement& operator=(const UnicoreDataMovement&);
  UnicoreDataMovement() : dataMovementInterfaceId("DO_NOT_SET_AT_CLIENTS"), securityProtocol((SecurityProtocol::type)0), unicoreEndPointURL() {
  }

  virtual ~UnicoreDataMovement() throw();
  std::string dataMovementInterfaceId;
  SecurityProtocol::type securityProtocol;
  std::string unicoreEndPointURL;

  void __set_dataMovementInterfaceId(const std::string& val);

  void __set_securityProtocol(const SecurityProtocol::type val);

  void __set_unicoreEndPointURL(const std::string& val);

  bool operator == (const UnicoreDataMovement & rhs) const
  {
    if (!(dataMovementInterfaceId == rhs.dataMovementInterfaceId))
      return false;
    if (!(securityProtocol == rhs.securityProtocol))
      return false;
    if (!(unicoreEndPointURL == rhs.unicoreEndPointURL))
      return false;
    return true;
  }
  bool operator != (const UnicoreDataMovement &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const UnicoreDataMovement & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const UnicoreDataMovement& obj);
};

void swap(UnicoreDataMovement &a, UnicoreDataMovement &b);


class LOCALDataMovement {
 public:

  static const char* ascii_fingerprint; // = "EFB929595D312AC8F305D5A794CFEDA1";
  static const uint8_t binary_fingerprint[16]; // = {0xEF,0xB9,0x29,0x59,0x5D,0x31,0x2A,0xC8,0xF3,0x05,0xD5,0xA7,0x94,0xCF,0xED,0xA1};

  LOCALDataMovement(const LOCALDataMovement&);
  LOCALDataMovement& operator=(const LOCALDataMovement&);
  LOCALDataMovement() : dataMovementInterfaceId("DO_NOT_SET_AT_CLIENTS") {
  }

  virtual ~LOCALDataMovement() throw();
  std::string dataMovementInterfaceId;

  void __set_dataMovementInterfaceId(const std::string& val);

  bool operator == (const LOCALDataMovement & rhs) const
  {
    if (!(dataMovementInterfaceId == rhs.dataMovementInterfaceId))
      return false;
    return true;
  }
  bool operator != (const LOCALDataMovement &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const LOCALDataMovement & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const LOCALDataMovement& obj);
};

void swap(LOCALDataMovement &a, LOCALDataMovement &b);


class DataMovementInterface {
 public:

  static const char* ascii_fingerprint; // = "A0A4DD7B8243FB842E64EAC6E5DA6C7B";
  static const uint8_t binary_fingerprint[16]; // = {0xA0,0xA4,0xDD,0x7B,0x82,0x43,0xFB,0x84,0x2E,0x64,0xEA,0xC6,0xE5,0xDA,0x6C,0x7B};

  DataMovementInterface(const DataMovementInterface&);
  DataMovementInterface& operator=(const DataMovementInterface&);
  DataMovementInterface() : dataMovementInterfaceId(), dataMovementProtocol((DataMovementProtocol::type)0), priorityOrder(0) {
  }

  virtual ~DataMovementInterface() throw();
  std::string dataMovementInterfaceId;
  DataMovementProtocol::type dataMovementProtocol;
  int32_t priorityOrder;

  void __set_dataMovementInterfaceId(const std::string& val);

  void __set_dataMovementProtocol(const DataMovementProtocol::type val);

  void __set_priorityOrder(const int32_t val);

  bool operator == (const DataMovementInterface & rhs) const
  {
    if (!(dataMovementInterfaceId == rhs.dataMovementInterfaceId))
      return false;
    if (!(dataMovementProtocol == rhs.dataMovementProtocol))
      return false;
    if (!(priorityOrder == rhs.priorityOrder))
      return false;
    return true;
  }
  bool operator != (const DataMovementInterface &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const DataMovementInterface & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const DataMovementInterface& obj);
};

void swap(DataMovementInterface &a, DataMovementInterface &b);

}}}}} // namespace

#endif
