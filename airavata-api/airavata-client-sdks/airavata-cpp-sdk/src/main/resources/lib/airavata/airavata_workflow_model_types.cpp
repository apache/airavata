/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Autogenerated by Thrift Compiler (0.10.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#include "airavata_workflow_model_types.h"

#include <algorithm>
#include <ostream>

#include <thrift/TToString.h>

namespace apache { namespace airavata { namespace model { namespace workflow {

int _kApplicationStateValues[] = {
  ApplicationState::CREATED,
  ApplicationState::VALIDATED,
  ApplicationState::SCHEDULED,
  ApplicationState::LAUNCHED,
  ApplicationState::EXECUTING,
  ApplicationState::CANCELING,
  ApplicationState::CANCELED,
  ApplicationState::COMPLETED,
  ApplicationState::FAILED
};
const char* _kApplicationStateNames[] = {
  "CREATED",
  "VALIDATED",
  "SCHEDULED",
  "LAUNCHED",
  "EXECUTING",
  "CANCELING",
  "CANCELED",
  "COMPLETED",
  "FAILED"
};
const std::map<int, const char*> _ApplicationState_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(9, _kApplicationStateValues, _kApplicationStateNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kComponentTypeValues[] = {
  ComponentType::APPLICATION,
  ComponentType::HANDLER
};
const char* _kComponentTypeNames[] = {
  "APPLICATION",
  "HANDLER"
};
const std::map<int, const char*> _ComponentType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(2, _kComponentTypeValues, _kComponentTypeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kHandlerTypeValues[] = {
  HandlerType::FLOW_STARTER,
  HandlerType::FLOW_TERMINATOR
};
const char* _kHandlerTypeNames[] = {
  "FLOW_STARTER",
  "FLOW_TERMINATOR"
};
const std::map<int, const char*> _HandlerType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(2, _kHandlerTypeValues, _kHandlerTypeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kHandlerStateValues[] = {
  HandlerState::CREATED,
  HandlerState::VALIDATED,
  HandlerState::SCHEDULED,
  HandlerState::LAUNCHED,
  HandlerState::EXECUTING,
  HandlerState::CANCELING,
  HandlerState::CANCELED,
  HandlerState::COMPLETED,
  HandlerState::FAILED
};
const char* _kHandlerStateNames[] = {
  "CREATED",
  "VALIDATED",
  "SCHEDULED",
  "LAUNCHED",
  "EXECUTING",
  "CANCELING",
  "CANCELED",
  "COMPLETED",
  "FAILED"
};
const std::map<int, const char*> _HandlerState_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(9, _kHandlerStateValues, _kHandlerStateNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kWorkflowStateValues[] = {
  WorkflowState::CREATED,
  WorkflowState::VALIDATED,
  WorkflowState::SCHEDULED,
  WorkflowState::LAUNCHED,
  WorkflowState::EXECUTING,
  WorkflowState::PAUSING,
  WorkflowState::PAUSED,
  WorkflowState::RESTARTING,
  WorkflowState::CANCELING,
  WorkflowState::CANCELED,
  WorkflowState::COMPLETED,
  WorkflowState::FAILED
};
const char* _kWorkflowStateNames[] = {
  "CREATED",
  "VALIDATED",
  "SCHEDULED",
  "LAUNCHED",
  "EXECUTING",
  "PAUSING",
  "PAUSED",
  "RESTARTING",
  "CANCELING",
  "CANCELED",
  "COMPLETED",
  "FAILED"
};
const std::map<int, const char*> _WorkflowState_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(12, _kWorkflowStateValues, _kWorkflowStateNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));


ApplicationStatus::~ApplicationStatus() throw() {
}


void ApplicationStatus::__set_id(const std::string& val) {
  this->id = val;
__isset.id = true;
}

void ApplicationStatus::__set_state(const ApplicationState::type val) {
  this->state = val;
}

void ApplicationStatus::__set_description(const std::string& val) {
  this->description = val;
__isset.description = true;
}

void ApplicationStatus::__set_updatedAt(const int64_t val) {
  this->updatedAt = val;
__isset.updatedAt = true;
}

uint32_t ApplicationStatus::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_state = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->id);
          this->__isset.id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast0;
          xfer += iprot->readI32(ecast0);
          this->state = (ApplicationState::type)ecast0;
          isset_state = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->description);
          this->__isset.description = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->updatedAt);
          this->__isset.updatedAt = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_state)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t ApplicationStatus::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ApplicationStatus");

  if (this->__isset.id) {
    xfer += oprot->writeFieldBegin("id", ::apache::thrift::protocol::T_STRING, 1);
    xfer += oprot->writeString(this->id);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldBegin("state", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32((int32_t)this->state);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.description) {
    xfer += oprot->writeFieldBegin("description", ::apache::thrift::protocol::T_STRING, 3);
    xfer += oprot->writeString(this->description);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.updatedAt) {
    xfer += oprot->writeFieldBegin("updatedAt", ::apache::thrift::protocol::T_I64, 4);
    xfer += oprot->writeI64(this->updatedAt);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ApplicationStatus &a, ApplicationStatus &b) {
  using ::std::swap;
  swap(a.id, b.id);
  swap(a.state, b.state);
  swap(a.description, b.description);
  swap(a.updatedAt, b.updatedAt);
  swap(a.__isset, b.__isset);
}

ApplicationStatus::ApplicationStatus(const ApplicationStatus& other1) {
  id = other1.id;
  state = other1.state;
  description = other1.description;
  updatedAt = other1.updatedAt;
  __isset = other1.__isset;
}
ApplicationStatus& ApplicationStatus::operator=(const ApplicationStatus& other2) {
  id = other2.id;
  state = other2.state;
  description = other2.description;
  updatedAt = other2.updatedAt;
  __isset = other2.__isset;
  return *this;
}
void ApplicationStatus::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "ApplicationStatus(";
  out << "id="; (__isset.id ? (out << to_string(id)) : (out << "<null>"));
  out << ", " << "state=" << to_string(state);
  out << ", " << "description="; (__isset.description ? (out << to_string(description)) : (out << "<null>"));
  out << ", " << "updatedAt="; (__isset.updatedAt ? (out << to_string(updatedAt)) : (out << "<null>"));
  out << ")";
}


WorkflowApplication::~WorkflowApplication() throw() {
}


void WorkflowApplication::__set_id(const std::string& val) {
  this->id = val;
}

void WorkflowApplication::__set_processId(const std::string& val) {
  this->processId = val;
__isset.processId = true;
}

void WorkflowApplication::__set_applicationInterfaceId(const std::string& val) {
  this->applicationInterfaceId = val;
__isset.applicationInterfaceId = true;
}

void WorkflowApplication::__set_computeResourceId(const std::string& val) {
  this->computeResourceId = val;
__isset.computeResourceId = true;
}

void WorkflowApplication::__set_queueName(const std::string& val) {
  this->queueName = val;
__isset.queueName = true;
}

void WorkflowApplication::__set_nodeCount(const int32_t val) {
  this->nodeCount = val;
__isset.nodeCount = true;
}

void WorkflowApplication::__set_coreCount(const int32_t val) {
  this->coreCount = val;
__isset.coreCount = true;
}

void WorkflowApplication::__set_wallTimeLimit(const int32_t val) {
  this->wallTimeLimit = val;
__isset.wallTimeLimit = true;
}

void WorkflowApplication::__set_physicalMemory(const int32_t val) {
  this->physicalMemory = val;
__isset.physicalMemory = true;
}

void WorkflowApplication::__set_statuses(const std::vector<ApplicationStatus> & val) {
  this->statuses = val;
__isset.statuses = true;
}

void WorkflowApplication::__set_errors(const std::vector< ::apache::airavata::model::commons::ErrorModel> & val) {
  this->errors = val;
__isset.errors = true;
}

void WorkflowApplication::__set_createdAt(const int64_t val) {
  this->createdAt = val;
__isset.createdAt = true;
}

void WorkflowApplication::__set_updatedAt(const int64_t val) {
  this->updatedAt = val;
__isset.updatedAt = true;
}

uint32_t WorkflowApplication::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_id = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->id);
          isset_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->processId);
          this->__isset.processId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->applicationInterfaceId);
          this->__isset.applicationInterfaceId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->computeResourceId);
          this->__isset.computeResourceId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->queueName);
          this->__isset.queueName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->nodeCount);
          this->__isset.nodeCount = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->coreCount);
          this->__isset.coreCount = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->wallTimeLimit);
          this->__isset.wallTimeLimit = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->physicalMemory);
          this->__isset.physicalMemory = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->statuses.clear();
            uint32_t _size3;
            ::apache::thrift::protocol::TType _etype6;
            xfer += iprot->readListBegin(_etype6, _size3);
            this->statuses.resize(_size3);
            uint32_t _i7;
            for (_i7 = 0; _i7 < _size3; ++_i7)
            {
              xfer += this->statuses[_i7].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.statuses = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 11:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->errors.clear();
            uint32_t _size8;
            ::apache::thrift::protocol::TType _etype11;
            xfer += iprot->readListBegin(_etype11, _size8);
            this->errors.resize(_size8);
            uint32_t _i12;
            for (_i12 = 0; _i12 < _size8; ++_i12)
            {
              xfer += this->errors[_i12].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.errors = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 12:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->createdAt);
          this->__isset.createdAt = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 13:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->updatedAt);
          this->__isset.updatedAt = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_id)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t WorkflowApplication::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("WorkflowApplication");

  xfer += oprot->writeFieldBegin("id", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->id);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.processId) {
    xfer += oprot->writeFieldBegin("processId", ::apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeString(this->processId);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.applicationInterfaceId) {
    xfer += oprot->writeFieldBegin("applicationInterfaceId", ::apache::thrift::protocol::T_STRING, 3);
    xfer += oprot->writeString(this->applicationInterfaceId);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.computeResourceId) {
    xfer += oprot->writeFieldBegin("computeResourceId", ::apache::thrift::protocol::T_STRING, 4);
    xfer += oprot->writeString(this->computeResourceId);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.queueName) {
    xfer += oprot->writeFieldBegin("queueName", ::apache::thrift::protocol::T_STRING, 5);
    xfer += oprot->writeString(this->queueName);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.nodeCount) {
    xfer += oprot->writeFieldBegin("nodeCount", ::apache::thrift::protocol::T_I32, 6);
    xfer += oprot->writeI32(this->nodeCount);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.coreCount) {
    xfer += oprot->writeFieldBegin("coreCount", ::apache::thrift::protocol::T_I32, 7);
    xfer += oprot->writeI32(this->coreCount);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.wallTimeLimit) {
    xfer += oprot->writeFieldBegin("wallTimeLimit", ::apache::thrift::protocol::T_I32, 8);
    xfer += oprot->writeI32(this->wallTimeLimit);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.physicalMemory) {
    xfer += oprot->writeFieldBegin("physicalMemory", ::apache::thrift::protocol::T_I32, 9);
    xfer += oprot->writeI32(this->physicalMemory);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.statuses) {
    xfer += oprot->writeFieldBegin("statuses", ::apache::thrift::protocol::T_LIST, 10);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->statuses.size()));
      std::vector<ApplicationStatus> ::const_iterator _iter13;
      for (_iter13 = this->statuses.begin(); _iter13 != this->statuses.end(); ++_iter13)
      {
        xfer += (*_iter13).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.errors) {
    xfer += oprot->writeFieldBegin("errors", ::apache::thrift::protocol::T_LIST, 11);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->errors.size()));
      std::vector< ::apache::airavata::model::commons::ErrorModel> ::const_iterator _iter14;
      for (_iter14 = this->errors.begin(); _iter14 != this->errors.end(); ++_iter14)
      {
        xfer += (*_iter14).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.createdAt) {
    xfer += oprot->writeFieldBegin("createdAt", ::apache::thrift::protocol::T_I64, 12);
    xfer += oprot->writeI64(this->createdAt);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.updatedAt) {
    xfer += oprot->writeFieldBegin("updatedAt", ::apache::thrift::protocol::T_I64, 13);
    xfer += oprot->writeI64(this->updatedAt);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(WorkflowApplication &a, WorkflowApplication &b) {
  using ::std::swap;
  swap(a.id, b.id);
  swap(a.processId, b.processId);
  swap(a.applicationInterfaceId, b.applicationInterfaceId);
  swap(a.computeResourceId, b.computeResourceId);
  swap(a.queueName, b.queueName);
  swap(a.nodeCount, b.nodeCount);
  swap(a.coreCount, b.coreCount);
  swap(a.wallTimeLimit, b.wallTimeLimit);
  swap(a.physicalMemory, b.physicalMemory);
  swap(a.statuses, b.statuses);
  swap(a.errors, b.errors);
  swap(a.createdAt, b.createdAt);
  swap(a.updatedAt, b.updatedAt);
  swap(a.__isset, b.__isset);
}

WorkflowApplication::WorkflowApplication(const WorkflowApplication& other15) {
  id = other15.id;
  processId = other15.processId;
  applicationInterfaceId = other15.applicationInterfaceId;
  computeResourceId = other15.computeResourceId;
  queueName = other15.queueName;
  nodeCount = other15.nodeCount;
  coreCount = other15.coreCount;
  wallTimeLimit = other15.wallTimeLimit;
  physicalMemory = other15.physicalMemory;
  statuses = other15.statuses;
  errors = other15.errors;
  createdAt = other15.createdAt;
  updatedAt = other15.updatedAt;
  __isset = other15.__isset;
}
WorkflowApplication& WorkflowApplication::operator=(const WorkflowApplication& other16) {
  id = other16.id;
  processId = other16.processId;
  applicationInterfaceId = other16.applicationInterfaceId;
  computeResourceId = other16.computeResourceId;
  queueName = other16.queueName;
  nodeCount = other16.nodeCount;
  coreCount = other16.coreCount;
  wallTimeLimit = other16.wallTimeLimit;
  physicalMemory = other16.physicalMemory;
  statuses = other16.statuses;
  errors = other16.errors;
  createdAt = other16.createdAt;
  updatedAt = other16.updatedAt;
  __isset = other16.__isset;
  return *this;
}
void WorkflowApplication::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "WorkflowApplication(";
  out << "id=" << to_string(id);
  out << ", " << "processId="; (__isset.processId ? (out << to_string(processId)) : (out << "<null>"));
  out << ", " << "applicationInterfaceId="; (__isset.applicationInterfaceId ? (out << to_string(applicationInterfaceId)) : (out << "<null>"));
  out << ", " << "computeResourceId="; (__isset.computeResourceId ? (out << to_string(computeResourceId)) : (out << "<null>"));
  out << ", " << "queueName="; (__isset.queueName ? (out << to_string(queueName)) : (out << "<null>"));
  out << ", " << "nodeCount="; (__isset.nodeCount ? (out << to_string(nodeCount)) : (out << "<null>"));
  out << ", " << "coreCount="; (__isset.coreCount ? (out << to_string(coreCount)) : (out << "<null>"));
  out << ", " << "wallTimeLimit="; (__isset.wallTimeLimit ? (out << to_string(wallTimeLimit)) : (out << "<null>"));
  out << ", " << "physicalMemory="; (__isset.physicalMemory ? (out << to_string(physicalMemory)) : (out << "<null>"));
  out << ", " << "statuses="; (__isset.statuses ? (out << to_string(statuses)) : (out << "<null>"));
  out << ", " << "errors="; (__isset.errors ? (out << to_string(errors)) : (out << "<null>"));
  out << ", " << "createdAt="; (__isset.createdAt ? (out << to_string(createdAt)) : (out << "<null>"));
  out << ", " << "updatedAt="; (__isset.updatedAt ? (out << to_string(updatedAt)) : (out << "<null>"));
  out << ")";
}


DataBlock::~DataBlock() throw() {
}


void DataBlock::__set_id(const std::string& val) {
  this->id = val;
}

void DataBlock::__set_value(const std::string& val) {
  this->value = val;
__isset.value = true;
}

void DataBlock::__set_type(const  ::apache::airavata::model::application::io::DataType::type val) {
  this->type = val;
__isset.type = true;
}

void DataBlock::__set_createdAt(const int64_t val) {
  this->createdAt = val;
__isset.createdAt = true;
}

void DataBlock::__set_updatedAt(const int64_t val) {
  this->updatedAt = val;
__isset.updatedAt = true;
}

uint32_t DataBlock::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_id = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->id);
          isset_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->value);
          this->__isset.value = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast17;
          xfer += iprot->readI32(ecast17);
          this->type = ( ::apache::airavata::model::application::io::DataType::type)ecast17;
          this->__isset.type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->createdAt);
          this->__isset.createdAt = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->updatedAt);
          this->__isset.updatedAt = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_id)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t DataBlock::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("DataBlock");

  xfer += oprot->writeFieldBegin("id", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->id);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.value) {
    xfer += oprot->writeFieldBegin("value", ::apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeString(this->value);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.type) {
    xfer += oprot->writeFieldBegin("type", ::apache::thrift::protocol::T_I32, 3);
    xfer += oprot->writeI32((int32_t)this->type);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.createdAt) {
    xfer += oprot->writeFieldBegin("createdAt", ::apache::thrift::protocol::T_I64, 4);
    xfer += oprot->writeI64(this->createdAt);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.updatedAt) {
    xfer += oprot->writeFieldBegin("updatedAt", ::apache::thrift::protocol::T_I64, 5);
    xfer += oprot->writeI64(this->updatedAt);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(DataBlock &a, DataBlock &b) {
  using ::std::swap;
  swap(a.id, b.id);
  swap(a.value, b.value);
  swap(a.type, b.type);
  swap(a.createdAt, b.createdAt);
  swap(a.updatedAt, b.updatedAt);
  swap(a.__isset, b.__isset);
}

DataBlock::DataBlock(const DataBlock& other18) {
  id = other18.id;
  value = other18.value;
  type = other18.type;
  createdAt = other18.createdAt;
  updatedAt = other18.updatedAt;
  __isset = other18.__isset;
}
DataBlock& DataBlock::operator=(const DataBlock& other19) {
  id = other19.id;
  value = other19.value;
  type = other19.type;
  createdAt = other19.createdAt;
  updatedAt = other19.updatedAt;
  __isset = other19.__isset;
  return *this;
}
void DataBlock::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "DataBlock(";
  out << "id=" << to_string(id);
  out << ", " << "value="; (__isset.value ? (out << to_string(value)) : (out << "<null>"));
  out << ", " << "type="; (__isset.type ? (out << to_string(type)) : (out << "<null>"));
  out << ", " << "createdAt="; (__isset.createdAt ? (out << to_string(createdAt)) : (out << "<null>"));
  out << ", " << "updatedAt="; (__isset.updatedAt ? (out << to_string(updatedAt)) : (out << "<null>"));
  out << ")";
}


WorkflowConnection::~WorkflowConnection() throw() {
}


void WorkflowConnection::__set_id(const std::string& val) {
  this->id = val;
}

void WorkflowConnection::__set_dataBlock(const DataBlock& val) {
  this->dataBlock = val;
__isset.dataBlock = true;
}

void WorkflowConnection::__set_fromType(const ComponentType::type val) {
  this->fromType = val;
}

void WorkflowConnection::__set_fromId(const std::string& val) {
  this->fromId = val;
}

void WorkflowConnection::__set_fromOutputName(const std::string& val) {
  this->fromOutputName = val;
}

void WorkflowConnection::__set_toType(const ComponentType::type val) {
  this->toType = val;
}

void WorkflowConnection::__set_toId(const std::string& val) {
  this->toId = val;
}

void WorkflowConnection::__set_toInputName(const std::string& val) {
  this->toInputName = val;
}

void WorkflowConnection::__set_createdAt(const int64_t val) {
  this->createdAt = val;
__isset.createdAt = true;
}

void WorkflowConnection::__set_updatedAt(const int64_t val) {
  this->updatedAt = val;
__isset.updatedAt = true;
}

uint32_t WorkflowConnection::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_id = false;
  bool isset_fromType = false;
  bool isset_fromId = false;
  bool isset_fromOutputName = false;
  bool isset_toType = false;
  bool isset_toId = false;
  bool isset_toInputName = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->id);
          isset_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->dataBlock.read(iprot);
          this->__isset.dataBlock = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast20;
          xfer += iprot->readI32(ecast20);
          this->fromType = (ComponentType::type)ecast20;
          isset_fromType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->fromId);
          isset_fromId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->fromOutputName);
          isset_fromOutputName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast21;
          xfer += iprot->readI32(ecast21);
          this->toType = (ComponentType::type)ecast21;
          isset_toType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->toId);
          isset_toId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->toInputName);
          isset_toInputName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->createdAt);
          this->__isset.createdAt = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->updatedAt);
          this->__isset.updatedAt = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_id)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_fromType)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_fromId)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_fromOutputName)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_toType)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_toId)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_toInputName)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t WorkflowConnection::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("WorkflowConnection");

  xfer += oprot->writeFieldBegin("id", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->id);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.dataBlock) {
    xfer += oprot->writeFieldBegin("dataBlock", ::apache::thrift::protocol::T_STRUCT, 2);
    xfer += this->dataBlock.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldBegin("fromType", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32((int32_t)this->fromType);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("fromId", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString(this->fromId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("fromOutputName", ::apache::thrift::protocol::T_STRING, 5);
  xfer += oprot->writeString(this->fromOutputName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("toType", ::apache::thrift::protocol::T_I32, 6);
  xfer += oprot->writeI32((int32_t)this->toType);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("toId", ::apache::thrift::protocol::T_STRING, 7);
  xfer += oprot->writeString(this->toId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("toInputName", ::apache::thrift::protocol::T_STRING, 8);
  xfer += oprot->writeString(this->toInputName);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.createdAt) {
    xfer += oprot->writeFieldBegin("createdAt", ::apache::thrift::protocol::T_I64, 9);
    xfer += oprot->writeI64(this->createdAt);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.updatedAt) {
    xfer += oprot->writeFieldBegin("updatedAt", ::apache::thrift::protocol::T_I64, 10);
    xfer += oprot->writeI64(this->updatedAt);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(WorkflowConnection &a, WorkflowConnection &b) {
  using ::std::swap;
  swap(a.id, b.id);
  swap(a.dataBlock, b.dataBlock);
  swap(a.fromType, b.fromType);
  swap(a.fromId, b.fromId);
  swap(a.fromOutputName, b.fromOutputName);
  swap(a.toType, b.toType);
  swap(a.toId, b.toId);
  swap(a.toInputName, b.toInputName);
  swap(a.createdAt, b.createdAt);
  swap(a.updatedAt, b.updatedAt);
  swap(a.__isset, b.__isset);
}

WorkflowConnection::WorkflowConnection(const WorkflowConnection& other22) {
  id = other22.id;
  dataBlock = other22.dataBlock;
  fromType = other22.fromType;
  fromId = other22.fromId;
  fromOutputName = other22.fromOutputName;
  toType = other22.toType;
  toId = other22.toId;
  toInputName = other22.toInputName;
  createdAt = other22.createdAt;
  updatedAt = other22.updatedAt;
  __isset = other22.__isset;
}
WorkflowConnection& WorkflowConnection::operator=(const WorkflowConnection& other23) {
  id = other23.id;
  dataBlock = other23.dataBlock;
  fromType = other23.fromType;
  fromId = other23.fromId;
  fromOutputName = other23.fromOutputName;
  toType = other23.toType;
  toId = other23.toId;
  toInputName = other23.toInputName;
  createdAt = other23.createdAt;
  updatedAt = other23.updatedAt;
  __isset = other23.__isset;
  return *this;
}
void WorkflowConnection::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "WorkflowConnection(";
  out << "id=" << to_string(id);
  out << ", " << "dataBlock="; (__isset.dataBlock ? (out << to_string(dataBlock)) : (out << "<null>"));
  out << ", " << "fromType=" << to_string(fromType);
  out << ", " << "fromId=" << to_string(fromId);
  out << ", " << "fromOutputName=" << to_string(fromOutputName);
  out << ", " << "toType=" << to_string(toType);
  out << ", " << "toId=" << to_string(toId);
  out << ", " << "toInputName=" << to_string(toInputName);
  out << ", " << "createdAt="; (__isset.createdAt ? (out << to_string(createdAt)) : (out << "<null>"));
  out << ", " << "updatedAt="; (__isset.updatedAt ? (out << to_string(updatedAt)) : (out << "<null>"));
  out << ")";
}


HandlerStatus::~HandlerStatus() throw() {
}


void HandlerStatus::__set_id(const std::string& val) {
  this->id = val;
__isset.id = true;
}

void HandlerStatus::__set_state(const HandlerState::type val) {
  this->state = val;
}

void HandlerStatus::__set_description(const std::string& val) {
  this->description = val;
__isset.description = true;
}

void HandlerStatus::__set_updatedAt(const int64_t val) {
  this->updatedAt = val;
__isset.updatedAt = true;
}

uint32_t HandlerStatus::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_state = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->id);
          this->__isset.id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast24;
          xfer += iprot->readI32(ecast24);
          this->state = (HandlerState::type)ecast24;
          isset_state = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->description);
          this->__isset.description = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->updatedAt);
          this->__isset.updatedAt = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_state)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t HandlerStatus::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HandlerStatus");

  if (this->__isset.id) {
    xfer += oprot->writeFieldBegin("id", ::apache::thrift::protocol::T_STRING, 1);
    xfer += oprot->writeString(this->id);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldBegin("state", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32((int32_t)this->state);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.description) {
    xfer += oprot->writeFieldBegin("description", ::apache::thrift::protocol::T_STRING, 3);
    xfer += oprot->writeString(this->description);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.updatedAt) {
    xfer += oprot->writeFieldBegin("updatedAt", ::apache::thrift::protocol::T_I64, 4);
    xfer += oprot->writeI64(this->updatedAt);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(HandlerStatus &a, HandlerStatus &b) {
  using ::std::swap;
  swap(a.id, b.id);
  swap(a.state, b.state);
  swap(a.description, b.description);
  swap(a.updatedAt, b.updatedAt);
  swap(a.__isset, b.__isset);
}

HandlerStatus::HandlerStatus(const HandlerStatus& other25) {
  id = other25.id;
  state = other25.state;
  description = other25.description;
  updatedAt = other25.updatedAt;
  __isset = other25.__isset;
}
HandlerStatus& HandlerStatus::operator=(const HandlerStatus& other26) {
  id = other26.id;
  state = other26.state;
  description = other26.description;
  updatedAt = other26.updatedAt;
  __isset = other26.__isset;
  return *this;
}
void HandlerStatus::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "HandlerStatus(";
  out << "id="; (__isset.id ? (out << to_string(id)) : (out << "<null>"));
  out << ", " << "state=" << to_string(state);
  out << ", " << "description="; (__isset.description ? (out << to_string(description)) : (out << "<null>"));
  out << ", " << "updatedAt="; (__isset.updatedAt ? (out << to_string(updatedAt)) : (out << "<null>"));
  out << ")";
}


WorkflowHandler::~WorkflowHandler() throw() {
}


void WorkflowHandler::__set_id(const std::string& val) {
  this->id = val;
}

void WorkflowHandler::__set_type(const HandlerType::type val) {
  this->type = val;
}

void WorkflowHandler::__set_inputs(const std::vector< ::apache::airavata::model::application::io::InputDataObjectType> & val) {
  this->inputs = val;
__isset.inputs = true;
}

void WorkflowHandler::__set_outputs(const std::vector< ::apache::airavata::model::application::io::OutputDataObjectType> & val) {
  this->outputs = val;
__isset.outputs = true;
}

void WorkflowHandler::__set_statuses(const std::vector<HandlerStatus> & val) {
  this->statuses = val;
__isset.statuses = true;
}

void WorkflowHandler::__set_errors(const std::vector< ::apache::airavata::model::commons::ErrorModel> & val) {
  this->errors = val;
__isset.errors = true;
}

void WorkflowHandler::__set_createdAt(const int64_t val) {
  this->createdAt = val;
__isset.createdAt = true;
}

void WorkflowHandler::__set_updatedAt(const int64_t val) {
  this->updatedAt = val;
__isset.updatedAt = true;
}

uint32_t WorkflowHandler::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_id = false;
  bool isset_type = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->id);
          isset_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast27;
          xfer += iprot->readI32(ecast27);
          this->type = (HandlerType::type)ecast27;
          isset_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->inputs.clear();
            uint32_t _size28;
            ::apache::thrift::protocol::TType _etype31;
            xfer += iprot->readListBegin(_etype31, _size28);
            this->inputs.resize(_size28);
            uint32_t _i32;
            for (_i32 = 0; _i32 < _size28; ++_i32)
            {
              xfer += this->inputs[_i32].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.inputs = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->outputs.clear();
            uint32_t _size33;
            ::apache::thrift::protocol::TType _etype36;
            xfer += iprot->readListBegin(_etype36, _size33);
            this->outputs.resize(_size33);
            uint32_t _i37;
            for (_i37 = 0; _i37 < _size33; ++_i37)
            {
              xfer += this->outputs[_i37].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.outputs = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->statuses.clear();
            uint32_t _size38;
            ::apache::thrift::protocol::TType _etype41;
            xfer += iprot->readListBegin(_etype41, _size38);
            this->statuses.resize(_size38);
            uint32_t _i42;
            for (_i42 = 0; _i42 < _size38; ++_i42)
            {
              xfer += this->statuses[_i42].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.statuses = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->errors.clear();
            uint32_t _size43;
            ::apache::thrift::protocol::TType _etype46;
            xfer += iprot->readListBegin(_etype46, _size43);
            this->errors.resize(_size43);
            uint32_t _i47;
            for (_i47 = 0; _i47 < _size43; ++_i47)
            {
              xfer += this->errors[_i47].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.errors = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->createdAt);
          this->__isset.createdAt = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->updatedAt);
          this->__isset.updatedAt = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_id)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_type)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t WorkflowHandler::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("WorkflowHandler");

  xfer += oprot->writeFieldBegin("id", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("type", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32((int32_t)this->type);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.inputs) {
    xfer += oprot->writeFieldBegin("inputs", ::apache::thrift::protocol::T_LIST, 3);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->inputs.size()));
      std::vector< ::apache::airavata::model::application::io::InputDataObjectType> ::const_iterator _iter48;
      for (_iter48 = this->inputs.begin(); _iter48 != this->inputs.end(); ++_iter48)
      {
        xfer += (*_iter48).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.outputs) {
    xfer += oprot->writeFieldBegin("outputs", ::apache::thrift::protocol::T_LIST, 4);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->outputs.size()));
      std::vector< ::apache::airavata::model::application::io::OutputDataObjectType> ::const_iterator _iter49;
      for (_iter49 = this->outputs.begin(); _iter49 != this->outputs.end(); ++_iter49)
      {
        xfer += (*_iter49).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.statuses) {
    xfer += oprot->writeFieldBegin("statuses", ::apache::thrift::protocol::T_LIST, 5);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->statuses.size()));
      std::vector<HandlerStatus> ::const_iterator _iter50;
      for (_iter50 = this->statuses.begin(); _iter50 != this->statuses.end(); ++_iter50)
      {
        xfer += (*_iter50).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.errors) {
    xfer += oprot->writeFieldBegin("errors", ::apache::thrift::protocol::T_LIST, 6);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->errors.size()));
      std::vector< ::apache::airavata::model::commons::ErrorModel> ::const_iterator _iter51;
      for (_iter51 = this->errors.begin(); _iter51 != this->errors.end(); ++_iter51)
      {
        xfer += (*_iter51).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.createdAt) {
    xfer += oprot->writeFieldBegin("createdAt", ::apache::thrift::protocol::T_I64, 7);
    xfer += oprot->writeI64(this->createdAt);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.updatedAt) {
    xfer += oprot->writeFieldBegin("updatedAt", ::apache::thrift::protocol::T_I64, 8);
    xfer += oprot->writeI64(this->updatedAt);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(WorkflowHandler &a, WorkflowHandler &b) {
  using ::std::swap;
  swap(a.id, b.id);
  swap(a.type, b.type);
  swap(a.inputs, b.inputs);
  swap(a.outputs, b.outputs);
  swap(a.statuses, b.statuses);
  swap(a.errors, b.errors);
  swap(a.createdAt, b.createdAt);
  swap(a.updatedAt, b.updatedAt);
  swap(a.__isset, b.__isset);
}

WorkflowHandler::WorkflowHandler(const WorkflowHandler& other52) {
  id = other52.id;
  type = other52.type;
  inputs = other52.inputs;
  outputs = other52.outputs;
  statuses = other52.statuses;
  errors = other52.errors;
  createdAt = other52.createdAt;
  updatedAt = other52.updatedAt;
  __isset = other52.__isset;
}
WorkflowHandler& WorkflowHandler::operator=(const WorkflowHandler& other53) {
  id = other53.id;
  type = other53.type;
  inputs = other53.inputs;
  outputs = other53.outputs;
  statuses = other53.statuses;
  errors = other53.errors;
  createdAt = other53.createdAt;
  updatedAt = other53.updatedAt;
  __isset = other53.__isset;
  return *this;
}
void WorkflowHandler::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "WorkflowHandler(";
  out << "id=" << to_string(id);
  out << ", " << "type=" << to_string(type);
  out << ", " << "inputs="; (__isset.inputs ? (out << to_string(inputs)) : (out << "<null>"));
  out << ", " << "outputs="; (__isset.outputs ? (out << to_string(outputs)) : (out << "<null>"));
  out << ", " << "statuses="; (__isset.statuses ? (out << to_string(statuses)) : (out << "<null>"));
  out << ", " << "errors="; (__isset.errors ? (out << to_string(errors)) : (out << "<null>"));
  out << ", " << "createdAt="; (__isset.createdAt ? (out << to_string(createdAt)) : (out << "<null>"));
  out << ", " << "updatedAt="; (__isset.updatedAt ? (out << to_string(updatedAt)) : (out << "<null>"));
  out << ")";
}


WorkflowStatus::~WorkflowStatus() throw() {
}


void WorkflowStatus::__set_id(const std::string& val) {
  this->id = val;
__isset.id = true;
}

void WorkflowStatus::__set_state(const WorkflowState::type val) {
  this->state = val;
}

void WorkflowStatus::__set_description(const std::string& val) {
  this->description = val;
__isset.description = true;
}

void WorkflowStatus::__set_updatedAt(const int64_t val) {
  this->updatedAt = val;
__isset.updatedAt = true;
}

uint32_t WorkflowStatus::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_state = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->id);
          this->__isset.id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast54;
          xfer += iprot->readI32(ecast54);
          this->state = (WorkflowState::type)ecast54;
          isset_state = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->description);
          this->__isset.description = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->updatedAt);
          this->__isset.updatedAt = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_state)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t WorkflowStatus::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("WorkflowStatus");

  if (this->__isset.id) {
    xfer += oprot->writeFieldBegin("id", ::apache::thrift::protocol::T_STRING, 1);
    xfer += oprot->writeString(this->id);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldBegin("state", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32((int32_t)this->state);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.description) {
    xfer += oprot->writeFieldBegin("description", ::apache::thrift::protocol::T_STRING, 3);
    xfer += oprot->writeString(this->description);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.updatedAt) {
    xfer += oprot->writeFieldBegin("updatedAt", ::apache::thrift::protocol::T_I64, 4);
    xfer += oprot->writeI64(this->updatedAt);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(WorkflowStatus &a, WorkflowStatus &b) {
  using ::std::swap;
  swap(a.id, b.id);
  swap(a.state, b.state);
  swap(a.description, b.description);
  swap(a.updatedAt, b.updatedAt);
  swap(a.__isset, b.__isset);
}

WorkflowStatus::WorkflowStatus(const WorkflowStatus& other55) {
  id = other55.id;
  state = other55.state;
  description = other55.description;
  updatedAt = other55.updatedAt;
  __isset = other55.__isset;
}
WorkflowStatus& WorkflowStatus::operator=(const WorkflowStatus& other56) {
  id = other56.id;
  state = other56.state;
  description = other56.description;
  updatedAt = other56.updatedAt;
  __isset = other56.__isset;
  return *this;
}
void WorkflowStatus::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "WorkflowStatus(";
  out << "id="; (__isset.id ? (out << to_string(id)) : (out << "<null>"));
  out << ", " << "state=" << to_string(state);
  out << ", " << "description="; (__isset.description ? (out << to_string(description)) : (out << "<null>"));
  out << ", " << "updatedAt="; (__isset.updatedAt ? (out << to_string(updatedAt)) : (out << "<null>"));
  out << ")";
}


AiravataWorkflow::~AiravataWorkflow() throw() {
}


void AiravataWorkflow::__set_id(const std::string& val) {
  this->id = val;
}

void AiravataWorkflow::__set_experimentId(const std::string& val) {
  this->experimentId = val;
}

void AiravataWorkflow::__set_description(const std::string& val) {
  this->description = val;
__isset.description = true;
}

void AiravataWorkflow::__set_applications(const std::vector<WorkflowApplication> & val) {
  this->applications = val;
__isset.applications = true;
}

void AiravataWorkflow::__set_handlers(const std::vector<WorkflowHandler> & val) {
  this->handlers = val;
__isset.handlers = true;
}

void AiravataWorkflow::__set_connections(const std::vector<WorkflowConnection> & val) {
  this->connections = val;
__isset.connections = true;
}

void AiravataWorkflow::__set_statuses(const std::vector<WorkflowStatus> & val) {
  this->statuses = val;
__isset.statuses = true;
}

void AiravataWorkflow::__set_errors(const std::vector< ::apache::airavata::model::commons::ErrorModel> & val) {
  this->errors = val;
__isset.errors = true;
}

void AiravataWorkflow::__set_createdAt(const int64_t val) {
  this->createdAt = val;
__isset.createdAt = true;
}

void AiravataWorkflow::__set_updatedAt(const int64_t val) {
  this->updatedAt = val;
__isset.updatedAt = true;
}

uint32_t AiravataWorkflow::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_id = false;
  bool isset_experimentId = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->id);
          isset_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->experimentId);
          isset_experimentId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->description);
          this->__isset.description = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->applications.clear();
            uint32_t _size57;
            ::apache::thrift::protocol::TType _etype60;
            xfer += iprot->readListBegin(_etype60, _size57);
            this->applications.resize(_size57);
            uint32_t _i61;
            for (_i61 = 0; _i61 < _size57; ++_i61)
            {
              xfer += this->applications[_i61].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.applications = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->handlers.clear();
            uint32_t _size62;
            ::apache::thrift::protocol::TType _etype65;
            xfer += iprot->readListBegin(_etype65, _size62);
            this->handlers.resize(_size62);
            uint32_t _i66;
            for (_i66 = 0; _i66 < _size62; ++_i66)
            {
              xfer += this->handlers[_i66].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.handlers = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->connections.clear();
            uint32_t _size67;
            ::apache::thrift::protocol::TType _etype70;
            xfer += iprot->readListBegin(_etype70, _size67);
            this->connections.resize(_size67);
            uint32_t _i71;
            for (_i71 = 0; _i71 < _size67; ++_i71)
            {
              xfer += this->connections[_i71].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.connections = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->statuses.clear();
            uint32_t _size72;
            ::apache::thrift::protocol::TType _etype75;
            xfer += iprot->readListBegin(_etype75, _size72);
            this->statuses.resize(_size72);
            uint32_t _i76;
            for (_i76 = 0; _i76 < _size72; ++_i76)
            {
              xfer += this->statuses[_i76].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.statuses = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->errors.clear();
            uint32_t _size77;
            ::apache::thrift::protocol::TType _etype80;
            xfer += iprot->readListBegin(_etype80, _size77);
            this->errors.resize(_size77);
            uint32_t _i81;
            for (_i81 = 0; _i81 < _size77; ++_i81)
            {
              xfer += this->errors[_i81].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.errors = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->createdAt);
          this->__isset.createdAt = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->updatedAt);
          this->__isset.updatedAt = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_id)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_experimentId)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t AiravataWorkflow::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("AiravataWorkflow");

  xfer += oprot->writeFieldBegin("id", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("experimentId", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->experimentId);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.description) {
    xfer += oprot->writeFieldBegin("description", ::apache::thrift::protocol::T_STRING, 3);
    xfer += oprot->writeString(this->description);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.applications) {
    xfer += oprot->writeFieldBegin("applications", ::apache::thrift::protocol::T_LIST, 4);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->applications.size()));
      std::vector<WorkflowApplication> ::const_iterator _iter82;
      for (_iter82 = this->applications.begin(); _iter82 != this->applications.end(); ++_iter82)
      {
        xfer += (*_iter82).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.handlers) {
    xfer += oprot->writeFieldBegin("handlers", ::apache::thrift::protocol::T_LIST, 5);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->handlers.size()));
      std::vector<WorkflowHandler> ::const_iterator _iter83;
      for (_iter83 = this->handlers.begin(); _iter83 != this->handlers.end(); ++_iter83)
      {
        xfer += (*_iter83).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.connections) {
    xfer += oprot->writeFieldBegin("connections", ::apache::thrift::protocol::T_LIST, 6);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->connections.size()));
      std::vector<WorkflowConnection> ::const_iterator _iter84;
      for (_iter84 = this->connections.begin(); _iter84 != this->connections.end(); ++_iter84)
      {
        xfer += (*_iter84).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.statuses) {
    xfer += oprot->writeFieldBegin("statuses", ::apache::thrift::protocol::T_LIST, 7);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->statuses.size()));
      std::vector<WorkflowStatus> ::const_iterator _iter85;
      for (_iter85 = this->statuses.begin(); _iter85 != this->statuses.end(); ++_iter85)
      {
        xfer += (*_iter85).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.errors) {
    xfer += oprot->writeFieldBegin("errors", ::apache::thrift::protocol::T_LIST, 8);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->errors.size()));
      std::vector< ::apache::airavata::model::commons::ErrorModel> ::const_iterator _iter86;
      for (_iter86 = this->errors.begin(); _iter86 != this->errors.end(); ++_iter86)
      {
        xfer += (*_iter86).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.createdAt) {
    xfer += oprot->writeFieldBegin("createdAt", ::apache::thrift::protocol::T_I64, 9);
    xfer += oprot->writeI64(this->createdAt);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.updatedAt) {
    xfer += oprot->writeFieldBegin("updatedAt", ::apache::thrift::protocol::T_I64, 10);
    xfer += oprot->writeI64(this->updatedAt);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(AiravataWorkflow &a, AiravataWorkflow &b) {
  using ::std::swap;
  swap(a.id, b.id);
  swap(a.experimentId, b.experimentId);
  swap(a.description, b.description);
  swap(a.applications, b.applications);
  swap(a.handlers, b.handlers);
  swap(a.connections, b.connections);
  swap(a.statuses, b.statuses);
  swap(a.errors, b.errors);
  swap(a.createdAt, b.createdAt);
  swap(a.updatedAt, b.updatedAt);
  swap(a.__isset, b.__isset);
}

AiravataWorkflow::AiravataWorkflow(const AiravataWorkflow& other87) {
  id = other87.id;
  experimentId = other87.experimentId;
  description = other87.description;
  applications = other87.applications;
  handlers = other87.handlers;
  connections = other87.connections;
  statuses = other87.statuses;
  errors = other87.errors;
  createdAt = other87.createdAt;
  updatedAt = other87.updatedAt;
  __isset = other87.__isset;
}
AiravataWorkflow& AiravataWorkflow::operator=(const AiravataWorkflow& other88) {
  id = other88.id;
  experimentId = other88.experimentId;
  description = other88.description;
  applications = other88.applications;
  handlers = other88.handlers;
  connections = other88.connections;
  statuses = other88.statuses;
  errors = other88.errors;
  createdAt = other88.createdAt;
  updatedAt = other88.updatedAt;
  __isset = other88.__isset;
  return *this;
}
void AiravataWorkflow::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "AiravataWorkflow(";
  out << "id=" << to_string(id);
  out << ", " << "experimentId=" << to_string(experimentId);
  out << ", " << "description="; (__isset.description ? (out << to_string(description)) : (out << "<null>"));
  out << ", " << "applications="; (__isset.applications ? (out << to_string(applications)) : (out << "<null>"));
  out << ", " << "handlers="; (__isset.handlers ? (out << to_string(handlers)) : (out << "<null>"));
  out << ", " << "connections="; (__isset.connections ? (out << to_string(connections)) : (out << "<null>"));
  out << ", " << "statuses="; (__isset.statuses ? (out << to_string(statuses)) : (out << "<null>"));
  out << ", " << "errors="; (__isset.errors ? (out << to_string(errors)) : (out << "<null>"));
  out << ", " << "createdAt="; (__isset.createdAt ? (out << to_string(createdAt)) : (out << "<null>"));
  out << ", " << "updatedAt="; (__isset.updatedAt ? (out << to_string(updatedAt)) : (out << "<null>"));
  out << ")";
}

}}}} // namespace
