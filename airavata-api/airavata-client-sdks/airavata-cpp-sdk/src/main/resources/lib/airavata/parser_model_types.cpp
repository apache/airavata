/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Autogenerated by Thrift Compiler (0.10.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#include "parser_model_types.h"

#include <algorithm>
#include <ostream>

#include <thrift/TToString.h>

namespace apache { namespace airavata { namespace model { namespace appcatalog { namespace parser {

int _kIOTypeValues[] = {
  IOType::FILE,
  IOType::PROPERTY
};
const char* _kIOTypeNames[] = {
  "FILE",
  "PROPERTY"
};
const std::map<int, const char*> _IOType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(2, _kIOTypeValues, _kIOTypeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));


ParserInput::~ParserInput() throw() {
}


void ParserInput::__set_id(const std::string& val) {
  this->id = val;
}

void ParserInput::__set_name(const std::string& val) {
  this->name = val;
}

void ParserInput::__set_requiredInput(const bool val) {
  this->requiredInput = val;
}

void ParserInput::__set_parserId(const std::string& val) {
  this->parserId = val;
}

void ParserInput::__set_type(const IOType::type val) {
  this->type = val;
}

uint32_t ParserInput::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_id = false;
  bool isset_name = false;
  bool isset_requiredInput = false;
  bool isset_parserId = false;
  bool isset_type = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->id);
          isset_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->name);
          isset_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->requiredInput);
          isset_requiredInput = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->parserId);
          isset_parserId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast0;
          xfer += iprot->readI32(ecast0);
          this->type = (IOType::type)ecast0;
          isset_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_id)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_name)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_requiredInput)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_parserId)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_type)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t ParserInput::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ParserInput");

  xfer += oprot->writeFieldBegin("id", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("name", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("requiredInput", ::apache::thrift::protocol::T_BOOL, 3);
  xfer += oprot->writeBool(this->requiredInput);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("parserId", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString(this->parserId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("type", ::apache::thrift::protocol::T_I32, 5);
  xfer += oprot->writeI32((int32_t)this->type);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ParserInput &a, ParserInput &b) {
  using ::std::swap;
  swap(a.id, b.id);
  swap(a.name, b.name);
  swap(a.requiredInput, b.requiredInput);
  swap(a.parserId, b.parserId);
  swap(a.type, b.type);
}

ParserInput::ParserInput(const ParserInput& other1) {
  id = other1.id;
  name = other1.name;
  requiredInput = other1.requiredInput;
  parserId = other1.parserId;
  type = other1.type;
}
ParserInput& ParserInput::operator=(const ParserInput& other2) {
  id = other2.id;
  name = other2.name;
  requiredInput = other2.requiredInput;
  parserId = other2.parserId;
  type = other2.type;
  return *this;
}
void ParserInput::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "ParserInput(";
  out << "id=" << to_string(id);
  out << ", " << "name=" << to_string(name);
  out << ", " << "requiredInput=" << to_string(requiredInput);
  out << ", " << "parserId=" << to_string(parserId);
  out << ", " << "type=" << to_string(type);
  out << ")";
}


ParserOutput::~ParserOutput() throw() {
}


void ParserOutput::__set_id(const std::string& val) {
  this->id = val;
}

void ParserOutput::__set_name(const std::string& val) {
  this->name = val;
}

void ParserOutput::__set_requiredOutput(const bool val) {
  this->requiredOutput = val;
}

void ParserOutput::__set_parserId(const std::string& val) {
  this->parserId = val;
}

void ParserOutput::__set_type(const IOType::type val) {
  this->type = val;
}

uint32_t ParserOutput::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_id = false;
  bool isset_name = false;
  bool isset_requiredOutput = false;
  bool isset_parserId = false;
  bool isset_type = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->id);
          isset_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->name);
          isset_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->requiredOutput);
          isset_requiredOutput = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->parserId);
          isset_parserId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast3;
          xfer += iprot->readI32(ecast3);
          this->type = (IOType::type)ecast3;
          isset_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_id)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_name)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_requiredOutput)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_parserId)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_type)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t ParserOutput::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ParserOutput");

  xfer += oprot->writeFieldBegin("id", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("name", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("requiredOutput", ::apache::thrift::protocol::T_BOOL, 3);
  xfer += oprot->writeBool(this->requiredOutput);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("parserId", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString(this->parserId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("type", ::apache::thrift::protocol::T_I32, 5);
  xfer += oprot->writeI32((int32_t)this->type);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ParserOutput &a, ParserOutput &b) {
  using ::std::swap;
  swap(a.id, b.id);
  swap(a.name, b.name);
  swap(a.requiredOutput, b.requiredOutput);
  swap(a.parserId, b.parserId);
  swap(a.type, b.type);
}

ParserOutput::ParserOutput(const ParserOutput& other4) {
  id = other4.id;
  name = other4.name;
  requiredOutput = other4.requiredOutput;
  parserId = other4.parserId;
  type = other4.type;
}
ParserOutput& ParserOutput::operator=(const ParserOutput& other5) {
  id = other5.id;
  name = other5.name;
  requiredOutput = other5.requiredOutput;
  parserId = other5.parserId;
  type = other5.type;
  return *this;
}
void ParserOutput::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "ParserOutput(";
  out << "id=" << to_string(id);
  out << ", " << "name=" << to_string(name);
  out << ", " << "requiredOutput=" << to_string(requiredOutput);
  out << ", " << "parserId=" << to_string(parserId);
  out << ", " << "type=" << to_string(type);
  out << ")";
}


Parser::~Parser() throw() {
}


void Parser::__set_id(const std::string& val) {
  this->id = val;
}

void Parser::__set_imageName(const std::string& val) {
  this->imageName = val;
}

void Parser::__set_outputDirPath(const std::string& val) {
  this->outputDirPath = val;
}

void Parser::__set_inputDirPath(const std::string& val) {
  this->inputDirPath = val;
}

void Parser::__set_executionCommand(const std::string& val) {
  this->executionCommand = val;
}

void Parser::__set_inputFiles(const std::vector<ParserInput> & val) {
  this->inputFiles = val;
}

void Parser::__set_outputFiles(const std::vector<ParserOutput> & val) {
  this->outputFiles = val;
}

void Parser::__set_gatewayId(const std::string& val) {
  this->gatewayId = val;
}

uint32_t Parser::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_id = false;
  bool isset_imageName = false;
  bool isset_outputDirPath = false;
  bool isset_inputDirPath = false;
  bool isset_executionCommand = false;
  bool isset_inputFiles = false;
  bool isset_outputFiles = false;
  bool isset_gatewayId = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->id);
          isset_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->imageName);
          isset_imageName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->outputDirPath);
          isset_outputDirPath = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->inputDirPath);
          isset_inputDirPath = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->executionCommand);
          isset_executionCommand = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->inputFiles.clear();
            uint32_t _size6;
            ::apache::thrift::protocol::TType _etype9;
            xfer += iprot->readListBegin(_etype9, _size6);
            this->inputFiles.resize(_size6);
            uint32_t _i10;
            for (_i10 = 0; _i10 < _size6; ++_i10)
            {
              xfer += this->inputFiles[_i10].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_inputFiles = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->outputFiles.clear();
            uint32_t _size11;
            ::apache::thrift::protocol::TType _etype14;
            xfer += iprot->readListBegin(_etype14, _size11);
            this->outputFiles.resize(_size11);
            uint32_t _i15;
            for (_i15 = 0; _i15 < _size11; ++_i15)
            {
              xfer += this->outputFiles[_i15].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_outputFiles = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->gatewayId);
          isset_gatewayId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_id)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_imageName)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_outputDirPath)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_inputDirPath)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_executionCommand)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_inputFiles)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_outputFiles)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_gatewayId)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t Parser::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Parser");

  xfer += oprot->writeFieldBegin("id", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("imageName", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->imageName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("outputDirPath", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->outputDirPath);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("inputDirPath", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString(this->inputDirPath);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("executionCommand", ::apache::thrift::protocol::T_STRING, 5);
  xfer += oprot->writeString(this->executionCommand);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("inputFiles", ::apache::thrift::protocol::T_LIST, 6);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->inputFiles.size()));
    std::vector<ParserInput> ::const_iterator _iter16;
    for (_iter16 = this->inputFiles.begin(); _iter16 != this->inputFiles.end(); ++_iter16)
    {
      xfer += (*_iter16).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("outputFiles", ::apache::thrift::protocol::T_LIST, 7);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->outputFiles.size()));
    std::vector<ParserOutput> ::const_iterator _iter17;
    for (_iter17 = this->outputFiles.begin(); _iter17 != this->outputFiles.end(); ++_iter17)
    {
      xfer += (*_iter17).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("gatewayId", ::apache::thrift::protocol::T_STRING, 8);
  xfer += oprot->writeString(this->gatewayId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Parser &a, Parser &b) {
  using ::std::swap;
  swap(a.id, b.id);
  swap(a.imageName, b.imageName);
  swap(a.outputDirPath, b.outputDirPath);
  swap(a.inputDirPath, b.inputDirPath);
  swap(a.executionCommand, b.executionCommand);
  swap(a.inputFiles, b.inputFiles);
  swap(a.outputFiles, b.outputFiles);
  swap(a.gatewayId, b.gatewayId);
}

Parser::Parser(const Parser& other18) {
  id = other18.id;
  imageName = other18.imageName;
  outputDirPath = other18.outputDirPath;
  inputDirPath = other18.inputDirPath;
  executionCommand = other18.executionCommand;
  inputFiles = other18.inputFiles;
  outputFiles = other18.outputFiles;
  gatewayId = other18.gatewayId;
}
Parser& Parser::operator=(const Parser& other19) {
  id = other19.id;
  imageName = other19.imageName;
  outputDirPath = other19.outputDirPath;
  inputDirPath = other19.inputDirPath;
  executionCommand = other19.executionCommand;
  inputFiles = other19.inputFiles;
  outputFiles = other19.outputFiles;
  gatewayId = other19.gatewayId;
  return *this;
}
void Parser::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "Parser(";
  out << "id=" << to_string(id);
  out << ", " << "imageName=" << to_string(imageName);
  out << ", " << "outputDirPath=" << to_string(outputDirPath);
  out << ", " << "inputDirPath=" << to_string(inputDirPath);
  out << ", " << "executionCommand=" << to_string(executionCommand);
  out << ", " << "inputFiles=" << to_string(inputFiles);
  out << ", " << "outputFiles=" << to_string(outputFiles);
  out << ", " << "gatewayId=" << to_string(gatewayId);
  out << ")";
}


ParserConnectorInput::~ParserConnectorInput() throw() {
}


void ParserConnectorInput::__set_id(const std::string& val) {
  this->id = val;
}

void ParserConnectorInput::__set_inputId(const std::string& val) {
  this->inputId = val;
}

void ParserConnectorInput::__set_parentOutputId(const std::string& val) {
  this->parentOutputId = val;
}

void ParserConnectorInput::__set_value(const std::string& val) {
  this->value = val;
}

void ParserConnectorInput::__set_parserConnectorId(const std::string& val) {
  this->parserConnectorId = val;
}

uint32_t ParserConnectorInput::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_id = false;
  bool isset_inputId = false;
  bool isset_parserConnectorId = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->id);
          isset_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->inputId);
          isset_inputId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->parentOutputId);
          this->__isset.parentOutputId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->value);
          this->__isset.value = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->parserConnectorId);
          isset_parserConnectorId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_id)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_inputId)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_parserConnectorId)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t ParserConnectorInput::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ParserConnectorInput");

  xfer += oprot->writeFieldBegin("id", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("inputId", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->inputId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("parentOutputId", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->parentOutputId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("value", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString(this->value);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("parserConnectorId", ::apache::thrift::protocol::T_STRING, 5);
  xfer += oprot->writeString(this->parserConnectorId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ParserConnectorInput &a, ParserConnectorInput &b) {
  using ::std::swap;
  swap(a.id, b.id);
  swap(a.inputId, b.inputId);
  swap(a.parentOutputId, b.parentOutputId);
  swap(a.value, b.value);
  swap(a.parserConnectorId, b.parserConnectorId);
  swap(a.__isset, b.__isset);
}

ParserConnectorInput::ParserConnectorInput(const ParserConnectorInput& other20) {
  id = other20.id;
  inputId = other20.inputId;
  parentOutputId = other20.parentOutputId;
  value = other20.value;
  parserConnectorId = other20.parserConnectorId;
  __isset = other20.__isset;
}
ParserConnectorInput& ParserConnectorInput::operator=(const ParserConnectorInput& other21) {
  id = other21.id;
  inputId = other21.inputId;
  parentOutputId = other21.parentOutputId;
  value = other21.value;
  parserConnectorId = other21.parserConnectorId;
  __isset = other21.__isset;
  return *this;
}
void ParserConnectorInput::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "ParserConnectorInput(";
  out << "id=" << to_string(id);
  out << ", " << "inputId=" << to_string(inputId);
  out << ", " << "parentOutputId=" << to_string(parentOutputId);
  out << ", " << "value=" << to_string(value);
  out << ", " << "parserConnectorId=" << to_string(parserConnectorId);
  out << ")";
}


ParserConnector::~ParserConnector() throw() {
}


void ParserConnector::__set_id(const std::string& val) {
  this->id = val;
}

void ParserConnector::__set_parentParserId(const std::string& val) {
  this->parentParserId = val;
}

void ParserConnector::__set_childParserId(const std::string& val) {
  this->childParserId = val;
}

void ParserConnector::__set_connectorInputs(const std::vector<ParserConnectorInput> & val) {
  this->connectorInputs = val;
}

void ParserConnector::__set_parsingTemplateId(const std::string& val) {
  this->parsingTemplateId = val;
}

uint32_t ParserConnector::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_id = false;
  bool isset_parentParserId = false;
  bool isset_childParserId = false;
  bool isset_connectorInputs = false;
  bool isset_parsingTemplateId = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->id);
          isset_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->parentParserId);
          isset_parentParserId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->childParserId);
          isset_childParserId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->connectorInputs.clear();
            uint32_t _size22;
            ::apache::thrift::protocol::TType _etype25;
            xfer += iprot->readListBegin(_etype25, _size22);
            this->connectorInputs.resize(_size22);
            uint32_t _i26;
            for (_i26 = 0; _i26 < _size22; ++_i26)
            {
              xfer += this->connectorInputs[_i26].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_connectorInputs = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->parsingTemplateId);
          isset_parsingTemplateId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_id)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_parentParserId)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_childParserId)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_connectorInputs)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_parsingTemplateId)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t ParserConnector::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ParserConnector");

  xfer += oprot->writeFieldBegin("id", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("parentParserId", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->parentParserId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("childParserId", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->childParserId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("connectorInputs", ::apache::thrift::protocol::T_LIST, 4);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->connectorInputs.size()));
    std::vector<ParserConnectorInput> ::const_iterator _iter27;
    for (_iter27 = this->connectorInputs.begin(); _iter27 != this->connectorInputs.end(); ++_iter27)
    {
      xfer += (*_iter27).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("parsingTemplateId", ::apache::thrift::protocol::T_STRING, 5);
  xfer += oprot->writeString(this->parsingTemplateId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ParserConnector &a, ParserConnector &b) {
  using ::std::swap;
  swap(a.id, b.id);
  swap(a.parentParserId, b.parentParserId);
  swap(a.childParserId, b.childParserId);
  swap(a.connectorInputs, b.connectorInputs);
  swap(a.parsingTemplateId, b.parsingTemplateId);
}

ParserConnector::ParserConnector(const ParserConnector& other28) {
  id = other28.id;
  parentParserId = other28.parentParserId;
  childParserId = other28.childParserId;
  connectorInputs = other28.connectorInputs;
  parsingTemplateId = other28.parsingTemplateId;
}
ParserConnector& ParserConnector::operator=(const ParserConnector& other29) {
  id = other29.id;
  parentParserId = other29.parentParserId;
  childParserId = other29.childParserId;
  connectorInputs = other29.connectorInputs;
  parsingTemplateId = other29.parsingTemplateId;
  return *this;
}
void ParserConnector::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "ParserConnector(";
  out << "id=" << to_string(id);
  out << ", " << "parentParserId=" << to_string(parentParserId);
  out << ", " << "childParserId=" << to_string(childParserId);
  out << ", " << "connectorInputs=" << to_string(connectorInputs);
  out << ", " << "parsingTemplateId=" << to_string(parsingTemplateId);
  out << ")";
}


ParsingTemplateInput::~ParsingTemplateInput() throw() {
}


void ParsingTemplateInput::__set_id(const std::string& val) {
  this->id = val;
}

void ParsingTemplateInput::__set_targetInputId(const std::string& val) {
  this->targetInputId = val;
}

void ParsingTemplateInput::__set_applicationOutputName(const std::string& val) {
  this->applicationOutputName = val;
}

void ParsingTemplateInput::__set_value(const std::string& val) {
  this->value = val;
}

void ParsingTemplateInput::__set_parsingTemplateId(const std::string& val) {
  this->parsingTemplateId = val;
}

uint32_t ParsingTemplateInput::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_id = false;
  bool isset_targetInputId = false;
  bool isset_parsingTemplateId = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->id);
          isset_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->targetInputId);
          isset_targetInputId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->applicationOutputName);
          this->__isset.applicationOutputName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->value);
          this->__isset.value = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->parsingTemplateId);
          isset_parsingTemplateId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_id)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_targetInputId)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_parsingTemplateId)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t ParsingTemplateInput::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ParsingTemplateInput");

  xfer += oprot->writeFieldBegin("id", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("targetInputId", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->targetInputId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("applicationOutputName", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->applicationOutputName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("value", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString(this->value);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("parsingTemplateId", ::apache::thrift::protocol::T_STRING, 5);
  xfer += oprot->writeString(this->parsingTemplateId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ParsingTemplateInput &a, ParsingTemplateInput &b) {
  using ::std::swap;
  swap(a.id, b.id);
  swap(a.targetInputId, b.targetInputId);
  swap(a.applicationOutputName, b.applicationOutputName);
  swap(a.value, b.value);
  swap(a.parsingTemplateId, b.parsingTemplateId);
  swap(a.__isset, b.__isset);
}

ParsingTemplateInput::ParsingTemplateInput(const ParsingTemplateInput& other30) {
  id = other30.id;
  targetInputId = other30.targetInputId;
  applicationOutputName = other30.applicationOutputName;
  value = other30.value;
  parsingTemplateId = other30.parsingTemplateId;
  __isset = other30.__isset;
}
ParsingTemplateInput& ParsingTemplateInput::operator=(const ParsingTemplateInput& other31) {
  id = other31.id;
  targetInputId = other31.targetInputId;
  applicationOutputName = other31.applicationOutputName;
  value = other31.value;
  parsingTemplateId = other31.parsingTemplateId;
  __isset = other31.__isset;
  return *this;
}
void ParsingTemplateInput::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "ParsingTemplateInput(";
  out << "id=" << to_string(id);
  out << ", " << "targetInputId=" << to_string(targetInputId);
  out << ", " << "applicationOutputName=" << to_string(applicationOutputName);
  out << ", " << "value=" << to_string(value);
  out << ", " << "parsingTemplateId=" << to_string(parsingTemplateId);
  out << ")";
}


ParsingTemplate::~ParsingTemplate() throw() {
}


void ParsingTemplate::__set_id(const std::string& val) {
  this->id = val;
}

void ParsingTemplate::__set_applicationInterface(const std::string& val) {
  this->applicationInterface = val;
}

void ParsingTemplate::__set_initialInputs(const std::vector<ParsingTemplateInput> & val) {
  this->initialInputs = val;
}

void ParsingTemplate::__set_parserConnections(const std::vector<ParserConnector> & val) {
  this->parserConnections = val;
}

void ParsingTemplate::__set_gatewayId(const std::string& val) {
  this->gatewayId = val;
}

uint32_t ParsingTemplate::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_id = false;
  bool isset_applicationInterface = false;
  bool isset_initialInputs = false;
  bool isset_parserConnections = false;
  bool isset_gatewayId = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->id);
          isset_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->applicationInterface);
          isset_applicationInterface = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->initialInputs.clear();
            uint32_t _size32;
            ::apache::thrift::protocol::TType _etype35;
            xfer += iprot->readListBegin(_etype35, _size32);
            this->initialInputs.resize(_size32);
            uint32_t _i36;
            for (_i36 = 0; _i36 < _size32; ++_i36)
            {
              xfer += this->initialInputs[_i36].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_initialInputs = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->parserConnections.clear();
            uint32_t _size37;
            ::apache::thrift::protocol::TType _etype40;
            xfer += iprot->readListBegin(_etype40, _size37);
            this->parserConnections.resize(_size37);
            uint32_t _i41;
            for (_i41 = 0; _i41 < _size37; ++_i41)
            {
              xfer += this->parserConnections[_i41].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_parserConnections = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->gatewayId);
          isset_gatewayId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_id)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_applicationInterface)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_initialInputs)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_parserConnections)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_gatewayId)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t ParsingTemplate::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ParsingTemplate");

  xfer += oprot->writeFieldBegin("id", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("applicationInterface", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->applicationInterface);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("initialInputs", ::apache::thrift::protocol::T_LIST, 3);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->initialInputs.size()));
    std::vector<ParsingTemplateInput> ::const_iterator _iter42;
    for (_iter42 = this->initialInputs.begin(); _iter42 != this->initialInputs.end(); ++_iter42)
    {
      xfer += (*_iter42).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("parserConnections", ::apache::thrift::protocol::T_LIST, 4);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->parserConnections.size()));
    std::vector<ParserConnector> ::const_iterator _iter43;
    for (_iter43 = this->parserConnections.begin(); _iter43 != this->parserConnections.end(); ++_iter43)
    {
      xfer += (*_iter43).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("gatewayId", ::apache::thrift::protocol::T_STRING, 5);
  xfer += oprot->writeString(this->gatewayId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ParsingTemplate &a, ParsingTemplate &b) {
  using ::std::swap;
  swap(a.id, b.id);
  swap(a.applicationInterface, b.applicationInterface);
  swap(a.initialInputs, b.initialInputs);
  swap(a.parserConnections, b.parserConnections);
  swap(a.gatewayId, b.gatewayId);
}

ParsingTemplate::ParsingTemplate(const ParsingTemplate& other44) {
  id = other44.id;
  applicationInterface = other44.applicationInterface;
  initialInputs = other44.initialInputs;
  parserConnections = other44.parserConnections;
  gatewayId = other44.gatewayId;
}
ParsingTemplate& ParsingTemplate::operator=(const ParsingTemplate& other45) {
  id = other45.id;
  applicationInterface = other45.applicationInterface;
  initialInputs = other45.initialInputs;
  parserConnections = other45.parserConnections;
  gatewayId = other45.gatewayId;
  return *this;
}
void ParsingTemplate::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "ParsingTemplate(";
  out << "id=" << to_string(id);
  out << ", " << "applicationInterface=" << to_string(applicationInterface);
  out << ", " << "initialInputs=" << to_string(initialInputs);
  out << ", " << "parserConnections=" << to_string(parserConnections);
  out << ", " << "gatewayId=" << to_string(gatewayId);
  out << ")";
}

}}}}} // namespace
