/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Autogenerated by Thrift Compiler (0.9.3)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#ifndef workspace_model_TYPES_H
#define workspace_model_TYPES_H

#include <iosfwd>

#include <thrift/Thrift.h>
#include <thrift/TApplicationException.h>
#include <thrift/protocol/TProtocol.h>
#include <thrift/transport/TTransport.h>

#include <thrift/cxxfunctional.h>
#include "airavata_commons_types.h"


namespace apache { namespace airavata { namespace model { namespace workspace {

class Group;

class Project;

class User;

class Gateway;

typedef struct _Group__isset {
  _Group__isset() : description(false) {}
  bool description :1;
} _Group__isset;

class Group {
 public:

  Group(const Group&);
  Group& operator=(const Group&);
  Group() : groupName(), description() {
  }

  virtual ~Group() throw();
  std::string groupName;
  std::string description;

  _Group__isset __isset;

  void __set_groupName(const std::string& val);

  void __set_description(const std::string& val);

  bool operator == (const Group & rhs) const
  {
    if (!(groupName == rhs.groupName))
      return false;
    if (__isset.description != rhs.__isset.description)
      return false;
    else if (__isset.description && !(description == rhs.description))
      return false;
    return true;
  }
  bool operator != (const Group &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Group & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(Group &a, Group &b);

inline std::ostream& operator<<(std::ostream& out, const Group& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _Project__isset {
  _Project__isset() : description(false), creationTime(false), sharedUsers(false), sharedGroups(false) {}
  bool description :1;
  bool creationTime :1;
  bool sharedUsers :1;
  bool sharedGroups :1;
} _Project__isset;

class Project {
 public:

  Project(const Project&);
  Project& operator=(const Project&);
  Project() : projectID("DO_NOT_SET_AT_CLIENTS"), owner(), name(), description(), creationTime(0) {
  }

  virtual ~Project() throw();
  std::string projectID;
  std::string owner;
  std::string name;
  std::string description;
  int64_t creationTime;
  std::vector<std::string>  sharedUsers;
  std::vector<std::string>  sharedGroups;

  _Project__isset __isset;

  void __set_projectID(const std::string& val);

  void __set_owner(const std::string& val);

  void __set_name(const std::string& val);

  void __set_description(const std::string& val);

  void __set_creationTime(const int64_t val);

  void __set_sharedUsers(const std::vector<std::string> & val);

  void __set_sharedGroups(const std::vector<std::string> & val);

  bool operator == (const Project & rhs) const
  {
    if (!(projectID == rhs.projectID))
      return false;
    if (!(owner == rhs.owner))
      return false;
    if (!(name == rhs.name))
      return false;
    if (__isset.description != rhs.__isset.description)
      return false;
    else if (__isset.description && !(description == rhs.description))
      return false;
    if (__isset.creationTime != rhs.__isset.creationTime)
      return false;
    else if (__isset.creationTime && !(creationTime == rhs.creationTime))
      return false;
    if (__isset.sharedUsers != rhs.__isset.sharedUsers)
      return false;
    else if (__isset.sharedUsers && !(sharedUsers == rhs.sharedUsers))
      return false;
    if (__isset.sharedGroups != rhs.__isset.sharedGroups)
      return false;
    else if (__isset.sharedGroups && !(sharedGroups == rhs.sharedGroups))
      return false;
    return true;
  }
  bool operator != (const Project &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Project & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(Project &a, Project &b);

inline std::ostream& operator<<(std::ostream& out, const Project& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _User__isset {
  _User__isset() : groupList(false) {}
  bool groupList :1;
} _User__isset;

class User {
 public:

  User(const User&);
  User& operator=(const User&);
  User() : userName() {
  }

  virtual ~User() throw();
  std::string userName;
  std::vector<Group>  groupList;

  _User__isset __isset;

  void __set_userName(const std::string& val);

  void __set_groupList(const std::vector<Group> & val);

  bool operator == (const User & rhs) const
  {
    if (!(userName == rhs.userName))
      return false;
    if (__isset.groupList != rhs.__isset.groupList)
      return false;
    else if (__isset.groupList && !(groupList == rhs.groupList))
      return false;
    return true;
  }
  bool operator != (const User &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const User & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(User &a, User &b);

inline std::ostream& operator<<(std::ostream& out, const User& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _Gateway__isset {
  _Gateway__isset() : gatewayName(false), domain(false), emailAddress(false) {}
  bool gatewayName :1;
  bool domain :1;
  bool emailAddress :1;
} _Gateway__isset;

class Gateway {
 public:

  Gateway(const Gateway&);
  Gateway& operator=(const Gateway&);
  Gateway() : gatewayId(), gatewayName(), domain(), emailAddress() {
  }

  virtual ~Gateway() throw();
  std::string gatewayId;
  std::string gatewayName;
  std::string domain;
  std::string emailAddress;

  _Gateway__isset __isset;

  void __set_gatewayId(const std::string& val);

  void __set_gatewayName(const std::string& val);

  void __set_domain(const std::string& val);

  void __set_emailAddress(const std::string& val);

  bool operator == (const Gateway & rhs) const
  {
    if (!(gatewayId == rhs.gatewayId))
      return false;
    if (__isset.gatewayName != rhs.__isset.gatewayName)
      return false;
    else if (__isset.gatewayName && !(gatewayName == rhs.gatewayName))
      return false;
    if (__isset.domain != rhs.__isset.domain)
      return false;
    else if (__isset.domain && !(domain == rhs.domain))
      return false;
    if (__isset.emailAddress != rhs.__isset.emailAddress)
      return false;
    else if (__isset.emailAddress && !(emailAddress == rhs.emailAddress))
      return false;
    return true;
  }
  bool operator != (const Gateway &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Gateway & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(Gateway &a, Gateway &b);

inline std::ostream& operator<<(std::ostream& out, const Gateway& obj)
{
  obj.printTo(out);
  return out;
}

}}}} // namespace

#endif
