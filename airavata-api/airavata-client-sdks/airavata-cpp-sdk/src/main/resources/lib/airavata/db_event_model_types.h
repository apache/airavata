/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Autogenerated by Thrift Compiler (0.10.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#ifndef db_event_model_TYPES_H
#define db_event_model_TYPES_H

#include <iosfwd>

#include <thrift/Thrift.h>
#include <thrift/TApplicationException.h>
#include <thrift/TBase.h>
#include <thrift/protocol/TProtocol.h>
#include <thrift/transport/TTransport.h>

#include <thrift/cxxfunctional.h>




struct CrudType {
  enum type {
    CREATE = 0,
    READ = 1,
    UPDATE = 2,
    DELETE = 3
  };
};

extern const std::map<int, const char*> _CrudType_VALUES_TO_NAMES;

struct EntityType {
  enum type {
    USER_PROFILE = 0,
    TENANT = 1,
    GROUP = 2,
    PROJECT = 3,
    EXPERIMENT = 4,
    APPLICATION = 5,
    SHARING = 6,
    REGISTRY = 7
  };
};

extern const std::map<int, const char*> _EntityType_VALUES_TO_NAMES;

struct DBEventType {
  enum type {
    PUBLISHER = 0,
    SUBSCRIBER = 1
  };
};

extern const std::map<int, const char*> _DBEventType_VALUES_TO_NAMES;

class DBEventPublisherContext;

class DBEventPublisher;

class DBEventSubscriber;

class DBEventMessageContext;

class DBEventMessage;


class DBEventPublisherContext : public virtual ::apache::thrift::TBase {
 public:

  DBEventPublisherContext(const DBEventPublisherContext&);
  DBEventPublisherContext& operator=(const DBEventPublisherContext&);
  DBEventPublisherContext() : crudType((CrudType::type)0), entityType((EntityType::type)0), entityDataModel() {
  }

  virtual ~DBEventPublisherContext() throw();
  CrudType::type crudType;
  EntityType::type entityType;
  std::string entityDataModel;

  void __set_crudType(const CrudType::type val);

  void __set_entityType(const EntityType::type val);

  void __set_entityDataModel(const std::string& val);

  bool operator == (const DBEventPublisherContext & rhs) const
  {
    if (!(crudType == rhs.crudType))
      return false;
    if (!(entityType == rhs.entityType))
      return false;
    if (!(entityDataModel == rhs.entityDataModel))
      return false;
    return true;
  }
  bool operator != (const DBEventPublisherContext &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const DBEventPublisherContext & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(DBEventPublisherContext &a, DBEventPublisherContext &b);

inline std::ostream& operator<<(std::ostream& out, const DBEventPublisherContext& obj)
{
  obj.printTo(out);
  return out;
}


class DBEventPublisher : public virtual ::apache::thrift::TBase {
 public:

  DBEventPublisher(const DBEventPublisher&);
  DBEventPublisher& operator=(const DBEventPublisher&);
  DBEventPublisher() {
  }

  virtual ~DBEventPublisher() throw();
  DBEventPublisherContext publisherContext;

  void __set_publisherContext(const DBEventPublisherContext& val);

  bool operator == (const DBEventPublisher & rhs) const
  {
    if (!(publisherContext == rhs.publisherContext))
      return false;
    return true;
  }
  bool operator != (const DBEventPublisher &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const DBEventPublisher & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(DBEventPublisher &a, DBEventPublisher &b);

inline std::ostream& operator<<(std::ostream& out, const DBEventPublisher& obj)
{
  obj.printTo(out);
  return out;
}


class DBEventSubscriber : public virtual ::apache::thrift::TBase {
 public:

  DBEventSubscriber(const DBEventSubscriber&);
  DBEventSubscriber& operator=(const DBEventSubscriber&);
  DBEventSubscriber() : subscriberService() {
  }

  virtual ~DBEventSubscriber() throw();
  std::string subscriberService;

  void __set_subscriberService(const std::string& val);

  bool operator == (const DBEventSubscriber & rhs) const
  {
    if (!(subscriberService == rhs.subscriberService))
      return false;
    return true;
  }
  bool operator != (const DBEventSubscriber &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const DBEventSubscriber & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(DBEventSubscriber &a, DBEventSubscriber &b);

inline std::ostream& operator<<(std::ostream& out, const DBEventSubscriber& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _DBEventMessageContext__isset {
  _DBEventMessageContext__isset() : publisher(false), subscriber(false) {}
  bool publisher :1;
  bool subscriber :1;
} _DBEventMessageContext__isset;

class DBEventMessageContext : public virtual ::apache::thrift::TBase {
 public:

  DBEventMessageContext(const DBEventMessageContext&);
  DBEventMessageContext& operator=(const DBEventMessageContext&);
  DBEventMessageContext() {
  }

  virtual ~DBEventMessageContext() throw();
  DBEventPublisher publisher;
  DBEventSubscriber subscriber;

  _DBEventMessageContext__isset __isset;

  void __set_publisher(const DBEventPublisher& val);

  void __set_subscriber(const DBEventSubscriber& val);

  bool operator == (const DBEventMessageContext & rhs) const
  {
    if (__isset.publisher != rhs.__isset.publisher)
      return false;
    else if (__isset.publisher && !(publisher == rhs.publisher))
      return false;
    if (__isset.subscriber != rhs.__isset.subscriber)
      return false;
    else if (__isset.subscriber && !(subscriber == rhs.subscriber))
      return false;
    return true;
  }
  bool operator != (const DBEventMessageContext &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const DBEventMessageContext & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(DBEventMessageContext &a, DBEventMessageContext &b);

inline std::ostream& operator<<(std::ostream& out, const DBEventMessageContext& obj)
{
  obj.printTo(out);
  return out;
}


class DBEventMessage : public virtual ::apache::thrift::TBase {
 public:

  DBEventMessage(const DBEventMessage&);
  DBEventMessage& operator=(const DBEventMessage&);
  DBEventMessage() : dbEventType((DBEventType::type)0), publisherService() {
  }

  virtual ~DBEventMessage() throw();
  DBEventType::type dbEventType;
  DBEventMessageContext messageContext;
  std::string publisherService;

  void __set_dbEventType(const DBEventType::type val);

  void __set_messageContext(const DBEventMessageContext& val);

  void __set_publisherService(const std::string& val);

  bool operator == (const DBEventMessage & rhs) const
  {
    if (!(dbEventType == rhs.dbEventType))
      return false;
    if (!(messageContext == rhs.messageContext))
      return false;
    if (!(publisherService == rhs.publisherService))
      return false;
    return true;
  }
  bool operator != (const DBEventMessage &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const DBEventMessage & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(DBEventMessage &a, DBEventMessage &b);

inline std::ostream& operator<<(std::ostream& out, const DBEventMessage& obj)
{
  obj.printTo(out);
  return out;
}



#endif
