/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Autogenerated by Thrift Compiler (0.9.2)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#include "task_model_types.h"

#include <algorithm>
#include <ostream>

#include <thrift/TToString.h>

namespace apache { namespace airavata { namespace model { namespace task {

int _kTaskTypesValues[] = {
  TaskTypes::ENV_SETUP,
  TaskTypes::DATA_STAGING,
  TaskTypes::JOB_SUBMISSION,
  TaskTypes::ENV_CLEANUP,
  TaskTypes::MONITORING
};
const char* _kTaskTypesNames[] = {
  "ENV_SETUP",
  "DATA_STAGING",
  "JOB_SUBMISSION",
  "ENV_CLEANUP",
  "MONITORING"
};
const std::map<int, const char*> _TaskTypes_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(5, _kTaskTypesValues, _kTaskTypesNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kDataStageTypeValues[] = {
  DataStageType::INPUT,
  DataStageType::OUPUT
};
const char* _kDataStageTypeNames[] = {
  "INPUT",
  "OUPUT"
};
const std::map<int, const char*> _DataStageType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(2, _kDataStageTypeValues, _kDataStageTypeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));


TaskModel::~TaskModel() throw() {
}


void TaskModel::__set_taskId(const std::string& val) {
  this->taskId = val;
}

void TaskModel::__set_taskType(const TaskTypes::type val) {
  this->taskType = val;
}

void TaskModel::__set_parentProcessId(const std::string& val) {
  this->parentProcessId = val;
}

void TaskModel::__set_creationTime(const int64_t val) {
  this->creationTime = val;
}

void TaskModel::__set_lastUpdateTime(const int64_t val) {
  this->lastUpdateTime = val;
}

void TaskModel::__set_taskStatus(const  ::apache::airavata::model::status::TaskStatus& val) {
  this->taskStatus = val;
}

void TaskModel::__set_taskDetail(const std::string& val) {
  this->taskDetail = val;
__isset.taskDetail = true;
}

void TaskModel::__set_subTaskModel(const std::string& val) {
  this->subTaskModel = val;
__isset.subTaskModel = true;
}

void TaskModel::__set_taskError(const  ::apache::airavata::model::commons::ErrorModel& val) {
  this->taskError = val;
__isset.taskError = true;
}

void TaskModel::__set_jobs(const std::vector< ::apache::airavata::model::job::JobModel> & val) {
  this->jobs = val;
__isset.jobs = true;
}

const char* TaskModel::ascii_fingerprint = "BA52131C9C867CBF7281F29EDD7DDB6F";
const uint8_t TaskModel::binary_fingerprint[16] = {0xBA,0x52,0x13,0x1C,0x9C,0x86,0x7C,0xBF,0x72,0x81,0xF2,0x9E,0xDD,0x7D,0xDB,0x6F};

uint32_t TaskModel::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_taskId = false;
  bool isset_taskType = false;
  bool isset_parentProcessId = false;
  bool isset_creationTime = false;
  bool isset_lastUpdateTime = false;
  bool isset_taskStatus = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->taskId);
          isset_taskId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast0;
          xfer += iprot->readI32(ecast0);
          this->taskType = (TaskTypes::type)ecast0;
          isset_taskType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->parentProcessId);
          isset_parentProcessId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->creationTime);
          isset_creationTime = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->lastUpdateTime);
          isset_lastUpdateTime = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->taskStatus.read(iprot);
          isset_taskStatus = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->taskDetail);
          this->__isset.taskDetail = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->subTaskModel);
          this->__isset.subTaskModel = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->taskError.read(iprot);
          this->__isset.taskError = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->jobs.clear();
            uint32_t _size1;
            ::apache::thrift::protocol::TType _etype4;
            xfer += iprot->readListBegin(_etype4, _size1);
            this->jobs.resize(_size1);
            uint32_t _i5;
            for (_i5 = 0; _i5 < _size1; ++_i5)
            {
              xfer += this->jobs[_i5].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.jobs = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_taskId)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_taskType)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_parentProcessId)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_creationTime)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_lastUpdateTime)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_taskStatus)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TaskModel::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  oprot->incrementRecursionDepth();
  xfer += oprot->writeStructBegin("TaskModel");

  xfer += oprot->writeFieldBegin("taskId", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->taskId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("taskType", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32((int32_t)this->taskType);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("parentProcessId", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->parentProcessId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("creationTime", ::apache::thrift::protocol::T_I64, 4);
  xfer += oprot->writeI64(this->creationTime);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("lastUpdateTime", ::apache::thrift::protocol::T_I64, 5);
  xfer += oprot->writeI64(this->lastUpdateTime);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("taskStatus", ::apache::thrift::protocol::T_STRUCT, 6);
  xfer += this->taskStatus.write(oprot);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.taskDetail) {
    xfer += oprot->writeFieldBegin("taskDetail", ::apache::thrift::protocol::T_STRING, 7);
    xfer += oprot->writeString(this->taskDetail);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.subTaskModel) {
    xfer += oprot->writeFieldBegin("subTaskModel", ::apache::thrift::protocol::T_STRING, 8);
    xfer += oprot->writeBinary(this->subTaskModel);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.taskError) {
    xfer += oprot->writeFieldBegin("taskError", ::apache::thrift::protocol::T_STRUCT, 9);
    xfer += this->taskError.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.jobs) {
    xfer += oprot->writeFieldBegin("jobs", ::apache::thrift::protocol::T_LIST, 10);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->jobs.size()));
      std::vector< ::apache::airavata::model::job::JobModel> ::const_iterator _iter6;
      for (_iter6 = this->jobs.begin(); _iter6 != this->jobs.end(); ++_iter6)
      {
        xfer += (*_iter6).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  oprot->decrementRecursionDepth();
  return xfer;
}

void swap(TaskModel &a, TaskModel &b) {
  using ::std::swap;
  swap(a.taskId, b.taskId);
  swap(a.taskType, b.taskType);
  swap(a.parentProcessId, b.parentProcessId);
  swap(a.creationTime, b.creationTime);
  swap(a.lastUpdateTime, b.lastUpdateTime);
  swap(a.taskStatus, b.taskStatus);
  swap(a.taskDetail, b.taskDetail);
  swap(a.subTaskModel, b.subTaskModel);
  swap(a.taskError, b.taskError);
  swap(a.jobs, b.jobs);
  swap(a.__isset, b.__isset);
}

TaskModel::TaskModel(const TaskModel& other7) {
  taskId = other7.taskId;
  taskType = other7.taskType;
  parentProcessId = other7.parentProcessId;
  creationTime = other7.creationTime;
  lastUpdateTime = other7.lastUpdateTime;
  taskStatus = other7.taskStatus;
  taskDetail = other7.taskDetail;
  subTaskModel = other7.subTaskModel;
  taskError = other7.taskError;
  jobs = other7.jobs;
  __isset = other7.__isset;
}
TaskModel& TaskModel::operator=(const TaskModel& other8) {
  taskId = other8.taskId;
  taskType = other8.taskType;
  parentProcessId = other8.parentProcessId;
  creationTime = other8.creationTime;
  lastUpdateTime = other8.lastUpdateTime;
  taskStatus = other8.taskStatus;
  taskDetail = other8.taskDetail;
  subTaskModel = other8.subTaskModel;
  taskError = other8.taskError;
  jobs = other8.jobs;
  __isset = other8.__isset;
  return *this;
}
std::ostream& operator<<(std::ostream& out, const TaskModel& obj) {
  using apache::thrift::to_string;
  out << "TaskModel(";
  out << "taskId=" << to_string(obj.taskId);
  out << ", " << "taskType=" << to_string(obj.taskType);
  out << ", " << "parentProcessId=" << to_string(obj.parentProcessId);
  out << ", " << "creationTime=" << to_string(obj.creationTime);
  out << ", " << "lastUpdateTime=" << to_string(obj.lastUpdateTime);
  out << ", " << "taskStatus=" << to_string(obj.taskStatus);
  out << ", " << "taskDetail="; (obj.__isset.taskDetail ? (out << to_string(obj.taskDetail)) : (out << "<null>"));
  out << ", " << "subTaskModel="; (obj.__isset.subTaskModel ? (out << to_string(obj.subTaskModel)) : (out << "<null>"));
  out << ", " << "taskError="; (obj.__isset.taskError ? (out << to_string(obj.taskError)) : (out << "<null>"));
  out << ", " << "jobs="; (obj.__isset.jobs ? (out << to_string(obj.jobs)) : (out << "<null>"));
  out << ")";
  return out;
}


DataStagingTaskModel::~DataStagingTaskModel() throw() {
}


void DataStagingTaskModel::__set_source(const std::string& val) {
  this->source = val;
}

void DataStagingTaskModel::__set_destination(const std::string& val) {
  this->destination = val;
}

void DataStagingTaskModel::__set_type(const DataStageType::type val) {
  this->type = val;
}

void DataStagingTaskModel::__set_transferStartTime(const int64_t val) {
  this->transferStartTime = val;
__isset.transferStartTime = true;
}

void DataStagingTaskModel::__set_transferEndTime(const int64_t val) {
  this->transferEndTime = val;
__isset.transferEndTime = true;
}

void DataStagingTaskModel::__set_transferRate(const std::string& val) {
  this->transferRate = val;
__isset.transferRate = true;
}

void DataStagingTaskModel::__set_processInput(const  ::apache::airavata::model::application::io::InputDataObjectType& val) {
  this->processInput = val;
__isset.processInput = true;
}

void DataStagingTaskModel::__set_processOutput(const  ::apache::airavata::model::application::io::OutputDataObjectType& val) {
  this->processOutput = val;
__isset.processOutput = true;
}

const char* DataStagingTaskModel::ascii_fingerprint = "ACF0A091382F299B453E77765150F8C9";
const uint8_t DataStagingTaskModel::binary_fingerprint[16] = {0xAC,0xF0,0xA0,0x91,0x38,0x2F,0x29,0x9B,0x45,0x3E,0x77,0x76,0x51,0x50,0xF8,0xC9};

uint32_t DataStagingTaskModel::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_source = false;
  bool isset_destination = false;
  bool isset_type = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->source);
          isset_source = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->destination);
          isset_destination = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast9;
          xfer += iprot->readI32(ecast9);
          this->type = (DataStageType::type)ecast9;
          isset_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->transferStartTime);
          this->__isset.transferStartTime = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->transferEndTime);
          this->__isset.transferEndTime = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->transferRate);
          this->__isset.transferRate = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->processInput.read(iprot);
          this->__isset.processInput = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->processOutput.read(iprot);
          this->__isset.processOutput = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_source)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_destination)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_type)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t DataStagingTaskModel::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  oprot->incrementRecursionDepth();
  xfer += oprot->writeStructBegin("DataStagingTaskModel");

  xfer += oprot->writeFieldBegin("source", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->source);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("destination", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->destination);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("type", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32((int32_t)this->type);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.transferStartTime) {
    xfer += oprot->writeFieldBegin("transferStartTime", ::apache::thrift::protocol::T_I64, 4);
    xfer += oprot->writeI64(this->transferStartTime);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.transferEndTime) {
    xfer += oprot->writeFieldBegin("transferEndTime", ::apache::thrift::protocol::T_I64, 5);
    xfer += oprot->writeI64(this->transferEndTime);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.transferRate) {
    xfer += oprot->writeFieldBegin("transferRate", ::apache::thrift::protocol::T_STRING, 6);
    xfer += oprot->writeString(this->transferRate);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.processInput) {
    xfer += oprot->writeFieldBegin("processInput", ::apache::thrift::protocol::T_STRUCT, 7);
    xfer += this->processInput.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.processOutput) {
    xfer += oprot->writeFieldBegin("processOutput", ::apache::thrift::protocol::T_STRUCT, 8);
    xfer += this->processOutput.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  oprot->decrementRecursionDepth();
  return xfer;
}

void swap(DataStagingTaskModel &a, DataStagingTaskModel &b) {
  using ::std::swap;
  swap(a.source, b.source);
  swap(a.destination, b.destination);
  swap(a.type, b.type);
  swap(a.transferStartTime, b.transferStartTime);
  swap(a.transferEndTime, b.transferEndTime);
  swap(a.transferRate, b.transferRate);
  swap(a.processInput, b.processInput);
  swap(a.processOutput, b.processOutput);
  swap(a.__isset, b.__isset);
}

DataStagingTaskModel::DataStagingTaskModel(const DataStagingTaskModel& other10) {
  source = other10.source;
  destination = other10.destination;
  type = other10.type;
  transferStartTime = other10.transferStartTime;
  transferEndTime = other10.transferEndTime;
  transferRate = other10.transferRate;
  processInput = other10.processInput;
  processOutput = other10.processOutput;
  __isset = other10.__isset;
}
DataStagingTaskModel& DataStagingTaskModel::operator=(const DataStagingTaskModel& other11) {
  source = other11.source;
  destination = other11.destination;
  type = other11.type;
  transferStartTime = other11.transferStartTime;
  transferEndTime = other11.transferEndTime;
  transferRate = other11.transferRate;
  processInput = other11.processInput;
  processOutput = other11.processOutput;
  __isset = other11.__isset;
  return *this;
}
std::ostream& operator<<(std::ostream& out, const DataStagingTaskModel& obj) {
  using apache::thrift::to_string;
  out << "DataStagingTaskModel(";
  out << "source=" << to_string(obj.source);
  out << ", " << "destination=" << to_string(obj.destination);
  out << ", " << "type=" << to_string(obj.type);
  out << ", " << "transferStartTime="; (obj.__isset.transferStartTime ? (out << to_string(obj.transferStartTime)) : (out << "<null>"));
  out << ", " << "transferEndTime="; (obj.__isset.transferEndTime ? (out << to_string(obj.transferEndTime)) : (out << "<null>"));
  out << ", " << "transferRate="; (obj.__isset.transferRate ? (out << to_string(obj.transferRate)) : (out << "<null>"));
  out << ", " << "processInput="; (obj.__isset.processInput ? (out << to_string(obj.processInput)) : (out << "<null>"));
  out << ", " << "processOutput="; (obj.__isset.processOutput ? (out << to_string(obj.processOutput)) : (out << "<null>"));
  out << ")";
  return out;
}


EnvironmentSetupTaskModel::~EnvironmentSetupTaskModel() throw() {
}


void EnvironmentSetupTaskModel::__set_location(const std::string& val) {
  this->location = val;
}

void EnvironmentSetupTaskModel::__set_protocol(const  ::apache::airavata::model::appcatalog::computeresource::SecurityProtocol::type val) {
  this->protocol = val;
}

const char* EnvironmentSetupTaskModel::ascii_fingerprint = "D6FD826D949221396F4FFC3ECCD3D192";
const uint8_t EnvironmentSetupTaskModel::binary_fingerprint[16] = {0xD6,0xFD,0x82,0x6D,0x94,0x92,0x21,0x39,0x6F,0x4F,0xFC,0x3E,0xCC,0xD3,0xD1,0x92};

uint32_t EnvironmentSetupTaskModel::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_location = false;
  bool isset_protocol = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->location);
          isset_location = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast12;
          xfer += iprot->readI32(ecast12);
          this->protocol = ( ::apache::airavata::model::appcatalog::computeresource::SecurityProtocol::type)ecast12;
          isset_protocol = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_location)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_protocol)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t EnvironmentSetupTaskModel::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  oprot->incrementRecursionDepth();
  xfer += oprot->writeStructBegin("EnvironmentSetupTaskModel");

  xfer += oprot->writeFieldBegin("location", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->location);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("protocol", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32((int32_t)this->protocol);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  oprot->decrementRecursionDepth();
  return xfer;
}

void swap(EnvironmentSetupTaskModel &a, EnvironmentSetupTaskModel &b) {
  using ::std::swap;
  swap(a.location, b.location);
  swap(a.protocol, b.protocol);
}

EnvironmentSetupTaskModel::EnvironmentSetupTaskModel(const EnvironmentSetupTaskModel& other13) {
  location = other13.location;
  protocol = other13.protocol;
}
EnvironmentSetupTaskModel& EnvironmentSetupTaskModel::operator=(const EnvironmentSetupTaskModel& other14) {
  location = other14.location;
  protocol = other14.protocol;
  return *this;
}
std::ostream& operator<<(std::ostream& out, const EnvironmentSetupTaskModel& obj) {
  using apache::thrift::to_string;
  out << "EnvironmentSetupTaskModel(";
  out << "location=" << to_string(obj.location);
  out << ", " << "protocol=" << to_string(obj.protocol);
  out << ")";
  return out;
}


JobSubmissionTaskModel::~JobSubmissionTaskModel() throw() {
}


void JobSubmissionTaskModel::__set_jobSubmissionProtocol(const  ::apache::airavata::model::appcatalog::computeresource::JobSubmissionProtocol::type val) {
  this->jobSubmissionProtocol = val;
}

void JobSubmissionTaskModel::__set_monitorMode(const  ::apache::airavata::model::appcatalog::computeresource::MonitorMode::type val) {
  this->monitorMode = val;
}

void JobSubmissionTaskModel::__set_wallTime(const int32_t val) {
  this->wallTime = val;
__isset.wallTime = true;
}

const char* JobSubmissionTaskModel::ascii_fingerprint = "AEF3E1D4E4ADDD8D31BD954A62F3809C";
const uint8_t JobSubmissionTaskModel::binary_fingerprint[16] = {0xAE,0xF3,0xE1,0xD4,0xE4,0xAD,0xDD,0x8D,0x31,0xBD,0x95,0x4A,0x62,0xF3,0x80,0x9C};

uint32_t JobSubmissionTaskModel::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_jobSubmissionProtocol = false;
  bool isset_monitorMode = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast15;
          xfer += iprot->readI32(ecast15);
          this->jobSubmissionProtocol = ( ::apache::airavata::model::appcatalog::computeresource::JobSubmissionProtocol::type)ecast15;
          isset_jobSubmissionProtocol = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast16;
          xfer += iprot->readI32(ecast16);
          this->monitorMode = ( ::apache::airavata::model::appcatalog::computeresource::MonitorMode::type)ecast16;
          isset_monitorMode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->wallTime);
          this->__isset.wallTime = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_jobSubmissionProtocol)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_monitorMode)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t JobSubmissionTaskModel::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  oprot->incrementRecursionDepth();
  xfer += oprot->writeStructBegin("JobSubmissionTaskModel");

  xfer += oprot->writeFieldBegin("jobSubmissionProtocol", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((int32_t)this->jobSubmissionProtocol);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("monitorMode", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32((int32_t)this->monitorMode);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.wallTime) {
    xfer += oprot->writeFieldBegin("wallTime", ::apache::thrift::protocol::T_I32, 3);
    xfer += oprot->writeI32(this->wallTime);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  oprot->decrementRecursionDepth();
  return xfer;
}

void swap(JobSubmissionTaskModel &a, JobSubmissionTaskModel &b) {
  using ::std::swap;
  swap(a.jobSubmissionProtocol, b.jobSubmissionProtocol);
  swap(a.monitorMode, b.monitorMode);
  swap(a.wallTime, b.wallTime);
  swap(a.__isset, b.__isset);
}

JobSubmissionTaskModel::JobSubmissionTaskModel(const JobSubmissionTaskModel& other17) {
  jobSubmissionProtocol = other17.jobSubmissionProtocol;
  monitorMode = other17.monitorMode;
  wallTime = other17.wallTime;
  __isset = other17.__isset;
}
JobSubmissionTaskModel& JobSubmissionTaskModel::operator=(const JobSubmissionTaskModel& other18) {
  jobSubmissionProtocol = other18.jobSubmissionProtocol;
  monitorMode = other18.monitorMode;
  wallTime = other18.wallTime;
  __isset = other18.__isset;
  return *this;
}
std::ostream& operator<<(std::ostream& out, const JobSubmissionTaskModel& obj) {
  using apache::thrift::to_string;
  out << "JobSubmissionTaskModel(";
  out << "jobSubmissionProtocol=" << to_string(obj.jobSubmissionProtocol);
  out << ", " << "monitorMode=" << to_string(obj.monitorMode);
  out << ", " << "wallTime="; (obj.__isset.wallTime ? (out << to_string(obj.wallTime)) : (out << "<null>"));
  out << ")";
  return out;
}


MonitorTaskModel::~MonitorTaskModel() throw() {
}


void MonitorTaskModel::__set_monitorMode(const  ::apache::airavata::model::appcatalog::computeresource::MonitorMode::type val) {
  this->monitorMode = val;
}

const char* MonitorTaskModel::ascii_fingerprint = "8BBB3D0C3B370CB38F2D1340BB79F0AA";
const uint8_t MonitorTaskModel::binary_fingerprint[16] = {0x8B,0xBB,0x3D,0x0C,0x3B,0x37,0x0C,0xB3,0x8F,0x2D,0x13,0x40,0xBB,0x79,0xF0,0xAA};

uint32_t MonitorTaskModel::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_monitorMode = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast19;
          xfer += iprot->readI32(ecast19);
          this->monitorMode = ( ::apache::airavata::model::appcatalog::computeresource::MonitorMode::type)ecast19;
          isset_monitorMode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_monitorMode)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t MonitorTaskModel::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  oprot->incrementRecursionDepth();
  xfer += oprot->writeStructBegin("MonitorTaskModel");

  xfer += oprot->writeFieldBegin("monitorMode", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((int32_t)this->monitorMode);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  oprot->decrementRecursionDepth();
  return xfer;
}

void swap(MonitorTaskModel &a, MonitorTaskModel &b) {
  using ::std::swap;
  swap(a.monitorMode, b.monitorMode);
}

MonitorTaskModel::MonitorTaskModel(const MonitorTaskModel& other20) {
  monitorMode = other20.monitorMode;
}
MonitorTaskModel& MonitorTaskModel::operator=(const MonitorTaskModel& other21) {
  monitorMode = other21.monitorMode;
  return *this;
}
std::ostream& operator<<(std::ostream& out, const MonitorTaskModel& obj) {
  using apache::thrift::to_string;
  out << "MonitorTaskModel(";
  out << "monitorMode=" << to_string(obj.monitorMode);
  out << ")";
  return out;
}

}}}} // namespace
