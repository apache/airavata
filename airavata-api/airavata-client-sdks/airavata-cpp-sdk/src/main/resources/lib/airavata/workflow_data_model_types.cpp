/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Autogenerated by Thrift Compiler (0.9.3)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#include "workflow_data_model_types.h"

#include <algorithm>
#include <ostream>

#include <thrift/TToString.h>



int _kWorkflowStateValues[] = {
  WorkflowState::CREATED,
  WorkflowState::STARTED,
  WorkflowState::EXECUTING,
  WorkflowState::COMPLETED,
  WorkflowState::FAILED,
  WorkflowState::CANCELLING,
  WorkflowState::CANCELED
};
const char* _kWorkflowStateNames[] = {
  "CREATED",
  "STARTED",
  "EXECUTING",
  "COMPLETED",
  "FAILED",
  "CANCELLING",
  "CANCELED"
};
const std::map<int, const char*> _WorkflowState_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(7, _kWorkflowStateValues, _kWorkflowStateNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kComponentStateValues[] = {
  ComponentState::CREATED,
  ComponentState::WAITING,
  ComponentState::READY,
  ComponentState::RUNNING,
  ComponentState::COMPLETED,
  ComponentState::FAILED,
  ComponentState::CANCELED
};
const char* _kComponentStateNames[] = {
  "CREATED",
  "WAITING",
  "READY",
  "RUNNING",
  "COMPLETED",
  "FAILED",
  "CANCELED"
};
const std::map<int, const char*> _ComponentState_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(7, _kComponentStateValues, _kComponentStateNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));


WorkflowModel::~WorkflowModel() throw() {
}


void WorkflowModel::__set_templateId(const std::string& val) {
  this->templateId = val;
}

void WorkflowModel::__set_name(const std::string& val) {
  this->name = val;
}

void WorkflowModel::__set_graph(const std::string& val) {
  this->graph = val;
}

void WorkflowModel::__set_gatewayId(const std::string& val) {
  this->gatewayId = val;
}

void WorkflowModel::__set_createdUser(const std::string& val) {
  this->createdUser = val;
}

void WorkflowModel::__set_image(const std::string& val) {
  this->image = val;
__isset.image = true;
}

void WorkflowModel::__set_workflowInputs(const std::vector< ::apache::airavata::model::application::io::InputDataObjectType> & val) {
  this->workflowInputs = val;
__isset.workflowInputs = true;
}

void WorkflowModel::__set_workflowOutputs(const std::vector< ::apache::airavata::model::application::io::OutputDataObjectType> & val) {
  this->workflowOutputs = val;
__isset.workflowOutputs = true;
}

void WorkflowModel::__set_creationTime(const int64_t val) {
  this->creationTime = val;
__isset.creationTime = true;
}

uint32_t WorkflowModel::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_templateId = false;
  bool isset_name = false;
  bool isset_graph = false;
  bool isset_gatewayId = false;
  bool isset_createdUser = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->templateId);
          isset_templateId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->name);
          isset_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->graph);
          isset_graph = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->gatewayId);
          isset_gatewayId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->createdUser);
          isset_createdUser = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->image);
          this->__isset.image = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->workflowInputs.clear();
            uint32_t _size0;
            ::apache::thrift::protocol::TType _etype3;
            xfer += iprot->readListBegin(_etype3, _size0);
            this->workflowInputs.resize(_size0);
            uint32_t _i4;
            for (_i4 = 0; _i4 < _size0; ++_i4)
            {
              xfer += this->workflowInputs[_i4].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.workflowInputs = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->workflowOutputs.clear();
            uint32_t _size5;
            ::apache::thrift::protocol::TType _etype8;
            xfer += iprot->readListBegin(_etype8, _size5);
            this->workflowOutputs.resize(_size5);
            uint32_t _i9;
            for (_i9 = 0; _i9 < _size5; ++_i9)
            {
              xfer += this->workflowOutputs[_i9].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.workflowOutputs = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->creationTime);
          this->__isset.creationTime = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_templateId)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_name)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_graph)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_gatewayId)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_createdUser)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t WorkflowModel::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("WorkflowModel");

  xfer += oprot->writeFieldBegin("templateId", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->templateId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("name", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("graph", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->graph);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("gatewayId", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString(this->gatewayId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("createdUser", ::apache::thrift::protocol::T_STRING, 5);
  xfer += oprot->writeString(this->createdUser);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.image) {
    xfer += oprot->writeFieldBegin("image", ::apache::thrift::protocol::T_STRING, 6);
    xfer += oprot->writeBinary(this->image);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.workflowInputs) {
    xfer += oprot->writeFieldBegin("workflowInputs", ::apache::thrift::protocol::T_LIST, 7);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->workflowInputs.size()));
      std::vector< ::apache::airavata::model::application::io::InputDataObjectType> ::const_iterator _iter10;
      for (_iter10 = this->workflowInputs.begin(); _iter10 != this->workflowInputs.end(); ++_iter10)
      {
        xfer += (*_iter10).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.workflowOutputs) {
    xfer += oprot->writeFieldBegin("workflowOutputs", ::apache::thrift::protocol::T_LIST, 8);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->workflowOutputs.size()));
      std::vector< ::apache::airavata::model::application::io::OutputDataObjectType> ::const_iterator _iter11;
      for (_iter11 = this->workflowOutputs.begin(); _iter11 != this->workflowOutputs.end(); ++_iter11)
      {
        xfer += (*_iter11).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.creationTime) {
    xfer += oprot->writeFieldBegin("creationTime", ::apache::thrift::protocol::T_I64, 9);
    xfer += oprot->writeI64(this->creationTime);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(WorkflowModel &a, WorkflowModel &b) {
  using ::std::swap;
  swap(a.templateId, b.templateId);
  swap(a.name, b.name);
  swap(a.graph, b.graph);
  swap(a.gatewayId, b.gatewayId);
  swap(a.createdUser, b.createdUser);
  swap(a.image, b.image);
  swap(a.workflowInputs, b.workflowInputs);
  swap(a.workflowOutputs, b.workflowOutputs);
  swap(a.creationTime, b.creationTime);
  swap(a.__isset, b.__isset);
}

WorkflowModel::WorkflowModel(const WorkflowModel& other12) {
  templateId = other12.templateId;
  name = other12.name;
  graph = other12.graph;
  gatewayId = other12.gatewayId;
  createdUser = other12.createdUser;
  image = other12.image;
  workflowInputs = other12.workflowInputs;
  workflowOutputs = other12.workflowOutputs;
  creationTime = other12.creationTime;
  __isset = other12.__isset;
}
WorkflowModel& WorkflowModel::operator=(const WorkflowModel& other13) {
  templateId = other13.templateId;
  name = other13.name;
  graph = other13.graph;
  gatewayId = other13.gatewayId;
  createdUser = other13.createdUser;
  image = other13.image;
  workflowInputs = other13.workflowInputs;
  workflowOutputs = other13.workflowOutputs;
  creationTime = other13.creationTime;
  __isset = other13.__isset;
  return *this;
}
void WorkflowModel::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "WorkflowModel(";
  out << "templateId=" << to_string(templateId);
  out << ", " << "name=" << to_string(name);
  out << ", " << "graph=" << to_string(graph);
  out << ", " << "gatewayId=" << to_string(gatewayId);
  out << ", " << "createdUser=" << to_string(createdUser);
  out << ", " << "image="; (__isset.image ? (out << to_string(image)) : (out << "<null>"));
  out << ", " << "workflowInputs="; (__isset.workflowInputs ? (out << to_string(workflowInputs)) : (out << "<null>"));
  out << ", " << "workflowOutputs="; (__isset.workflowOutputs ? (out << to_string(workflowOutputs)) : (out << "<null>"));
  out << ", " << "creationTime="; (__isset.creationTime ? (out << to_string(creationTime)) : (out << "<null>"));
  out << ")";
}


ComponentStatus::~ComponentStatus() throw() {
}


void ComponentStatus::__set_state(const ComponentState::type val) {
  this->state = val;
}

void ComponentStatus::__set_reason(const std::string& val) {
  this->reason = val;
__isset.reason = true;
}

void ComponentStatus::__set_timeofStateChange(const int64_t val) {
  this->timeofStateChange = val;
__isset.timeofStateChange = true;
}

uint32_t ComponentStatus::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_state = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast14;
          xfer += iprot->readI32(ecast14);
          this->state = (ComponentState::type)ecast14;
          isset_state = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->reason);
          this->__isset.reason = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->timeofStateChange);
          this->__isset.timeofStateChange = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_state)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t ComponentStatus::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ComponentStatus");

  xfer += oprot->writeFieldBegin("state", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((int32_t)this->state);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.reason) {
    xfer += oprot->writeFieldBegin("reason", ::apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeString(this->reason);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.timeofStateChange) {
    xfer += oprot->writeFieldBegin("timeofStateChange", ::apache::thrift::protocol::T_I64, 3);
    xfer += oprot->writeI64(this->timeofStateChange);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ComponentStatus &a, ComponentStatus &b) {
  using ::std::swap;
  swap(a.state, b.state);
  swap(a.reason, b.reason);
  swap(a.timeofStateChange, b.timeofStateChange);
  swap(a.__isset, b.__isset);
}

ComponentStatus::ComponentStatus(const ComponentStatus& other15) {
  state = other15.state;
  reason = other15.reason;
  timeofStateChange = other15.timeofStateChange;
  __isset = other15.__isset;
}
ComponentStatus& ComponentStatus::operator=(const ComponentStatus& other16) {
  state = other16.state;
  reason = other16.reason;
  timeofStateChange = other16.timeofStateChange;
  __isset = other16.__isset;
  return *this;
}
void ComponentStatus::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "ComponentStatus(";
  out << "state=" << to_string(state);
  out << ", " << "reason="; (__isset.reason ? (out << to_string(reason)) : (out << "<null>"));
  out << ", " << "timeofStateChange="; (__isset.timeofStateChange ? (out << to_string(timeofStateChange)) : (out << "<null>"));
  out << ")";
}


WorkflowStatus::~WorkflowStatus() throw() {
}


void WorkflowStatus::__set_state(const WorkflowState::type val) {
  this->state = val;
}

void WorkflowStatus::__set_timeOfStateChange(const int64_t val) {
  this->timeOfStateChange = val;
__isset.timeOfStateChange = true;
}

void WorkflowStatus::__set_reason(const std::string& val) {
  this->reason = val;
__isset.reason = true;
}

uint32_t WorkflowStatus::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_state = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast17;
          xfer += iprot->readI32(ecast17);
          this->state = (WorkflowState::type)ecast17;
          isset_state = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->timeOfStateChange);
          this->__isset.timeOfStateChange = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->reason);
          this->__isset.reason = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_state)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t WorkflowStatus::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("WorkflowStatus");

  xfer += oprot->writeFieldBegin("state", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((int32_t)this->state);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.timeOfStateChange) {
    xfer += oprot->writeFieldBegin("timeOfStateChange", ::apache::thrift::protocol::T_I64, 2);
    xfer += oprot->writeI64(this->timeOfStateChange);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.reason) {
    xfer += oprot->writeFieldBegin("reason", ::apache::thrift::protocol::T_STRING, 3);
    xfer += oprot->writeString(this->reason);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(WorkflowStatus &a, WorkflowStatus &b) {
  using ::std::swap;
  swap(a.state, b.state);
  swap(a.timeOfStateChange, b.timeOfStateChange);
  swap(a.reason, b.reason);
  swap(a.__isset, b.__isset);
}

WorkflowStatus::WorkflowStatus(const WorkflowStatus& other18) {
  state = other18.state;
  timeOfStateChange = other18.timeOfStateChange;
  reason = other18.reason;
  __isset = other18.__isset;
}
WorkflowStatus& WorkflowStatus::operator=(const WorkflowStatus& other19) {
  state = other19.state;
  timeOfStateChange = other19.timeOfStateChange;
  reason = other19.reason;
  __isset = other19.__isset;
  return *this;
}
void WorkflowStatus::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "WorkflowStatus(";
  out << "state=" << to_string(state);
  out << ", " << "timeOfStateChange="; (__isset.timeOfStateChange ? (out << to_string(timeOfStateChange)) : (out << "<null>"));
  out << ", " << "reason="; (__isset.reason ? (out << to_string(reason)) : (out << "<null>"));
  out << ")";
}


EdgeModel::~EdgeModel() throw() {
}


void EdgeModel::__set_edgeId(const std::string& val) {
  this->edgeId = val;
}

void EdgeModel::__set_name(const std::string& val) {
  this->name = val;
__isset.name = true;
}

void EdgeModel::__set_status(const ComponentStatus& val) {
  this->status = val;
__isset.status = true;
}

void EdgeModel::__set_description(const std::string& val) {
  this->description = val;
__isset.description = true;
}

uint32_t EdgeModel::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_edgeId = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->edgeId);
          isset_edgeId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->name);
          this->__isset.name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->status.read(iprot);
          this->__isset.status = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->description);
          this->__isset.description = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_edgeId)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t EdgeModel::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("EdgeModel");

  xfer += oprot->writeFieldBegin("edgeId", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->edgeId);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.name) {
    xfer += oprot->writeFieldBegin("name", ::apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeString(this->name);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.status) {
    xfer += oprot->writeFieldBegin("status", ::apache::thrift::protocol::T_STRUCT, 3);
    xfer += this->status.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.description) {
    xfer += oprot->writeFieldBegin("description", ::apache::thrift::protocol::T_STRING, 4);
    xfer += oprot->writeString(this->description);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(EdgeModel &a, EdgeModel &b) {
  using ::std::swap;
  swap(a.edgeId, b.edgeId);
  swap(a.name, b.name);
  swap(a.status, b.status);
  swap(a.description, b.description);
  swap(a.__isset, b.__isset);
}

EdgeModel::EdgeModel(const EdgeModel& other20) {
  edgeId = other20.edgeId;
  name = other20.name;
  status = other20.status;
  description = other20.description;
  __isset = other20.__isset;
}
EdgeModel& EdgeModel::operator=(const EdgeModel& other21) {
  edgeId = other21.edgeId;
  name = other21.name;
  status = other21.status;
  description = other21.description;
  __isset = other21.__isset;
  return *this;
}
void EdgeModel::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "EdgeModel(";
  out << "edgeId=" << to_string(edgeId);
  out << ", " << "name="; (__isset.name ? (out << to_string(name)) : (out << "<null>"));
  out << ", " << "status="; (__isset.status ? (out << to_string(status)) : (out << "<null>"));
  out << ", " << "description="; (__isset.description ? (out << to_string(description)) : (out << "<null>"));
  out << ")";
}


PortModel::~PortModel() throw() {
}


void PortModel::__set_portId(const std::string& val) {
  this->portId = val;
}

void PortModel::__set_name(const std::string& val) {
  this->name = val;
__isset.name = true;
}

void PortModel::__set_status(const ComponentStatus& val) {
  this->status = val;
__isset.status = true;
}

void PortModel::__set_value(const std::string& val) {
  this->value = val;
__isset.value = true;
}

void PortModel::__set_description(const std::string& val) {
  this->description = val;
__isset.description = true;
}

uint32_t PortModel::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_portId = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->portId);
          isset_portId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->name);
          this->__isset.name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->status.read(iprot);
          this->__isset.status = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->value);
          this->__isset.value = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->description);
          this->__isset.description = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_portId)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t PortModel::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("PortModel");

  xfer += oprot->writeFieldBegin("portId", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->portId);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.name) {
    xfer += oprot->writeFieldBegin("name", ::apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeString(this->name);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.status) {
    xfer += oprot->writeFieldBegin("status", ::apache::thrift::protocol::T_STRUCT, 3);
    xfer += this->status.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.value) {
    xfer += oprot->writeFieldBegin("value", ::apache::thrift::protocol::T_STRING, 4);
    xfer += oprot->writeString(this->value);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.description) {
    xfer += oprot->writeFieldBegin("description", ::apache::thrift::protocol::T_STRING, 5);
    xfer += oprot->writeString(this->description);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(PortModel &a, PortModel &b) {
  using ::std::swap;
  swap(a.portId, b.portId);
  swap(a.name, b.name);
  swap(a.status, b.status);
  swap(a.value, b.value);
  swap(a.description, b.description);
  swap(a.__isset, b.__isset);
}

PortModel::PortModel(const PortModel& other22) {
  portId = other22.portId;
  name = other22.name;
  status = other22.status;
  value = other22.value;
  description = other22.description;
  __isset = other22.__isset;
}
PortModel& PortModel::operator=(const PortModel& other23) {
  portId = other23.portId;
  name = other23.name;
  status = other23.status;
  value = other23.value;
  description = other23.description;
  __isset = other23.__isset;
  return *this;
}
void PortModel::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "PortModel(";
  out << "portId=" << to_string(portId);
  out << ", " << "name="; (__isset.name ? (out << to_string(name)) : (out << "<null>"));
  out << ", " << "status="; (__isset.status ? (out << to_string(status)) : (out << "<null>"));
  out << ", " << "value="; (__isset.value ? (out << to_string(value)) : (out << "<null>"));
  out << ", " << "description="; (__isset.description ? (out << to_string(description)) : (out << "<null>"));
  out << ")";
}


NodeModel::~NodeModel() throw() {
}


void NodeModel::__set_nodeId(const std::string& val) {
  this->nodeId = val;
}

void NodeModel::__set_name(const std::string& val) {
  this->name = val;
__isset.name = true;
}

void NodeModel::__set_applicationId(const std::string& val) {
  this->applicationId = val;
__isset.applicationId = true;
}

void NodeModel::__set_applicationName(const std::string& val) {
  this->applicationName = val;
__isset.applicationName = true;
}

void NodeModel::__set_status(const ComponentStatus& val) {
  this->status = val;
__isset.status = true;
}

void NodeModel::__set_description(const std::string& val) {
  this->description = val;
__isset.description = true;
}

uint32_t NodeModel::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_nodeId = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->nodeId);
          isset_nodeId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->name);
          this->__isset.name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->applicationId);
          this->__isset.applicationId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->applicationName);
          this->__isset.applicationName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->status.read(iprot);
          this->__isset.status = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->description);
          this->__isset.description = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_nodeId)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t NodeModel::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("NodeModel");

  xfer += oprot->writeFieldBegin("nodeId", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->nodeId);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.name) {
    xfer += oprot->writeFieldBegin("name", ::apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeString(this->name);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.applicationId) {
    xfer += oprot->writeFieldBegin("applicationId", ::apache::thrift::protocol::T_STRING, 3);
    xfer += oprot->writeString(this->applicationId);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.applicationName) {
    xfer += oprot->writeFieldBegin("applicationName", ::apache::thrift::protocol::T_STRING, 4);
    xfer += oprot->writeString(this->applicationName);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.status) {
    xfer += oprot->writeFieldBegin("status", ::apache::thrift::protocol::T_STRUCT, 5);
    xfer += this->status.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.description) {
    xfer += oprot->writeFieldBegin("description", ::apache::thrift::protocol::T_STRING, 6);
    xfer += oprot->writeString(this->description);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(NodeModel &a, NodeModel &b) {
  using ::std::swap;
  swap(a.nodeId, b.nodeId);
  swap(a.name, b.name);
  swap(a.applicationId, b.applicationId);
  swap(a.applicationName, b.applicationName);
  swap(a.status, b.status);
  swap(a.description, b.description);
  swap(a.__isset, b.__isset);
}

NodeModel::NodeModel(const NodeModel& other24) {
  nodeId = other24.nodeId;
  name = other24.name;
  applicationId = other24.applicationId;
  applicationName = other24.applicationName;
  status = other24.status;
  description = other24.description;
  __isset = other24.__isset;
}
NodeModel& NodeModel::operator=(const NodeModel& other25) {
  nodeId = other25.nodeId;
  name = other25.name;
  applicationId = other25.applicationId;
  applicationName = other25.applicationName;
  status = other25.status;
  description = other25.description;
  __isset = other25.__isset;
  return *this;
}
void NodeModel::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "NodeModel(";
  out << "nodeId=" << to_string(nodeId);
  out << ", " << "name="; (__isset.name ? (out << to_string(name)) : (out << "<null>"));
  out << ", " << "applicationId="; (__isset.applicationId ? (out << to_string(applicationId)) : (out << "<null>"));
  out << ", " << "applicationName="; (__isset.applicationName ? (out << to_string(applicationName)) : (out << "<null>"));
  out << ", " << "status="; (__isset.status ? (out << to_string(status)) : (out << "<null>"));
  out << ", " << "description="; (__isset.description ? (out << to_string(description)) : (out << "<null>"));
  out << ")";
}


