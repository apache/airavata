/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Autogenerated by Thrift Compiler (0.9.2)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#include "compute_resource_model_types.h"

#include <algorithm>
#include <ostream>

#include <thrift/TToString.h>

namespace apache { namespace airavata { namespace model { namespace appcatalog { namespace computeresource {

int _kResourceJobManagerTypeValues[] = {
  ResourceJobManagerType::FORK,
  ResourceJobManagerType::PBS,
  ResourceJobManagerType::SLURM,
  ResourceJobManagerType::LSF,
  ResourceJobManagerType::UGE
};
const char* _kResourceJobManagerTypeNames[] = {
  "FORK",
  "PBS",
  "SLURM",
  "LSF",
  "UGE"
};
const std::map<int, const char*> _ResourceJobManagerType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(5, _kResourceJobManagerTypeValues, _kResourceJobManagerTypeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kJobManagerCommandValues[] = {
  JobManagerCommand::SUBMISSION,
  JobManagerCommand::JOB_MONITORING,
  JobManagerCommand::DELETION,
  JobManagerCommand::CHECK_JOB,
  JobManagerCommand::SHOW_QUEUE,
  JobManagerCommand::SHOW_RESERVATION,
  JobManagerCommand::SHOW_START
};
const char* _kJobManagerCommandNames[] = {
  "SUBMISSION",
  "JOB_MONITORING",
  "DELETION",
  "CHECK_JOB",
  "SHOW_QUEUE",
  "SHOW_RESERVATION",
  "SHOW_START"
};
const std::map<int, const char*> _JobManagerCommand_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(7, _kJobManagerCommandValues, _kJobManagerCommandNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kFileSystemsValues[] = {
  FileSystems::HOME,
  FileSystems::WORK,
  FileSystems::LOCALTMP,
  FileSystems::SCRATCH,
  FileSystems::ARCHIVE
};
const char* _kFileSystemsNames[] = {
  "HOME",
  "WORK",
  "LOCALTMP",
  "SCRATCH",
  "ARCHIVE"
};
const std::map<int, const char*> _FileSystems_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(5, _kFileSystemsValues, _kFileSystemsNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kSecurityProtocolValues[] = {
  SecurityProtocol::USERNAME_PASSWORD,
  SecurityProtocol::SSH_KEYS,
  SecurityProtocol::GSI,
  SecurityProtocol::KERBEROS,
  SecurityProtocol::OAUTH,
  SecurityProtocol::LOCAL
};
const char* _kSecurityProtocolNames[] = {
  "USERNAME_PASSWORD",
  "SSH_KEYS",
  "GSI",
  "KERBEROS",
  "OAUTH",
  "LOCAL"
};
const std::map<int, const char*> _SecurityProtocol_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(6, _kSecurityProtocolValues, _kSecurityProtocolNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kJobSubmissionProtocolValues[] = {
  JobSubmissionProtocol::LOCAL,
  JobSubmissionProtocol::SSH,
  JobSubmissionProtocol::GLOBUS,
  JobSubmissionProtocol::UNICORE,
  JobSubmissionProtocol::CLOUD,
  JobSubmissionProtocol::SSH_FORK,
  JobSubmissionProtocol::LOCAL_FORK
};
const char* _kJobSubmissionProtocolNames[] = {
  "LOCAL",
  "SSH",
  "GLOBUS",
  "UNICORE",
  "CLOUD",
  "SSH_FORK",
  "LOCAL_FORK"
};
const std::map<int, const char*> _JobSubmissionProtocol_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(7, _kJobSubmissionProtocolValues, _kJobSubmissionProtocolNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kMonitorModeValues[] = {
  MonitorMode::POLL_JOB_MANAGER,
  MonitorMode::JOB_EMAIL_NOTIFICATION_MONITOR,
  MonitorMode::XSEDE_AMQP_SUBSCRIBE,
  MonitorMode::FORK
};
const char* _kMonitorModeNames[] = {
  "POLL_JOB_MANAGER",
  "JOB_EMAIL_NOTIFICATION_MONITOR",
  "XSEDE_AMQP_SUBSCRIBE",
  "FORK"
};
const std::map<int, const char*> _MonitorMode_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(4, _kMonitorModeValues, _kMonitorModeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kDMTypeValues[] = {
  DMType::COMPUTE_RESOURCE,
  DMType::STORAGE_RESOURCE
};
const char* _kDMTypeNames[] = {
  "COMPUTE_RESOURCE",
  "STORAGE_RESOURCE"
};
const std::map<int, const char*> _DMType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(2, _kDMTypeValues, _kDMTypeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kDataMovementProtocolValues[] = {
  DataMovementProtocol::LOCAL,
  DataMovementProtocol::SCP,
  DataMovementProtocol::SFTP,
  DataMovementProtocol::GridFTP,
  DataMovementProtocol::UNICORE_STORAGE_SERVICE
};
const char* _kDataMovementProtocolNames[] = {
  "LOCAL",
  "SCP",
  "SFTP",
  "GridFTP",
  "UNICORE_STORAGE_SERVICE"
};
const std::map<int, const char*> _DataMovementProtocol_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(5, _kDataMovementProtocolValues, _kDataMovementProtocolNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kProviderNameValues[] = {
  ProviderName::EC2,
  ProviderName::AWSEC2,
  ProviderName::RACKSPACE
};
const char* _kProviderNameNames[] = {
  "EC2",
  "AWSEC2",
  "RACKSPACE"
};
const std::map<int, const char*> _ProviderName_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(3, _kProviderNameValues, _kProviderNameNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));


ResourceJobManager::~ResourceJobManager() throw() {
}


void ResourceJobManager::__set_resourceJobManagerId(const std::string& val) {
  this->resourceJobManagerId = val;
}

void ResourceJobManager::__set_resourceJobManagerType(const ResourceJobManagerType::type val) {
  this->resourceJobManagerType = val;
}

void ResourceJobManager::__set_pushMonitoringEndpoint(const std::string& val) {
  this->pushMonitoringEndpoint = val;
__isset.pushMonitoringEndpoint = true;
}

void ResourceJobManager::__set_jobManagerBinPath(const std::string& val) {
  this->jobManagerBinPath = val;
__isset.jobManagerBinPath = true;
}

void ResourceJobManager::__set_jobManagerCommands(const std::map<JobManagerCommand::type, std::string> & val) {
  this->jobManagerCommands = val;
__isset.jobManagerCommands = true;
}

const char* ResourceJobManager::ascii_fingerprint = "F61CAF80247D0E44C8D52504F3A43BED";
const uint8_t ResourceJobManager::binary_fingerprint[16] = {0xF6,0x1C,0xAF,0x80,0x24,0x7D,0x0E,0x44,0xC8,0xD5,0x25,0x04,0xF3,0xA4,0x3B,0xED};

uint32_t ResourceJobManager::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_resourceJobManagerId = false;
  bool isset_resourceJobManagerType = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->resourceJobManagerId);
          isset_resourceJobManagerId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast0;
          xfer += iprot->readI32(ecast0);
          this->resourceJobManagerType = (ResourceJobManagerType::type)ecast0;
          isset_resourceJobManagerType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->pushMonitoringEndpoint);
          this->__isset.pushMonitoringEndpoint = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->jobManagerBinPath);
          this->__isset.jobManagerBinPath = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->jobManagerCommands.clear();
            uint32_t _size1;
            ::apache::thrift::protocol::TType _ktype2;
            ::apache::thrift::protocol::TType _vtype3;
            xfer += iprot->readMapBegin(_ktype2, _vtype3, _size1);
            uint32_t _i5;
            for (_i5 = 0; _i5 < _size1; ++_i5)
            {
              JobManagerCommand::type _key6;
              int32_t ecast8;
              xfer += iprot->readI32(ecast8);
              _key6 = (JobManagerCommand::type)ecast8;
              std::string& _val7 = this->jobManagerCommands[_key6];
              xfer += iprot->readString(_val7);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.jobManagerCommands = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_resourceJobManagerId)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_resourceJobManagerType)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t ResourceJobManager::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  oprot->incrementRecursionDepth();
  xfer += oprot->writeStructBegin("ResourceJobManager");

  xfer += oprot->writeFieldBegin("resourceJobManagerId", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->resourceJobManagerId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("resourceJobManagerType", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32((int32_t)this->resourceJobManagerType);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.pushMonitoringEndpoint) {
    xfer += oprot->writeFieldBegin("pushMonitoringEndpoint", ::apache::thrift::protocol::T_STRING, 3);
    xfer += oprot->writeString(this->pushMonitoringEndpoint);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.jobManagerBinPath) {
    xfer += oprot->writeFieldBegin("jobManagerBinPath", ::apache::thrift::protocol::T_STRING, 4);
    xfer += oprot->writeString(this->jobManagerBinPath);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.jobManagerCommands) {
    xfer += oprot->writeFieldBegin("jobManagerCommands", ::apache::thrift::protocol::T_MAP, 5);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_I32, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->jobManagerCommands.size()));
      std::map<JobManagerCommand::type, std::string> ::const_iterator _iter9;
      for (_iter9 = this->jobManagerCommands.begin(); _iter9 != this->jobManagerCommands.end(); ++_iter9)
      {
        xfer += oprot->writeI32((int32_t)_iter9->first);
        xfer += oprot->writeString(_iter9->second);
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  oprot->decrementRecursionDepth();
  return xfer;
}

void swap(ResourceJobManager &a, ResourceJobManager &b) {
  using ::std::swap;
  swap(a.resourceJobManagerId, b.resourceJobManagerId);
  swap(a.resourceJobManagerType, b.resourceJobManagerType);
  swap(a.pushMonitoringEndpoint, b.pushMonitoringEndpoint);
  swap(a.jobManagerBinPath, b.jobManagerBinPath);
  swap(a.jobManagerCommands, b.jobManagerCommands);
  swap(a.__isset, b.__isset);
}

ResourceJobManager::ResourceJobManager(const ResourceJobManager& other10) {
  resourceJobManagerId = other10.resourceJobManagerId;
  resourceJobManagerType = other10.resourceJobManagerType;
  pushMonitoringEndpoint = other10.pushMonitoringEndpoint;
  jobManagerBinPath = other10.jobManagerBinPath;
  jobManagerCommands = other10.jobManagerCommands;
  __isset = other10.__isset;
}
ResourceJobManager& ResourceJobManager::operator=(const ResourceJobManager& other11) {
  resourceJobManagerId = other11.resourceJobManagerId;
  resourceJobManagerType = other11.resourceJobManagerType;
  pushMonitoringEndpoint = other11.pushMonitoringEndpoint;
  jobManagerBinPath = other11.jobManagerBinPath;
  jobManagerCommands = other11.jobManagerCommands;
  __isset = other11.__isset;
  return *this;
}
std::ostream& operator<<(std::ostream& out, const ResourceJobManager& obj) {
  using apache::thrift::to_string;
  out << "ResourceJobManager(";
  out << "resourceJobManagerId=" << to_string(obj.resourceJobManagerId);
  out << ", " << "resourceJobManagerType=" << to_string(obj.resourceJobManagerType);
  out << ", " << "pushMonitoringEndpoint="; (obj.__isset.pushMonitoringEndpoint ? (out << to_string(obj.pushMonitoringEndpoint)) : (out << "<null>"));
  out << ", " << "jobManagerBinPath="; (obj.__isset.jobManagerBinPath ? (out << to_string(obj.jobManagerBinPath)) : (out << "<null>"));
  out << ", " << "jobManagerCommands="; (obj.__isset.jobManagerCommands ? (out << to_string(obj.jobManagerCommands)) : (out << "<null>"));
  out << ")";
  return out;
}


BatchQueue::~BatchQueue() throw() {
}


void BatchQueue::__set_queueName(const std::string& val) {
  this->queueName = val;
}

void BatchQueue::__set_queueDescription(const std::string& val) {
  this->queueDescription = val;
__isset.queueDescription = true;
}

void BatchQueue::__set_maxRunTime(const int32_t val) {
  this->maxRunTime = val;
__isset.maxRunTime = true;
}

void BatchQueue::__set_maxNodes(const int32_t val) {
  this->maxNodes = val;
__isset.maxNodes = true;
}

void BatchQueue::__set_maxProcessors(const int32_t val) {
  this->maxProcessors = val;
__isset.maxProcessors = true;
}

void BatchQueue::__set_maxJobsInQueue(const int32_t val) {
  this->maxJobsInQueue = val;
__isset.maxJobsInQueue = true;
}

void BatchQueue::__set_maxMemory(const int32_t val) {
  this->maxMemory = val;
__isset.maxMemory = true;
}

const char* BatchQueue::ascii_fingerprint = "ED0A78585E8BA402743AC1D5D510EF9E";
const uint8_t BatchQueue::binary_fingerprint[16] = {0xED,0x0A,0x78,0x58,0x5E,0x8B,0xA4,0x02,0x74,0x3A,0xC1,0xD5,0xD5,0x10,0xEF,0x9E};

uint32_t BatchQueue::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_queueName = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->queueName);
          isset_queueName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->queueDescription);
          this->__isset.queueDescription = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->maxRunTime);
          this->__isset.maxRunTime = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->maxNodes);
          this->__isset.maxNodes = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->maxProcessors);
          this->__isset.maxProcessors = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->maxJobsInQueue);
          this->__isset.maxJobsInQueue = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->maxMemory);
          this->__isset.maxMemory = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_queueName)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t BatchQueue::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  oprot->incrementRecursionDepth();
  xfer += oprot->writeStructBegin("BatchQueue");

  xfer += oprot->writeFieldBegin("queueName", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->queueName);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.queueDescription) {
    xfer += oprot->writeFieldBegin("queueDescription", ::apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeString(this->queueDescription);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.maxRunTime) {
    xfer += oprot->writeFieldBegin("maxRunTime", ::apache::thrift::protocol::T_I32, 3);
    xfer += oprot->writeI32(this->maxRunTime);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.maxNodes) {
    xfer += oprot->writeFieldBegin("maxNodes", ::apache::thrift::protocol::T_I32, 4);
    xfer += oprot->writeI32(this->maxNodes);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.maxProcessors) {
    xfer += oprot->writeFieldBegin("maxProcessors", ::apache::thrift::protocol::T_I32, 5);
    xfer += oprot->writeI32(this->maxProcessors);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.maxJobsInQueue) {
    xfer += oprot->writeFieldBegin("maxJobsInQueue", ::apache::thrift::protocol::T_I32, 6);
    xfer += oprot->writeI32(this->maxJobsInQueue);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.maxMemory) {
    xfer += oprot->writeFieldBegin("maxMemory", ::apache::thrift::protocol::T_I32, 7);
    xfer += oprot->writeI32(this->maxMemory);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  oprot->decrementRecursionDepth();
  return xfer;
}

void swap(BatchQueue &a, BatchQueue &b) {
  using ::std::swap;
  swap(a.queueName, b.queueName);
  swap(a.queueDescription, b.queueDescription);
  swap(a.maxRunTime, b.maxRunTime);
  swap(a.maxNodes, b.maxNodes);
  swap(a.maxProcessors, b.maxProcessors);
  swap(a.maxJobsInQueue, b.maxJobsInQueue);
  swap(a.maxMemory, b.maxMemory);
  swap(a.__isset, b.__isset);
}

BatchQueue::BatchQueue(const BatchQueue& other12) {
  queueName = other12.queueName;
  queueDescription = other12.queueDescription;
  maxRunTime = other12.maxRunTime;
  maxNodes = other12.maxNodes;
  maxProcessors = other12.maxProcessors;
  maxJobsInQueue = other12.maxJobsInQueue;
  maxMemory = other12.maxMemory;
  __isset = other12.__isset;
}
BatchQueue& BatchQueue::operator=(const BatchQueue& other13) {
  queueName = other13.queueName;
  queueDescription = other13.queueDescription;
  maxRunTime = other13.maxRunTime;
  maxNodes = other13.maxNodes;
  maxProcessors = other13.maxProcessors;
  maxJobsInQueue = other13.maxJobsInQueue;
  maxMemory = other13.maxMemory;
  __isset = other13.__isset;
  return *this;
}
std::ostream& operator<<(std::ostream& out, const BatchQueue& obj) {
  using apache::thrift::to_string;
  out << "BatchQueue(";
  out << "queueName=" << to_string(obj.queueName);
  out << ", " << "queueDescription="; (obj.__isset.queueDescription ? (out << to_string(obj.queueDescription)) : (out << "<null>"));
  out << ", " << "maxRunTime="; (obj.__isset.maxRunTime ? (out << to_string(obj.maxRunTime)) : (out << "<null>"));
  out << ", " << "maxNodes="; (obj.__isset.maxNodes ? (out << to_string(obj.maxNodes)) : (out << "<null>"));
  out << ", " << "maxProcessors="; (obj.__isset.maxProcessors ? (out << to_string(obj.maxProcessors)) : (out << "<null>"));
  out << ", " << "maxJobsInQueue="; (obj.__isset.maxJobsInQueue ? (out << to_string(obj.maxJobsInQueue)) : (out << "<null>"));
  out << ", " << "maxMemory="; (obj.__isset.maxMemory ? (out << to_string(obj.maxMemory)) : (out << "<null>"));
  out << ")";
  return out;
}


SCPDataMovement::~SCPDataMovement() throw() {
}


void SCPDataMovement::__set_dataMovementInterfaceId(const std::string& val) {
  this->dataMovementInterfaceId = val;
}

void SCPDataMovement::__set_securityProtocol(const SecurityProtocol::type val) {
  this->securityProtocol = val;
}

void SCPDataMovement::__set_alternativeSCPHostName(const std::string& val) {
  this->alternativeSCPHostName = val;
__isset.alternativeSCPHostName = true;
}

void SCPDataMovement::__set_sshPort(const int32_t val) {
  this->sshPort = val;
__isset.sshPort = true;
}

const char* SCPDataMovement::ascii_fingerprint = "63CAE6EE336A7DBD91CCCD6E22628F4A";
const uint8_t SCPDataMovement::binary_fingerprint[16] = {0x63,0xCA,0xE6,0xEE,0x33,0x6A,0x7D,0xBD,0x91,0xCC,0xCD,0x6E,0x22,0x62,0x8F,0x4A};

uint32_t SCPDataMovement::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_dataMovementInterfaceId = false;
  bool isset_securityProtocol = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->dataMovementInterfaceId);
          isset_dataMovementInterfaceId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast14;
          xfer += iprot->readI32(ecast14);
          this->securityProtocol = (SecurityProtocol::type)ecast14;
          isset_securityProtocol = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->alternativeSCPHostName);
          this->__isset.alternativeSCPHostName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->sshPort);
          this->__isset.sshPort = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_dataMovementInterfaceId)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_securityProtocol)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t SCPDataMovement::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  oprot->incrementRecursionDepth();
  xfer += oprot->writeStructBegin("SCPDataMovement");

  xfer += oprot->writeFieldBegin("dataMovementInterfaceId", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->dataMovementInterfaceId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("securityProtocol", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32((int32_t)this->securityProtocol);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.alternativeSCPHostName) {
    xfer += oprot->writeFieldBegin("alternativeSCPHostName", ::apache::thrift::protocol::T_STRING, 3);
    xfer += oprot->writeString(this->alternativeSCPHostName);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.sshPort) {
    xfer += oprot->writeFieldBegin("sshPort", ::apache::thrift::protocol::T_I32, 4);
    xfer += oprot->writeI32(this->sshPort);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  oprot->decrementRecursionDepth();
  return xfer;
}

void swap(SCPDataMovement &a, SCPDataMovement &b) {
  using ::std::swap;
  swap(a.dataMovementInterfaceId, b.dataMovementInterfaceId);
  swap(a.securityProtocol, b.securityProtocol);
  swap(a.alternativeSCPHostName, b.alternativeSCPHostName);
  swap(a.sshPort, b.sshPort);
  swap(a.__isset, b.__isset);
}

SCPDataMovement::SCPDataMovement(const SCPDataMovement& other15) {
  dataMovementInterfaceId = other15.dataMovementInterfaceId;
  securityProtocol = other15.securityProtocol;
  alternativeSCPHostName = other15.alternativeSCPHostName;
  sshPort = other15.sshPort;
  __isset = other15.__isset;
}
SCPDataMovement& SCPDataMovement::operator=(const SCPDataMovement& other16) {
  dataMovementInterfaceId = other16.dataMovementInterfaceId;
  securityProtocol = other16.securityProtocol;
  alternativeSCPHostName = other16.alternativeSCPHostName;
  sshPort = other16.sshPort;
  __isset = other16.__isset;
  return *this;
}
std::ostream& operator<<(std::ostream& out, const SCPDataMovement& obj) {
  using apache::thrift::to_string;
  out << "SCPDataMovement(";
  out << "dataMovementInterfaceId=" << to_string(obj.dataMovementInterfaceId);
  out << ", " << "securityProtocol=" << to_string(obj.securityProtocol);
  out << ", " << "alternativeSCPHostName="; (obj.__isset.alternativeSCPHostName ? (out << to_string(obj.alternativeSCPHostName)) : (out << "<null>"));
  out << ", " << "sshPort="; (obj.__isset.sshPort ? (out << to_string(obj.sshPort)) : (out << "<null>"));
  out << ")";
  return out;
}


GridFTPDataMovement::~GridFTPDataMovement() throw() {
}


void GridFTPDataMovement::__set_dataMovementInterfaceId(const std::string& val) {
  this->dataMovementInterfaceId = val;
}

void GridFTPDataMovement::__set_securityProtocol(const SecurityProtocol::type val) {
  this->securityProtocol = val;
}

void GridFTPDataMovement::__set_gridFTPEndPoints(const std::vector<std::string> & val) {
  this->gridFTPEndPoints = val;
}

const char* GridFTPDataMovement::ascii_fingerprint = "790EE8B1D56A3B9B76C41DD063726E75";
const uint8_t GridFTPDataMovement::binary_fingerprint[16] = {0x79,0x0E,0xE8,0xB1,0xD5,0x6A,0x3B,0x9B,0x76,0xC4,0x1D,0xD0,0x63,0x72,0x6E,0x75};

uint32_t GridFTPDataMovement::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_dataMovementInterfaceId = false;
  bool isset_securityProtocol = false;
  bool isset_gridFTPEndPoints = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->dataMovementInterfaceId);
          isset_dataMovementInterfaceId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast17;
          xfer += iprot->readI32(ecast17);
          this->securityProtocol = (SecurityProtocol::type)ecast17;
          isset_securityProtocol = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->gridFTPEndPoints.clear();
            uint32_t _size18;
            ::apache::thrift::protocol::TType _etype21;
            xfer += iprot->readListBegin(_etype21, _size18);
            this->gridFTPEndPoints.resize(_size18);
            uint32_t _i22;
            for (_i22 = 0; _i22 < _size18; ++_i22)
            {
              xfer += iprot->readString(this->gridFTPEndPoints[_i22]);
            }
            xfer += iprot->readListEnd();
          }
          isset_gridFTPEndPoints = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_dataMovementInterfaceId)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_securityProtocol)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_gridFTPEndPoints)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t GridFTPDataMovement::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  oprot->incrementRecursionDepth();
  xfer += oprot->writeStructBegin("GridFTPDataMovement");

  xfer += oprot->writeFieldBegin("dataMovementInterfaceId", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->dataMovementInterfaceId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("securityProtocol", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32((int32_t)this->securityProtocol);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("gridFTPEndPoints", ::apache::thrift::protocol::T_LIST, 3);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->gridFTPEndPoints.size()));
    std::vector<std::string> ::const_iterator _iter23;
    for (_iter23 = this->gridFTPEndPoints.begin(); _iter23 != this->gridFTPEndPoints.end(); ++_iter23)
    {
      xfer += oprot->writeString((*_iter23));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  oprot->decrementRecursionDepth();
  return xfer;
}

void swap(GridFTPDataMovement &a, GridFTPDataMovement &b) {
  using ::std::swap;
  swap(a.dataMovementInterfaceId, b.dataMovementInterfaceId);
  swap(a.securityProtocol, b.securityProtocol);
  swap(a.gridFTPEndPoints, b.gridFTPEndPoints);
}

GridFTPDataMovement::GridFTPDataMovement(const GridFTPDataMovement& other24) {
  dataMovementInterfaceId = other24.dataMovementInterfaceId;
  securityProtocol = other24.securityProtocol;
  gridFTPEndPoints = other24.gridFTPEndPoints;
}
GridFTPDataMovement& GridFTPDataMovement::operator=(const GridFTPDataMovement& other25) {
  dataMovementInterfaceId = other25.dataMovementInterfaceId;
  securityProtocol = other25.securityProtocol;
  gridFTPEndPoints = other25.gridFTPEndPoints;
  return *this;
}
std::ostream& operator<<(std::ostream& out, const GridFTPDataMovement& obj) {
  using apache::thrift::to_string;
  out << "GridFTPDataMovement(";
  out << "dataMovementInterfaceId=" << to_string(obj.dataMovementInterfaceId);
  out << ", " << "securityProtocol=" << to_string(obj.securityProtocol);
  out << ", " << "gridFTPEndPoints=" << to_string(obj.gridFTPEndPoints);
  out << ")";
  return out;
}


UnicoreDataMovement::~UnicoreDataMovement() throw() {
}


void UnicoreDataMovement::__set_dataMovementInterfaceId(const std::string& val) {
  this->dataMovementInterfaceId = val;
}

void UnicoreDataMovement::__set_securityProtocol(const SecurityProtocol::type val) {
  this->securityProtocol = val;
}

void UnicoreDataMovement::__set_unicoreEndPointURL(const std::string& val) {
  this->unicoreEndPointURL = val;
}

const char* UnicoreDataMovement::ascii_fingerprint = "D9F4CFE2F293A8B1052FD3031DD2C847";
const uint8_t UnicoreDataMovement::binary_fingerprint[16] = {0xD9,0xF4,0xCF,0xE2,0xF2,0x93,0xA8,0xB1,0x05,0x2F,0xD3,0x03,0x1D,0xD2,0xC8,0x47};

uint32_t UnicoreDataMovement::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_dataMovementInterfaceId = false;
  bool isset_securityProtocol = false;
  bool isset_unicoreEndPointURL = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->dataMovementInterfaceId);
          isset_dataMovementInterfaceId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast26;
          xfer += iprot->readI32(ecast26);
          this->securityProtocol = (SecurityProtocol::type)ecast26;
          isset_securityProtocol = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->unicoreEndPointURL);
          isset_unicoreEndPointURL = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_dataMovementInterfaceId)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_securityProtocol)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_unicoreEndPointURL)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t UnicoreDataMovement::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  oprot->incrementRecursionDepth();
  xfer += oprot->writeStructBegin("UnicoreDataMovement");

  xfer += oprot->writeFieldBegin("dataMovementInterfaceId", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->dataMovementInterfaceId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("securityProtocol", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32((int32_t)this->securityProtocol);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("unicoreEndPointURL", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->unicoreEndPointURL);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  oprot->decrementRecursionDepth();
  return xfer;
}

void swap(UnicoreDataMovement &a, UnicoreDataMovement &b) {
  using ::std::swap;
  swap(a.dataMovementInterfaceId, b.dataMovementInterfaceId);
  swap(a.securityProtocol, b.securityProtocol);
  swap(a.unicoreEndPointURL, b.unicoreEndPointURL);
}

UnicoreDataMovement::UnicoreDataMovement(const UnicoreDataMovement& other27) {
  dataMovementInterfaceId = other27.dataMovementInterfaceId;
  securityProtocol = other27.securityProtocol;
  unicoreEndPointURL = other27.unicoreEndPointURL;
}
UnicoreDataMovement& UnicoreDataMovement::operator=(const UnicoreDataMovement& other28) {
  dataMovementInterfaceId = other28.dataMovementInterfaceId;
  securityProtocol = other28.securityProtocol;
  unicoreEndPointURL = other28.unicoreEndPointURL;
  return *this;
}
std::ostream& operator<<(std::ostream& out, const UnicoreDataMovement& obj) {
  using apache::thrift::to_string;
  out << "UnicoreDataMovement(";
  out << "dataMovementInterfaceId=" << to_string(obj.dataMovementInterfaceId);
  out << ", " << "securityProtocol=" << to_string(obj.securityProtocol);
  out << ", " << "unicoreEndPointURL=" << to_string(obj.unicoreEndPointURL);
  out << ")";
  return out;
}


LOCALSubmission::~LOCALSubmission() throw() {
}


void LOCALSubmission::__set_jobSubmissionInterfaceId(const std::string& val) {
  this->jobSubmissionInterfaceId = val;
}

void LOCALSubmission::__set_securityProtocol(const SecurityProtocol::type val) {
  this->securityProtocol = val;
}

void LOCALSubmission::__set_resourceJobManager(const ResourceJobManager& val) {
  this->resourceJobManager = val;
}

const char* LOCALSubmission::ascii_fingerprint = "9237E82F3C6C8601C7B7AD6A6BBC347C";
const uint8_t LOCALSubmission::binary_fingerprint[16] = {0x92,0x37,0xE8,0x2F,0x3C,0x6C,0x86,0x01,0xC7,0xB7,0xAD,0x6A,0x6B,0xBC,0x34,0x7C};

uint32_t LOCALSubmission::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_jobSubmissionInterfaceId = false;
  bool isset_securityProtocol = false;
  bool isset_resourceJobManager = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->jobSubmissionInterfaceId);
          isset_jobSubmissionInterfaceId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast29;
          xfer += iprot->readI32(ecast29);
          this->securityProtocol = (SecurityProtocol::type)ecast29;
          isset_securityProtocol = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->resourceJobManager.read(iprot);
          isset_resourceJobManager = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_jobSubmissionInterfaceId)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_securityProtocol)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_resourceJobManager)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t LOCALSubmission::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  oprot->incrementRecursionDepth();
  xfer += oprot->writeStructBegin("LOCALSubmission");

  xfer += oprot->writeFieldBegin("jobSubmissionInterfaceId", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->jobSubmissionInterfaceId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("securityProtocol", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32((int32_t)this->securityProtocol);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("resourceJobManager", ::apache::thrift::protocol::T_STRUCT, 3);
  xfer += this->resourceJobManager.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  oprot->decrementRecursionDepth();
  return xfer;
}

void swap(LOCALSubmission &a, LOCALSubmission &b) {
  using ::std::swap;
  swap(a.jobSubmissionInterfaceId, b.jobSubmissionInterfaceId);
  swap(a.securityProtocol, b.securityProtocol);
  swap(a.resourceJobManager, b.resourceJobManager);
}

LOCALSubmission::LOCALSubmission(const LOCALSubmission& other30) {
  jobSubmissionInterfaceId = other30.jobSubmissionInterfaceId;
  securityProtocol = other30.securityProtocol;
  resourceJobManager = other30.resourceJobManager;
}
LOCALSubmission& LOCALSubmission::operator=(const LOCALSubmission& other31) {
  jobSubmissionInterfaceId = other31.jobSubmissionInterfaceId;
  securityProtocol = other31.securityProtocol;
  resourceJobManager = other31.resourceJobManager;
  return *this;
}
std::ostream& operator<<(std::ostream& out, const LOCALSubmission& obj) {
  using apache::thrift::to_string;
  out << "LOCALSubmission(";
  out << "jobSubmissionInterfaceId=" << to_string(obj.jobSubmissionInterfaceId);
  out << ", " << "securityProtocol=" << to_string(obj.securityProtocol);
  out << ", " << "resourceJobManager=" << to_string(obj.resourceJobManager);
  out << ")";
  return out;
}


LOCALDataMovement::~LOCALDataMovement() throw() {
}


void LOCALDataMovement::__set_dataMovementInterfaceId(const std::string& val) {
  this->dataMovementInterfaceId = val;
}

const char* LOCALDataMovement::ascii_fingerprint = "EFB929595D312AC8F305D5A794CFEDA1";
const uint8_t LOCALDataMovement::binary_fingerprint[16] = {0xEF,0xB9,0x29,0x59,0x5D,0x31,0x2A,0xC8,0xF3,0x05,0xD5,0xA7,0x94,0xCF,0xED,0xA1};

uint32_t LOCALDataMovement::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_dataMovementInterfaceId = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->dataMovementInterfaceId);
          isset_dataMovementInterfaceId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_dataMovementInterfaceId)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t LOCALDataMovement::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  oprot->incrementRecursionDepth();
  xfer += oprot->writeStructBegin("LOCALDataMovement");

  xfer += oprot->writeFieldBegin("dataMovementInterfaceId", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->dataMovementInterfaceId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  oprot->decrementRecursionDepth();
  return xfer;
}

void swap(LOCALDataMovement &a, LOCALDataMovement &b) {
  using ::std::swap;
  swap(a.dataMovementInterfaceId, b.dataMovementInterfaceId);
}

LOCALDataMovement::LOCALDataMovement(const LOCALDataMovement& other32) {
  dataMovementInterfaceId = other32.dataMovementInterfaceId;
}
LOCALDataMovement& LOCALDataMovement::operator=(const LOCALDataMovement& other33) {
  dataMovementInterfaceId = other33.dataMovementInterfaceId;
  return *this;
}
std::ostream& operator<<(std::ostream& out, const LOCALDataMovement& obj) {
  using apache::thrift::to_string;
  out << "LOCALDataMovement(";
  out << "dataMovementInterfaceId=" << to_string(obj.dataMovementInterfaceId);
  out << ")";
  return out;
}


SSHJobSubmission::~SSHJobSubmission() throw() {
}


void SSHJobSubmission::__set_jobSubmissionInterfaceId(const std::string& val) {
  this->jobSubmissionInterfaceId = val;
}

void SSHJobSubmission::__set_securityProtocol(const SecurityProtocol::type val) {
  this->securityProtocol = val;
}

void SSHJobSubmission::__set_resourceJobManager(const ResourceJobManager& val) {
  this->resourceJobManager = val;
}

void SSHJobSubmission::__set_alternativeSSHHostName(const std::string& val) {
  this->alternativeSSHHostName = val;
__isset.alternativeSSHHostName = true;
}

void SSHJobSubmission::__set_sshPort(const int32_t val) {
  this->sshPort = val;
__isset.sshPort = true;
}

void SSHJobSubmission::__set_monitorMode(const MonitorMode::type val) {
  this->monitorMode = val;
__isset.monitorMode = true;
}

void SSHJobSubmission::__set_batchQueueEmailSenders(const std::vector<std::string> & val) {
  this->batchQueueEmailSenders = val;
__isset.batchQueueEmailSenders = true;
}

const char* SSHJobSubmission::ascii_fingerprint = "46172F971809F7ECCCF7AB14291B87C6";
const uint8_t SSHJobSubmission::binary_fingerprint[16] = {0x46,0x17,0x2F,0x97,0x18,0x09,0xF7,0xEC,0xCC,0xF7,0xAB,0x14,0x29,0x1B,0x87,0xC6};

uint32_t SSHJobSubmission::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_jobSubmissionInterfaceId = false;
  bool isset_securityProtocol = false;
  bool isset_resourceJobManager = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->jobSubmissionInterfaceId);
          isset_jobSubmissionInterfaceId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast34;
          xfer += iprot->readI32(ecast34);
          this->securityProtocol = (SecurityProtocol::type)ecast34;
          isset_securityProtocol = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->resourceJobManager.read(iprot);
          isset_resourceJobManager = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->alternativeSSHHostName);
          this->__isset.alternativeSSHHostName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->sshPort);
          this->__isset.sshPort = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast35;
          xfer += iprot->readI32(ecast35);
          this->monitorMode = (MonitorMode::type)ecast35;
          this->__isset.monitorMode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->batchQueueEmailSenders.clear();
            uint32_t _size36;
            ::apache::thrift::protocol::TType _etype39;
            xfer += iprot->readListBegin(_etype39, _size36);
            this->batchQueueEmailSenders.resize(_size36);
            uint32_t _i40;
            for (_i40 = 0; _i40 < _size36; ++_i40)
            {
              xfer += iprot->readString(this->batchQueueEmailSenders[_i40]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.batchQueueEmailSenders = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_jobSubmissionInterfaceId)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_securityProtocol)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_resourceJobManager)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t SSHJobSubmission::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  oprot->incrementRecursionDepth();
  xfer += oprot->writeStructBegin("SSHJobSubmission");

  xfer += oprot->writeFieldBegin("jobSubmissionInterfaceId", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->jobSubmissionInterfaceId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("securityProtocol", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32((int32_t)this->securityProtocol);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("resourceJobManager", ::apache::thrift::protocol::T_STRUCT, 3);
  xfer += this->resourceJobManager.write(oprot);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.alternativeSSHHostName) {
    xfer += oprot->writeFieldBegin("alternativeSSHHostName", ::apache::thrift::protocol::T_STRING, 4);
    xfer += oprot->writeString(this->alternativeSSHHostName);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.sshPort) {
    xfer += oprot->writeFieldBegin("sshPort", ::apache::thrift::protocol::T_I32, 5);
    xfer += oprot->writeI32(this->sshPort);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.monitorMode) {
    xfer += oprot->writeFieldBegin("monitorMode", ::apache::thrift::protocol::T_I32, 6);
    xfer += oprot->writeI32((int32_t)this->monitorMode);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.batchQueueEmailSenders) {
    xfer += oprot->writeFieldBegin("batchQueueEmailSenders", ::apache::thrift::protocol::T_LIST, 7);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->batchQueueEmailSenders.size()));
      std::vector<std::string> ::const_iterator _iter41;
      for (_iter41 = this->batchQueueEmailSenders.begin(); _iter41 != this->batchQueueEmailSenders.end(); ++_iter41)
      {
        xfer += oprot->writeString((*_iter41));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  oprot->decrementRecursionDepth();
  return xfer;
}

void swap(SSHJobSubmission &a, SSHJobSubmission &b) {
  using ::std::swap;
  swap(a.jobSubmissionInterfaceId, b.jobSubmissionInterfaceId);
  swap(a.securityProtocol, b.securityProtocol);
  swap(a.resourceJobManager, b.resourceJobManager);
  swap(a.alternativeSSHHostName, b.alternativeSSHHostName);
  swap(a.sshPort, b.sshPort);
  swap(a.monitorMode, b.monitorMode);
  swap(a.batchQueueEmailSenders, b.batchQueueEmailSenders);
  swap(a.__isset, b.__isset);
}

SSHJobSubmission::SSHJobSubmission(const SSHJobSubmission& other42) {
  jobSubmissionInterfaceId = other42.jobSubmissionInterfaceId;
  securityProtocol = other42.securityProtocol;
  resourceJobManager = other42.resourceJobManager;
  alternativeSSHHostName = other42.alternativeSSHHostName;
  sshPort = other42.sshPort;
  monitorMode = other42.monitorMode;
  batchQueueEmailSenders = other42.batchQueueEmailSenders;
  __isset = other42.__isset;
}
SSHJobSubmission& SSHJobSubmission::operator=(const SSHJobSubmission& other43) {
  jobSubmissionInterfaceId = other43.jobSubmissionInterfaceId;
  securityProtocol = other43.securityProtocol;
  resourceJobManager = other43.resourceJobManager;
  alternativeSSHHostName = other43.alternativeSSHHostName;
  sshPort = other43.sshPort;
  monitorMode = other43.monitorMode;
  batchQueueEmailSenders = other43.batchQueueEmailSenders;
  __isset = other43.__isset;
  return *this;
}
std::ostream& operator<<(std::ostream& out, const SSHJobSubmission& obj) {
  using apache::thrift::to_string;
  out << "SSHJobSubmission(";
  out << "jobSubmissionInterfaceId=" << to_string(obj.jobSubmissionInterfaceId);
  out << ", " << "securityProtocol=" << to_string(obj.securityProtocol);
  out << ", " << "resourceJobManager=" << to_string(obj.resourceJobManager);
  out << ", " << "alternativeSSHHostName="; (obj.__isset.alternativeSSHHostName ? (out << to_string(obj.alternativeSSHHostName)) : (out << "<null>"));
  out << ", " << "sshPort="; (obj.__isset.sshPort ? (out << to_string(obj.sshPort)) : (out << "<null>"));
  out << ", " << "monitorMode="; (obj.__isset.monitorMode ? (out << to_string(obj.monitorMode)) : (out << "<null>"));
  out << ", " << "batchQueueEmailSenders="; (obj.__isset.batchQueueEmailSenders ? (out << to_string(obj.batchQueueEmailSenders)) : (out << "<null>"));
  out << ")";
  return out;
}


GlobusJobSubmission::~GlobusJobSubmission() throw() {
}


void GlobusJobSubmission::__set_jobSubmissionInterfaceId(const std::string& val) {
  this->jobSubmissionInterfaceId = val;
}

void GlobusJobSubmission::__set_securityProtocol(const SecurityProtocol::type val) {
  this->securityProtocol = val;
}

void GlobusJobSubmission::__set_globusGateKeeperEndPoint(const std::vector<std::string> & val) {
  this->globusGateKeeperEndPoint = val;
__isset.globusGateKeeperEndPoint = true;
}

const char* GlobusJobSubmission::ascii_fingerprint = "AF422FFD77BB68BA57079B8B33BC8CF7";
const uint8_t GlobusJobSubmission::binary_fingerprint[16] = {0xAF,0x42,0x2F,0xFD,0x77,0xBB,0x68,0xBA,0x57,0x07,0x9B,0x8B,0x33,0xBC,0x8C,0xF7};

uint32_t GlobusJobSubmission::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_jobSubmissionInterfaceId = false;
  bool isset_securityProtocol = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->jobSubmissionInterfaceId);
          isset_jobSubmissionInterfaceId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast44;
          xfer += iprot->readI32(ecast44);
          this->securityProtocol = (SecurityProtocol::type)ecast44;
          isset_securityProtocol = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->globusGateKeeperEndPoint.clear();
            uint32_t _size45;
            ::apache::thrift::protocol::TType _etype48;
            xfer += iprot->readListBegin(_etype48, _size45);
            this->globusGateKeeperEndPoint.resize(_size45);
            uint32_t _i49;
            for (_i49 = 0; _i49 < _size45; ++_i49)
            {
              xfer += iprot->readString(this->globusGateKeeperEndPoint[_i49]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.globusGateKeeperEndPoint = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_jobSubmissionInterfaceId)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_securityProtocol)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t GlobusJobSubmission::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  oprot->incrementRecursionDepth();
  xfer += oprot->writeStructBegin("GlobusJobSubmission");

  xfer += oprot->writeFieldBegin("jobSubmissionInterfaceId", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->jobSubmissionInterfaceId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("securityProtocol", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32((int32_t)this->securityProtocol);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.globusGateKeeperEndPoint) {
    xfer += oprot->writeFieldBegin("globusGateKeeperEndPoint", ::apache::thrift::protocol::T_LIST, 3);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->globusGateKeeperEndPoint.size()));
      std::vector<std::string> ::const_iterator _iter50;
      for (_iter50 = this->globusGateKeeperEndPoint.begin(); _iter50 != this->globusGateKeeperEndPoint.end(); ++_iter50)
      {
        xfer += oprot->writeString((*_iter50));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  oprot->decrementRecursionDepth();
  return xfer;
}

void swap(GlobusJobSubmission &a, GlobusJobSubmission &b) {
  using ::std::swap;
  swap(a.jobSubmissionInterfaceId, b.jobSubmissionInterfaceId);
  swap(a.securityProtocol, b.securityProtocol);
  swap(a.globusGateKeeperEndPoint, b.globusGateKeeperEndPoint);
  swap(a.__isset, b.__isset);
}

GlobusJobSubmission::GlobusJobSubmission(const GlobusJobSubmission& other51) {
  jobSubmissionInterfaceId = other51.jobSubmissionInterfaceId;
  securityProtocol = other51.securityProtocol;
  globusGateKeeperEndPoint = other51.globusGateKeeperEndPoint;
  __isset = other51.__isset;
}
GlobusJobSubmission& GlobusJobSubmission::operator=(const GlobusJobSubmission& other52) {
  jobSubmissionInterfaceId = other52.jobSubmissionInterfaceId;
  securityProtocol = other52.securityProtocol;
  globusGateKeeperEndPoint = other52.globusGateKeeperEndPoint;
  __isset = other52.__isset;
  return *this;
}
std::ostream& operator<<(std::ostream& out, const GlobusJobSubmission& obj) {
  using apache::thrift::to_string;
  out << "GlobusJobSubmission(";
  out << "jobSubmissionInterfaceId=" << to_string(obj.jobSubmissionInterfaceId);
  out << ", " << "securityProtocol=" << to_string(obj.securityProtocol);
  out << ", " << "globusGateKeeperEndPoint="; (obj.__isset.globusGateKeeperEndPoint ? (out << to_string(obj.globusGateKeeperEndPoint)) : (out << "<null>"));
  out << ")";
  return out;
}


UnicoreJobSubmission::~UnicoreJobSubmission() throw() {
}


void UnicoreJobSubmission::__set_jobSubmissionInterfaceId(const std::string& val) {
  this->jobSubmissionInterfaceId = val;
}

void UnicoreJobSubmission::__set_securityProtocol(const SecurityProtocol::type val) {
  this->securityProtocol = val;
}

void UnicoreJobSubmission::__set_unicoreEndPointURL(const std::string& val) {
  this->unicoreEndPointURL = val;
}

const char* UnicoreJobSubmission::ascii_fingerprint = "D9F4CFE2F293A8B1052FD3031DD2C847";
const uint8_t UnicoreJobSubmission::binary_fingerprint[16] = {0xD9,0xF4,0xCF,0xE2,0xF2,0x93,0xA8,0xB1,0x05,0x2F,0xD3,0x03,0x1D,0xD2,0xC8,0x47};

uint32_t UnicoreJobSubmission::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_jobSubmissionInterfaceId = false;
  bool isset_securityProtocol = false;
  bool isset_unicoreEndPointURL = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->jobSubmissionInterfaceId);
          isset_jobSubmissionInterfaceId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast53;
          xfer += iprot->readI32(ecast53);
          this->securityProtocol = (SecurityProtocol::type)ecast53;
          isset_securityProtocol = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->unicoreEndPointURL);
          isset_unicoreEndPointURL = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_jobSubmissionInterfaceId)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_securityProtocol)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_unicoreEndPointURL)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t UnicoreJobSubmission::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  oprot->incrementRecursionDepth();
  xfer += oprot->writeStructBegin("UnicoreJobSubmission");

  xfer += oprot->writeFieldBegin("jobSubmissionInterfaceId", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->jobSubmissionInterfaceId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("securityProtocol", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32((int32_t)this->securityProtocol);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("unicoreEndPointURL", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->unicoreEndPointURL);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  oprot->decrementRecursionDepth();
  return xfer;
}

void swap(UnicoreJobSubmission &a, UnicoreJobSubmission &b) {
  using ::std::swap;
  swap(a.jobSubmissionInterfaceId, b.jobSubmissionInterfaceId);
  swap(a.securityProtocol, b.securityProtocol);
  swap(a.unicoreEndPointURL, b.unicoreEndPointURL);
}

UnicoreJobSubmission::UnicoreJobSubmission(const UnicoreJobSubmission& other54) {
  jobSubmissionInterfaceId = other54.jobSubmissionInterfaceId;
  securityProtocol = other54.securityProtocol;
  unicoreEndPointURL = other54.unicoreEndPointURL;
}
UnicoreJobSubmission& UnicoreJobSubmission::operator=(const UnicoreJobSubmission& other55) {
  jobSubmissionInterfaceId = other55.jobSubmissionInterfaceId;
  securityProtocol = other55.securityProtocol;
  unicoreEndPointURL = other55.unicoreEndPointURL;
  return *this;
}
std::ostream& operator<<(std::ostream& out, const UnicoreJobSubmission& obj) {
  using apache::thrift::to_string;
  out << "UnicoreJobSubmission(";
  out << "jobSubmissionInterfaceId=" << to_string(obj.jobSubmissionInterfaceId);
  out << ", " << "securityProtocol=" << to_string(obj.securityProtocol);
  out << ", " << "unicoreEndPointURL=" << to_string(obj.unicoreEndPointURL);
  out << ")";
  return out;
}


CloudJobSubmission::~CloudJobSubmission() throw() {
}


void CloudJobSubmission::__set_jobSubmissionInterfaceId(const std::string& val) {
  this->jobSubmissionInterfaceId = val;
}

void CloudJobSubmission::__set_securityProtocol(const SecurityProtocol::type val) {
  this->securityProtocol = val;
}

void CloudJobSubmission::__set_nodeId(const std::string& val) {
  this->nodeId = val;
}

void CloudJobSubmission::__set_executableType(const std::string& val) {
  this->executableType = val;
}

void CloudJobSubmission::__set_providerName(const ProviderName::type val) {
  this->providerName = val;
}

void CloudJobSubmission::__set_userAccountName(const std::string& val) {
  this->userAccountName = val;
}

const char* CloudJobSubmission::ascii_fingerprint = "F98AE2E6E51F2426504F2566EB71B5CC";
const uint8_t CloudJobSubmission::binary_fingerprint[16] = {0xF9,0x8A,0xE2,0xE6,0xE5,0x1F,0x24,0x26,0x50,0x4F,0x25,0x66,0xEB,0x71,0xB5,0xCC};

uint32_t CloudJobSubmission::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_jobSubmissionInterfaceId = false;
  bool isset_securityProtocol = false;
  bool isset_nodeId = false;
  bool isset_executableType = false;
  bool isset_providerName = false;
  bool isset_userAccountName = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->jobSubmissionInterfaceId);
          isset_jobSubmissionInterfaceId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast56;
          xfer += iprot->readI32(ecast56);
          this->securityProtocol = (SecurityProtocol::type)ecast56;
          isset_securityProtocol = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->nodeId);
          isset_nodeId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->executableType);
          isset_executableType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast57;
          xfer += iprot->readI32(ecast57);
          this->providerName = (ProviderName::type)ecast57;
          isset_providerName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->userAccountName);
          isset_userAccountName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_jobSubmissionInterfaceId)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_securityProtocol)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_nodeId)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_executableType)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_providerName)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_userAccountName)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t CloudJobSubmission::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  oprot->incrementRecursionDepth();
  xfer += oprot->writeStructBegin("CloudJobSubmission");

  xfer += oprot->writeFieldBegin("jobSubmissionInterfaceId", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->jobSubmissionInterfaceId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("securityProtocol", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32((int32_t)this->securityProtocol);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("nodeId", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->nodeId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("executableType", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString(this->executableType);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("providerName", ::apache::thrift::protocol::T_I32, 5);
  xfer += oprot->writeI32((int32_t)this->providerName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("userAccountName", ::apache::thrift::protocol::T_STRING, 6);
  xfer += oprot->writeString(this->userAccountName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  oprot->decrementRecursionDepth();
  return xfer;
}

void swap(CloudJobSubmission &a, CloudJobSubmission &b) {
  using ::std::swap;
  swap(a.jobSubmissionInterfaceId, b.jobSubmissionInterfaceId);
  swap(a.securityProtocol, b.securityProtocol);
  swap(a.nodeId, b.nodeId);
  swap(a.executableType, b.executableType);
  swap(a.providerName, b.providerName);
  swap(a.userAccountName, b.userAccountName);
}

CloudJobSubmission::CloudJobSubmission(const CloudJobSubmission& other58) {
  jobSubmissionInterfaceId = other58.jobSubmissionInterfaceId;
  securityProtocol = other58.securityProtocol;
  nodeId = other58.nodeId;
  executableType = other58.executableType;
  providerName = other58.providerName;
  userAccountName = other58.userAccountName;
}
CloudJobSubmission& CloudJobSubmission::operator=(const CloudJobSubmission& other59) {
  jobSubmissionInterfaceId = other59.jobSubmissionInterfaceId;
  securityProtocol = other59.securityProtocol;
  nodeId = other59.nodeId;
  executableType = other59.executableType;
  providerName = other59.providerName;
  userAccountName = other59.userAccountName;
  return *this;
}
std::ostream& operator<<(std::ostream& out, const CloudJobSubmission& obj) {
  using apache::thrift::to_string;
  out << "CloudJobSubmission(";
  out << "jobSubmissionInterfaceId=" << to_string(obj.jobSubmissionInterfaceId);
  out << ", " << "securityProtocol=" << to_string(obj.securityProtocol);
  out << ", " << "nodeId=" << to_string(obj.nodeId);
  out << ", " << "executableType=" << to_string(obj.executableType);
  out << ", " << "providerName=" << to_string(obj.providerName);
  out << ", " << "userAccountName=" << to_string(obj.userAccountName);
  out << ")";
  return out;
}


JobSubmissionInterface::~JobSubmissionInterface() throw() {
}


void JobSubmissionInterface::__set_jobSubmissionInterfaceId(const std::string& val) {
  this->jobSubmissionInterfaceId = val;
}

void JobSubmissionInterface::__set_jobSubmissionProtocol(const JobSubmissionProtocol::type val) {
  this->jobSubmissionProtocol = val;
}

void JobSubmissionInterface::__set_priorityOrder(const int32_t val) {
  this->priorityOrder = val;
}

const char* JobSubmissionInterface::ascii_fingerprint = "A0A4DD7B8243FB842E64EAC6E5DA6C7B";
const uint8_t JobSubmissionInterface::binary_fingerprint[16] = {0xA0,0xA4,0xDD,0x7B,0x82,0x43,0xFB,0x84,0x2E,0x64,0xEA,0xC6,0xE5,0xDA,0x6C,0x7B};

uint32_t JobSubmissionInterface::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_jobSubmissionInterfaceId = false;
  bool isset_jobSubmissionProtocol = false;
  bool isset_priorityOrder = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->jobSubmissionInterfaceId);
          isset_jobSubmissionInterfaceId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast60;
          xfer += iprot->readI32(ecast60);
          this->jobSubmissionProtocol = (JobSubmissionProtocol::type)ecast60;
          isset_jobSubmissionProtocol = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->priorityOrder);
          isset_priorityOrder = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_jobSubmissionInterfaceId)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_jobSubmissionProtocol)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_priorityOrder)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t JobSubmissionInterface::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  oprot->incrementRecursionDepth();
  xfer += oprot->writeStructBegin("JobSubmissionInterface");

  xfer += oprot->writeFieldBegin("jobSubmissionInterfaceId", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->jobSubmissionInterfaceId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("jobSubmissionProtocol", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32((int32_t)this->jobSubmissionProtocol);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("priorityOrder", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32(this->priorityOrder);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  oprot->decrementRecursionDepth();
  return xfer;
}

void swap(JobSubmissionInterface &a, JobSubmissionInterface &b) {
  using ::std::swap;
  swap(a.jobSubmissionInterfaceId, b.jobSubmissionInterfaceId);
  swap(a.jobSubmissionProtocol, b.jobSubmissionProtocol);
  swap(a.priorityOrder, b.priorityOrder);
}

JobSubmissionInterface::JobSubmissionInterface(const JobSubmissionInterface& other61) {
  jobSubmissionInterfaceId = other61.jobSubmissionInterfaceId;
  jobSubmissionProtocol = other61.jobSubmissionProtocol;
  priorityOrder = other61.priorityOrder;
}
JobSubmissionInterface& JobSubmissionInterface::operator=(const JobSubmissionInterface& other62) {
  jobSubmissionInterfaceId = other62.jobSubmissionInterfaceId;
  jobSubmissionProtocol = other62.jobSubmissionProtocol;
  priorityOrder = other62.priorityOrder;
  return *this;
}
std::ostream& operator<<(std::ostream& out, const JobSubmissionInterface& obj) {
  using apache::thrift::to_string;
  out << "JobSubmissionInterface(";
  out << "jobSubmissionInterfaceId=" << to_string(obj.jobSubmissionInterfaceId);
  out << ", " << "jobSubmissionProtocol=" << to_string(obj.jobSubmissionProtocol);
  out << ", " << "priorityOrder=" << to_string(obj.priorityOrder);
  out << ")";
  return out;
}


DataMovementInterface::~DataMovementInterface() throw() {
}


void DataMovementInterface::__set_dataMovementInterfaceId(const std::string& val) {
  this->dataMovementInterfaceId = val;
}

void DataMovementInterface::__set_dataMovementProtocol(const DataMovementProtocol::type val) {
  this->dataMovementProtocol = val;
}

void DataMovementInterface::__set_priorityOrder(const int32_t val) {
  this->priorityOrder = val;
}

const char* DataMovementInterface::ascii_fingerprint = "A0A4DD7B8243FB842E64EAC6E5DA6C7B";
const uint8_t DataMovementInterface::binary_fingerprint[16] = {0xA0,0xA4,0xDD,0x7B,0x82,0x43,0xFB,0x84,0x2E,0x64,0xEA,0xC6,0xE5,0xDA,0x6C,0x7B};

uint32_t DataMovementInterface::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_dataMovementInterfaceId = false;
  bool isset_dataMovementProtocol = false;
  bool isset_priorityOrder = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->dataMovementInterfaceId);
          isset_dataMovementInterfaceId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast63;
          xfer += iprot->readI32(ecast63);
          this->dataMovementProtocol = (DataMovementProtocol::type)ecast63;
          isset_dataMovementProtocol = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->priorityOrder);
          isset_priorityOrder = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_dataMovementInterfaceId)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_dataMovementProtocol)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_priorityOrder)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t DataMovementInterface::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  oprot->incrementRecursionDepth();
  xfer += oprot->writeStructBegin("DataMovementInterface");

  xfer += oprot->writeFieldBegin("dataMovementInterfaceId", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->dataMovementInterfaceId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("dataMovementProtocol", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32((int32_t)this->dataMovementProtocol);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("priorityOrder", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32(this->priorityOrder);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  oprot->decrementRecursionDepth();
  return xfer;
}

void swap(DataMovementInterface &a, DataMovementInterface &b) {
  using ::std::swap;
  swap(a.dataMovementInterfaceId, b.dataMovementInterfaceId);
  swap(a.dataMovementProtocol, b.dataMovementProtocol);
  swap(a.priorityOrder, b.priorityOrder);
}

DataMovementInterface::DataMovementInterface(const DataMovementInterface& other64) {
  dataMovementInterfaceId = other64.dataMovementInterfaceId;
  dataMovementProtocol = other64.dataMovementProtocol;
  priorityOrder = other64.priorityOrder;
}
DataMovementInterface& DataMovementInterface::operator=(const DataMovementInterface& other65) {
  dataMovementInterfaceId = other65.dataMovementInterfaceId;
  dataMovementProtocol = other65.dataMovementProtocol;
  priorityOrder = other65.priorityOrder;
  return *this;
}
std::ostream& operator<<(std::ostream& out, const DataMovementInterface& obj) {
  using apache::thrift::to_string;
  out << "DataMovementInterface(";
  out << "dataMovementInterfaceId=" << to_string(obj.dataMovementInterfaceId);
  out << ", " << "dataMovementProtocol=" << to_string(obj.dataMovementProtocol);
  out << ", " << "priorityOrder=" << to_string(obj.priorityOrder);
  out << ")";
  return out;
}


ComputeResourceDescription::~ComputeResourceDescription() throw() {
}


void ComputeResourceDescription::__set_computeResourceId(const std::string& val) {
  this->computeResourceId = val;
}

void ComputeResourceDescription::__set_hostName(const std::string& val) {
  this->hostName = val;
}

void ComputeResourceDescription::__set_hostAliases(const std::vector<std::string> & val) {
  this->hostAliases = val;
__isset.hostAliases = true;
}

void ComputeResourceDescription::__set_ipAddresses(const std::vector<std::string> & val) {
  this->ipAddresses = val;
__isset.ipAddresses = true;
}

void ComputeResourceDescription::__set_resourceDescription(const std::string& val) {
  this->resourceDescription = val;
__isset.resourceDescription = true;
}

void ComputeResourceDescription::__set_enabled(const bool val) {
  this->enabled = val;
__isset.enabled = true;
}

void ComputeResourceDescription::__set_batchQueues(const std::vector<BatchQueue> & val) {
  this->batchQueues = val;
__isset.batchQueues = true;
}

void ComputeResourceDescription::__set_fileSystems(const std::map<FileSystems::type, std::string> & val) {
  this->fileSystems = val;
__isset.fileSystems = true;
}

void ComputeResourceDescription::__set_jobSubmissionInterfaces(const std::vector<JobSubmissionInterface> & val) {
  this->jobSubmissionInterfaces = val;
__isset.jobSubmissionInterfaces = true;
}

void ComputeResourceDescription::__set_dataMovementInterfaces(const std::vector<DataMovementInterface> & val) {
  this->dataMovementInterfaces = val;
__isset.dataMovementInterfaces = true;
}

void ComputeResourceDescription::__set_maxMemoryPerNode(const int32_t val) {
  this->maxMemoryPerNode = val;
__isset.maxMemoryPerNode = true;
}

const char* ComputeResourceDescription::ascii_fingerprint = "FEBE7045EBC701802205EA9BA436FCE2";
const uint8_t ComputeResourceDescription::binary_fingerprint[16] = {0xFE,0xBE,0x70,0x45,0xEB,0xC7,0x01,0x80,0x22,0x05,0xEA,0x9B,0xA4,0x36,0xFC,0xE2};

uint32_t ComputeResourceDescription::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_computeResourceId = false;
  bool isset_hostName = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->computeResourceId);
          isset_computeResourceId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->hostName);
          isset_hostName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->hostAliases.clear();
            uint32_t _size66;
            ::apache::thrift::protocol::TType _etype69;
            xfer += iprot->readListBegin(_etype69, _size66);
            this->hostAliases.resize(_size66);
            uint32_t _i70;
            for (_i70 = 0; _i70 < _size66; ++_i70)
            {
              xfer += iprot->readString(this->hostAliases[_i70]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.hostAliases = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->ipAddresses.clear();
            uint32_t _size71;
            ::apache::thrift::protocol::TType _etype74;
            xfer += iprot->readListBegin(_etype74, _size71);
            this->ipAddresses.resize(_size71);
            uint32_t _i75;
            for (_i75 = 0; _i75 < _size71; ++_i75)
            {
              xfer += iprot->readString(this->ipAddresses[_i75]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.ipAddresses = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->resourceDescription);
          this->__isset.resourceDescription = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->enabled);
          this->__isset.enabled = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->batchQueues.clear();
            uint32_t _size76;
            ::apache::thrift::protocol::TType _etype79;
            xfer += iprot->readListBegin(_etype79, _size76);
            this->batchQueues.resize(_size76);
            uint32_t _i80;
            for (_i80 = 0; _i80 < _size76; ++_i80)
            {
              xfer += this->batchQueues[_i80].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.batchQueues = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->fileSystems.clear();
            uint32_t _size81;
            ::apache::thrift::protocol::TType _ktype82;
            ::apache::thrift::protocol::TType _vtype83;
            xfer += iprot->readMapBegin(_ktype82, _vtype83, _size81);
            uint32_t _i85;
            for (_i85 = 0; _i85 < _size81; ++_i85)
            {
              FileSystems::type _key86;
              int32_t ecast88;
              xfer += iprot->readI32(ecast88);
              _key86 = (FileSystems::type)ecast88;
              std::string& _val87 = this->fileSystems[_key86];
              xfer += iprot->readString(_val87);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.fileSystems = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->jobSubmissionInterfaces.clear();
            uint32_t _size89;
            ::apache::thrift::protocol::TType _etype92;
            xfer += iprot->readListBegin(_etype92, _size89);
            this->jobSubmissionInterfaces.resize(_size89);
            uint32_t _i93;
            for (_i93 = 0; _i93 < _size89; ++_i93)
            {
              xfer += this->jobSubmissionInterfaces[_i93].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.jobSubmissionInterfaces = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->dataMovementInterfaces.clear();
            uint32_t _size94;
            ::apache::thrift::protocol::TType _etype97;
            xfer += iprot->readListBegin(_etype97, _size94);
            this->dataMovementInterfaces.resize(_size94);
            uint32_t _i98;
            for (_i98 = 0; _i98 < _size94; ++_i98)
            {
              xfer += this->dataMovementInterfaces[_i98].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.dataMovementInterfaces = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 11:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->maxMemoryPerNode);
          this->__isset.maxMemoryPerNode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_computeResourceId)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_hostName)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t ComputeResourceDescription::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  oprot->incrementRecursionDepth();
  xfer += oprot->writeStructBegin("ComputeResourceDescription");

  xfer += oprot->writeFieldBegin("computeResourceId", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->computeResourceId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("hostName", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->hostName);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.hostAliases) {
    xfer += oprot->writeFieldBegin("hostAliases", ::apache::thrift::protocol::T_LIST, 3);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->hostAliases.size()));
      std::vector<std::string> ::const_iterator _iter99;
      for (_iter99 = this->hostAliases.begin(); _iter99 != this->hostAliases.end(); ++_iter99)
      {
        xfer += oprot->writeString((*_iter99));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.ipAddresses) {
    xfer += oprot->writeFieldBegin("ipAddresses", ::apache::thrift::protocol::T_LIST, 4);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->ipAddresses.size()));
      std::vector<std::string> ::const_iterator _iter100;
      for (_iter100 = this->ipAddresses.begin(); _iter100 != this->ipAddresses.end(); ++_iter100)
      {
        xfer += oprot->writeString((*_iter100));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.resourceDescription) {
    xfer += oprot->writeFieldBegin("resourceDescription", ::apache::thrift::protocol::T_STRING, 5);
    xfer += oprot->writeString(this->resourceDescription);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.enabled) {
    xfer += oprot->writeFieldBegin("enabled", ::apache::thrift::protocol::T_BOOL, 6);
    xfer += oprot->writeBool(this->enabled);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.batchQueues) {
    xfer += oprot->writeFieldBegin("batchQueues", ::apache::thrift::protocol::T_LIST, 7);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->batchQueues.size()));
      std::vector<BatchQueue> ::const_iterator _iter101;
      for (_iter101 = this->batchQueues.begin(); _iter101 != this->batchQueues.end(); ++_iter101)
      {
        xfer += (*_iter101).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.fileSystems) {
    xfer += oprot->writeFieldBegin("fileSystems", ::apache::thrift::protocol::T_MAP, 8);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_I32, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->fileSystems.size()));
      std::map<FileSystems::type, std::string> ::const_iterator _iter102;
      for (_iter102 = this->fileSystems.begin(); _iter102 != this->fileSystems.end(); ++_iter102)
      {
        xfer += oprot->writeI32((int32_t)_iter102->first);
        xfer += oprot->writeString(_iter102->second);
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.jobSubmissionInterfaces) {
    xfer += oprot->writeFieldBegin("jobSubmissionInterfaces", ::apache::thrift::protocol::T_LIST, 9);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->jobSubmissionInterfaces.size()));
      std::vector<JobSubmissionInterface> ::const_iterator _iter103;
      for (_iter103 = this->jobSubmissionInterfaces.begin(); _iter103 != this->jobSubmissionInterfaces.end(); ++_iter103)
      {
        xfer += (*_iter103).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.dataMovementInterfaces) {
    xfer += oprot->writeFieldBegin("dataMovementInterfaces", ::apache::thrift::protocol::T_LIST, 10);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->dataMovementInterfaces.size()));
      std::vector<DataMovementInterface> ::const_iterator _iter104;
      for (_iter104 = this->dataMovementInterfaces.begin(); _iter104 != this->dataMovementInterfaces.end(); ++_iter104)
      {
        xfer += (*_iter104).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.maxMemoryPerNode) {
    xfer += oprot->writeFieldBegin("maxMemoryPerNode", ::apache::thrift::protocol::T_I32, 11);
    xfer += oprot->writeI32(this->maxMemoryPerNode);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  oprot->decrementRecursionDepth();
  return xfer;
}

void swap(ComputeResourceDescription &a, ComputeResourceDescription &b) {
  using ::std::swap;
  swap(a.computeResourceId, b.computeResourceId);
  swap(a.hostName, b.hostName);
  swap(a.hostAliases, b.hostAliases);
  swap(a.ipAddresses, b.ipAddresses);
  swap(a.resourceDescription, b.resourceDescription);
  swap(a.enabled, b.enabled);
  swap(a.batchQueues, b.batchQueues);
  swap(a.fileSystems, b.fileSystems);
  swap(a.jobSubmissionInterfaces, b.jobSubmissionInterfaces);
  swap(a.dataMovementInterfaces, b.dataMovementInterfaces);
  swap(a.maxMemoryPerNode, b.maxMemoryPerNode);
  swap(a.__isset, b.__isset);
}

ComputeResourceDescription::ComputeResourceDescription(const ComputeResourceDescription& other105) {
  computeResourceId = other105.computeResourceId;
  hostName = other105.hostName;
  hostAliases = other105.hostAliases;
  ipAddresses = other105.ipAddresses;
  resourceDescription = other105.resourceDescription;
  enabled = other105.enabled;
  batchQueues = other105.batchQueues;
  fileSystems = other105.fileSystems;
  jobSubmissionInterfaces = other105.jobSubmissionInterfaces;
  dataMovementInterfaces = other105.dataMovementInterfaces;
  maxMemoryPerNode = other105.maxMemoryPerNode;
  __isset = other105.__isset;
}
ComputeResourceDescription& ComputeResourceDescription::operator=(const ComputeResourceDescription& other106) {
  computeResourceId = other106.computeResourceId;
  hostName = other106.hostName;
  hostAliases = other106.hostAliases;
  ipAddresses = other106.ipAddresses;
  resourceDescription = other106.resourceDescription;
  enabled = other106.enabled;
  batchQueues = other106.batchQueues;
  fileSystems = other106.fileSystems;
  jobSubmissionInterfaces = other106.jobSubmissionInterfaces;
  dataMovementInterfaces = other106.dataMovementInterfaces;
  maxMemoryPerNode = other106.maxMemoryPerNode;
  __isset = other106.__isset;
  return *this;
}
std::ostream& operator<<(std::ostream& out, const ComputeResourceDescription& obj) {
  using apache::thrift::to_string;
  out << "ComputeResourceDescription(";
  out << "computeResourceId=" << to_string(obj.computeResourceId);
  out << ", " << "hostName=" << to_string(obj.hostName);
  out << ", " << "hostAliases="; (obj.__isset.hostAliases ? (out << to_string(obj.hostAliases)) : (out << "<null>"));
  out << ", " << "ipAddresses="; (obj.__isset.ipAddresses ? (out << to_string(obj.ipAddresses)) : (out << "<null>"));
  out << ", " << "resourceDescription="; (obj.__isset.resourceDescription ? (out << to_string(obj.resourceDescription)) : (out << "<null>"));
  out << ", " << "enabled="; (obj.__isset.enabled ? (out << to_string(obj.enabled)) : (out << "<null>"));
  out << ", " << "batchQueues="; (obj.__isset.batchQueues ? (out << to_string(obj.batchQueues)) : (out << "<null>"));
  out << ", " << "fileSystems="; (obj.__isset.fileSystems ? (out << to_string(obj.fileSystems)) : (out << "<null>"));
  out << ", " << "jobSubmissionInterfaces="; (obj.__isset.jobSubmissionInterfaces ? (out << to_string(obj.jobSubmissionInterfaces)) : (out << "<null>"));
  out << ", " << "dataMovementInterfaces="; (obj.__isset.dataMovementInterfaces ? (out << to_string(obj.dataMovementInterfaces)) : (out << "<null>"));
  out << ", " << "maxMemoryPerNode="; (obj.__isset.maxMemoryPerNode ? (out << to_string(obj.maxMemoryPerNode)) : (out << "<null>"));
  out << ")";
  return out;
}

}}}}} // namespace
