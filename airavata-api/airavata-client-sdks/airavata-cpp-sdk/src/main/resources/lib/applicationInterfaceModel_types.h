/**
 * Autogenerated by Thrift Compiler (0.9.1)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#ifndef applicationInterfaceModel_TYPES_H
#define applicationInterfaceModel_TYPES_H

#include <thrift/Thrift.h>
#include <thrift/TApplicationException.h>
#include <thrift/protocol/TProtocol.h>
#include <thrift/transport/TTransport.h>

#include <thrift/cxxfunctional.h>




struct DataType {
  enum type {
    STRING = 0,
    INTEGER = 1,
    FLOAT = 2,
    URI = 3
  };
};

extern const std::map<int, const char*> _DataType_VALUES_TO_NAMES;

typedef struct _InputDataObjectType__isset {
  _InputDataObjectType__isset() : value(false), type(false), applicationArguement(false), standardInput(true), userFriendlyDescription(false), metaData(false) {}
  bool value;
  bool type;
  bool applicationArguement;
  bool standardInput;
  bool userFriendlyDescription;
  bool metaData;
} _InputDataObjectType__isset;

class InputDataObjectType {
 public:

  static const char* ascii_fingerprint; // = "0C147F4C4DFD0B9FF70275BF29D07281";
  static const uint8_t binary_fingerprint[16]; // = {0x0C,0x14,0x7F,0x4C,0x4D,0xFD,0x0B,0x9F,0xF7,0x02,0x75,0xBF,0x29,0xD0,0x72,0x81};

  InputDataObjectType() : isEmpty(false), name(), value(), type((DataType::type)0), applicationArguement(), standardInput(false), userFriendlyDescription(), metaData() {
  }

  virtual ~InputDataObjectType() throw() {}

  bool isEmpty;
  std::string name;
  std::string value;
  DataType::type type;
  std::string applicationArguement;
  bool standardInput;
  std::string userFriendlyDescription;
  std::string metaData;

  _InputDataObjectType__isset __isset;

  void __set_isEmpty(const bool val) {
    isEmpty = val;
  }

  void __set_name(const std::string& val) {
    name = val;
  }

  void __set_value(const std::string& val) {
    value = val;
    __isset.value = true;
  }

  void __set_type(const DataType::type val) {
    type = val;
    __isset.type = true;
  }

  void __set_applicationArguement(const std::string& val) {
    applicationArguement = val;
    __isset.applicationArguement = true;
  }

  void __set_standardInput(const bool val) {
    standardInput = val;
    __isset.standardInput = true;
  }

  void __set_userFriendlyDescription(const std::string& val) {
    userFriendlyDescription = val;
    __isset.userFriendlyDescription = true;
  }

  void __set_metaData(const std::string& val) {
    metaData = val;
    __isset.metaData = true;
  }

  bool operator == (const InputDataObjectType & rhs) const
  {
    if (!(isEmpty == rhs.isEmpty))
      return false;
    if (!(name == rhs.name))
      return false;
    if (__isset.value != rhs.__isset.value)
      return false;
    else if (__isset.value && !(value == rhs.value))
      return false;
    if (__isset.type != rhs.__isset.type)
      return false;
    else if (__isset.type && !(type == rhs.type))
      return false;
    if (__isset.applicationArguement != rhs.__isset.applicationArguement)
      return false;
    else if (__isset.applicationArguement && !(applicationArguement == rhs.applicationArguement))
      return false;
    if (__isset.standardInput != rhs.__isset.standardInput)
      return false;
    else if (__isset.standardInput && !(standardInput == rhs.standardInput))
      return false;
    if (__isset.userFriendlyDescription != rhs.__isset.userFriendlyDescription)
      return false;
    else if (__isset.userFriendlyDescription && !(userFriendlyDescription == rhs.userFriendlyDescription))
      return false;
    if (__isset.metaData != rhs.__isset.metaData)
      return false;
    else if (__isset.metaData && !(metaData == rhs.metaData))
      return false;
    return true;
  }
  bool operator != (const InputDataObjectType &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const InputDataObjectType & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(InputDataObjectType &a, InputDataObjectType &b);

typedef struct _OutputDataObjectType__isset {
  _OutputDataObjectType__isset() : value(false), type(false) {}
  bool value;
  bool type;
} _OutputDataObjectType__isset;

class OutputDataObjectType {
 public:

  static const char* ascii_fingerprint; // = "FFD96F45C68610A5AC6E843C512B01EC";
  static const uint8_t binary_fingerprint[16]; // = {0xFF,0xD9,0x6F,0x45,0xC6,0x86,0x10,0xA5,0xAC,0x6E,0x84,0x3C,0x51,0x2B,0x01,0xEC};

  OutputDataObjectType() : isEmpty(false), name(), value(), type((DataType::type)0) {
  }

  virtual ~OutputDataObjectType() throw() {}

  bool isEmpty;
  std::string name;
  std::string value;
  DataType::type type;

  _OutputDataObjectType__isset __isset;

  void __set_isEmpty(const bool val) {
    isEmpty = val;
  }

  void __set_name(const std::string& val) {
    name = val;
  }

  void __set_value(const std::string& val) {
    value = val;
    __isset.value = true;
  }

  void __set_type(const DataType::type val) {
    type = val;
    __isset.type = true;
  }

  bool operator == (const OutputDataObjectType & rhs) const
  {
    if (!(isEmpty == rhs.isEmpty))
      return false;
    if (!(name == rhs.name))
      return false;
    if (__isset.value != rhs.__isset.value)
      return false;
    else if (__isset.value && !(value == rhs.value))
      return false;
    if (__isset.type != rhs.__isset.type)
      return false;
    else if (__isset.type && !(type == rhs.type))
      return false;
    return true;
  }
  bool operator != (const OutputDataObjectType &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const OutputDataObjectType & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(OutputDataObjectType &a, OutputDataObjectType &b);

typedef struct _ApplicationInterfaceDescription__isset {
  _ApplicationInterfaceDescription__isset() : applicationModules(false), applicationInputs(false), applicationOutputs(false) {}
  bool applicationModules;
  bool applicationInputs;
  bool applicationOutputs;
} _ApplicationInterfaceDescription__isset;

class ApplicationInterfaceDescription {
 public:

  static const char* ascii_fingerprint; // = "EF5E3A4F34CCD8942A56C19B7B92E473";
  static const uint8_t binary_fingerprint[16]; // = {0xEF,0x5E,0x3A,0x4F,0x34,0xCC,0xD8,0x94,0x2A,0x56,0xC1,0x9B,0x7B,0x92,0xE4,0x73};

  ApplicationInterfaceDescription() : isEmpty(false), applicationInterfaceId("DO_NOT_SET_AT_CLIENTS"), applicationName() {
  }

  virtual ~ApplicationInterfaceDescription() throw() {}

  bool isEmpty;
  std::string applicationInterfaceId;
  std::string applicationName;
  std::vector<std::string>  applicationModules;
  std::vector<InputDataObjectType>  applicationInputs;
  std::vector<OutputDataObjectType>  applicationOutputs;

  _ApplicationInterfaceDescription__isset __isset;

  void __set_isEmpty(const bool val) {
    isEmpty = val;
  }

  void __set_applicationInterfaceId(const std::string& val) {
    applicationInterfaceId = val;
  }

  void __set_applicationName(const std::string& val) {
    applicationName = val;
  }

  void __set_applicationModules(const std::vector<std::string> & val) {
    applicationModules = val;
    __isset.applicationModules = true;
  }

  void __set_applicationInputs(const std::vector<InputDataObjectType> & val) {
    applicationInputs = val;
    __isset.applicationInputs = true;
  }

  void __set_applicationOutputs(const std::vector<OutputDataObjectType> & val) {
    applicationOutputs = val;
    __isset.applicationOutputs = true;
  }

  bool operator == (const ApplicationInterfaceDescription & rhs) const
  {
    if (!(isEmpty == rhs.isEmpty))
      return false;
    if (!(applicationInterfaceId == rhs.applicationInterfaceId))
      return false;
    if (!(applicationName == rhs.applicationName))
      return false;
    if (__isset.applicationModules != rhs.__isset.applicationModules)
      return false;
    else if (__isset.applicationModules && !(applicationModules == rhs.applicationModules))
      return false;
    if (__isset.applicationInputs != rhs.__isset.applicationInputs)
      return false;
    else if (__isset.applicationInputs && !(applicationInputs == rhs.applicationInputs))
      return false;
    if (__isset.applicationOutputs != rhs.__isset.applicationOutputs)
      return false;
    else if (__isset.applicationOutputs && !(applicationOutputs == rhs.applicationOutputs))
      return false;
    return true;
  }
  bool operator != (const ApplicationInterfaceDescription &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ApplicationInterfaceDescription & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(ApplicationInterfaceDescription &a, ApplicationInterfaceDescription &b);



#endif
