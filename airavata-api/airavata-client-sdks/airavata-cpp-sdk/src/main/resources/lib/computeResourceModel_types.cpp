/**
 * Autogenerated by Thrift Compiler (0.9.1)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#include "computeResourceModel_types.h"

#include <algorithm>



int _kResourceJobManagerValues[] = {
  ResourceJobManager::FORK,
  ResourceJobManager::PBS,
  ResourceJobManager::UGE,
  ResourceJobManager::SLURM
};
const char* _kResourceJobManagerNames[] = {
  "FORK",
  "PBS",
  "UGE",
  "SLURM"
};
const std::map<int, const char*> _ResourceJobManager_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(4, _kResourceJobManagerValues, _kResourceJobManagerNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kFileSystemsValues[] = {
  FileSystems::HOME,
  FileSystems::WORK,
  FileSystems::LOCALTMP,
  FileSystems::SCRATCH,
  FileSystems::ARCHIVE
};
const char* _kFileSystemsNames[] = {
  "HOME",
  "WORK",
  "LOCALTMP",
  "SCRATCH",
  "ARCHIVE"
};
const std::map<int, const char*> _FileSystems_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(5, _kFileSystemsValues, _kFileSystemsNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kSecurityProtocolValues[] = {
  SecurityProtocol::USERNAME_PASSWORD,
  SecurityProtocol::SSH_KEYS,
  SecurityProtocol::GSI,
  SecurityProtocol::KERBEROS,
  SecurityProtocol::OAUTH
};
const char* _kSecurityProtocolNames[] = {
  "USERNAME_PASSWORD",
  "SSH_KEYS",
  "GSI",
  "KERBEROS",
  "OAUTH"
};
const std::map<int, const char*> _SecurityProtocol_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(5, _kSecurityProtocolValues, _kSecurityProtocolNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kJobSubmissionProtocolValues[] = {
  JobSubmissionProtocol::LOCAL,
  JobSubmissionProtocol::SSH,
  JobSubmissionProtocol::GSISSH,
  JobSubmissionProtocol::GRAM,
  JobSubmissionProtocol::UNICORE
};
const char* _kJobSubmissionProtocolNames[] = {
  "LOCAL",
  "SSH",
  "GSISSH",
  "GRAM",
  "UNICORE"
};
const std::map<int, const char*> _JobSubmissionProtocol_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(5, _kJobSubmissionProtocolValues, _kJobSubmissionProtocolNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kDataMovementProtocolValues[] = {
  DataMovementProtocol::LOCAL,
  DataMovementProtocol::SCP,
  DataMovementProtocol::SFTP,
  DataMovementProtocol::GridFTP,
  DataMovementProtocol::UNICORE_STORAGE_SERVICE
};
const char* _kDataMovementProtocolNames[] = {
  "LOCAL",
  "SCP",
  "SFTP",
  "GridFTP",
  "UNICORE_STORAGE_SERVICE"
};
const std::map<int, const char*> _DataMovementProtocol_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(5, _kDataMovementProtocolValues, _kDataMovementProtocolNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

const char* BatchQueue::ascii_fingerprint = "DA59FF8EE453E1822971C1CE1471EEA1";
const uint8_t BatchQueue::binary_fingerprint[16] = {0xDA,0x59,0xFF,0x8E,0xE4,0x53,0xE1,0x82,0x29,0x71,0xC1,0xCE,0x14,0x71,0xEE,0xA1};

uint32_t BatchQueue::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_queueName = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->queueName);
          isset_queueName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->queueDescription);
          this->__isset.queueDescription = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->maxRunTime);
          this->__isset.maxRunTime = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->maxNodes);
          this->__isset.maxNodes = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->maxProcessors);
          this->__isset.maxProcessors = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->maxJobsInQueue);
          this->__isset.maxJobsInQueue = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_queueName)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t BatchQueue::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("BatchQueue");

  xfer += oprot->writeFieldBegin("queueName", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->queueName);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.queueDescription) {
    xfer += oprot->writeFieldBegin("queueDescription", ::apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeString(this->queueDescription);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.maxRunTime) {
    xfer += oprot->writeFieldBegin("maxRunTime", ::apache::thrift::protocol::T_I32, 3);
    xfer += oprot->writeI32(this->maxRunTime);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.maxNodes) {
    xfer += oprot->writeFieldBegin("maxNodes", ::apache::thrift::protocol::T_I32, 4);
    xfer += oprot->writeI32(this->maxNodes);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.maxProcessors) {
    xfer += oprot->writeFieldBegin("maxProcessors", ::apache::thrift::protocol::T_I32, 5);
    xfer += oprot->writeI32(this->maxProcessors);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.maxJobsInQueue) {
    xfer += oprot->writeFieldBegin("maxJobsInQueue", ::apache::thrift::protocol::T_I32, 6);
    xfer += oprot->writeI32(this->maxJobsInQueue);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(BatchQueue &a, BatchQueue &b) {
  using ::std::swap;
  swap(a.queueName, b.queueName);
  swap(a.queueDescription, b.queueDescription);
  swap(a.maxRunTime, b.maxRunTime);
  swap(a.maxNodes, b.maxNodes);
  swap(a.maxProcessors, b.maxProcessors);
  swap(a.maxJobsInQueue, b.maxJobsInQueue);
  swap(a.__isset, b.__isset);
}

const char* SCPDataMovement::ascii_fingerprint = "63CAE6EE336A7DBD91CCCD6E22628F4A";
const uint8_t SCPDataMovement::binary_fingerprint[16] = {0x63,0xCA,0xE6,0xEE,0x33,0x6A,0x7D,0xBD,0x91,0xCC,0xCD,0x6E,0x22,0x62,0x8F,0x4A};

uint32_t SCPDataMovement::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_dataMovementInterfaceId = false;
  bool isset_securityProtocol = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->dataMovementInterfaceId);
          isset_dataMovementInterfaceId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast0;
          xfer += iprot->readI32(ecast0);
          this->securityProtocol = (SecurityProtocol::type)ecast0;
          isset_securityProtocol = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->alternativeSCPHostName);
          this->__isset.alternativeSCPHostName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->sshPort);
          this->__isset.sshPort = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_dataMovementInterfaceId)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_securityProtocol)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t SCPDataMovement::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("SCPDataMovement");

  xfer += oprot->writeFieldBegin("dataMovementInterfaceId", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->dataMovementInterfaceId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("securityProtocol", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32((int32_t)this->securityProtocol);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.alternativeSCPHostName) {
    xfer += oprot->writeFieldBegin("alternativeSCPHostName", ::apache::thrift::protocol::T_STRING, 3);
    xfer += oprot->writeString(this->alternativeSCPHostName);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.sshPort) {
    xfer += oprot->writeFieldBegin("sshPort", ::apache::thrift::protocol::T_I32, 4);
    xfer += oprot->writeI32(this->sshPort);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(SCPDataMovement &a, SCPDataMovement &b) {
  using ::std::swap;
  swap(a.dataMovementInterfaceId, b.dataMovementInterfaceId);
  swap(a.securityProtocol, b.securityProtocol);
  swap(a.alternativeSCPHostName, b.alternativeSCPHostName);
  swap(a.sshPort, b.sshPort);
  swap(a.__isset, b.__isset);
}

const char* GridFTPDataMovement::ascii_fingerprint = "790EE8B1D56A3B9B76C41DD063726E75";
const uint8_t GridFTPDataMovement::binary_fingerprint[16] = {0x79,0x0E,0xE8,0xB1,0xD5,0x6A,0x3B,0x9B,0x76,0xC4,0x1D,0xD0,0x63,0x72,0x6E,0x75};

uint32_t GridFTPDataMovement::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_dataMovementInterfaceId = false;
  bool isset_securityProtocol = false;
  bool isset_gridFTPEndPoints = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->dataMovementInterfaceId);
          isset_dataMovementInterfaceId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast1;
          xfer += iprot->readI32(ecast1);
          this->securityProtocol = (SecurityProtocol::type)ecast1;
          isset_securityProtocol = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->gridFTPEndPoints.clear();
            uint32_t _size2;
            ::apache::thrift::protocol::TType _etype5;
            xfer += iprot->readListBegin(_etype5, _size2);
            this->gridFTPEndPoints.resize(_size2);
            uint32_t _i6;
            for (_i6 = 0; _i6 < _size2; ++_i6)
            {
              xfer += iprot->readString(this->gridFTPEndPoints[_i6]);
            }
            xfer += iprot->readListEnd();
          }
          isset_gridFTPEndPoints = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_dataMovementInterfaceId)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_securityProtocol)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_gridFTPEndPoints)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t GridFTPDataMovement::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("GridFTPDataMovement");

  xfer += oprot->writeFieldBegin("dataMovementInterfaceId", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->dataMovementInterfaceId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("securityProtocol", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32((int32_t)this->securityProtocol);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("gridFTPEndPoints", ::apache::thrift::protocol::T_LIST, 3);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->gridFTPEndPoints.size()));
    std::vector<std::string> ::const_iterator _iter7;
    for (_iter7 = this->gridFTPEndPoints.begin(); _iter7 != this->gridFTPEndPoints.end(); ++_iter7)
    {
      xfer += oprot->writeString((*_iter7));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(GridFTPDataMovement &a, GridFTPDataMovement &b) {
  using ::std::swap;
  swap(a.dataMovementInterfaceId, b.dataMovementInterfaceId);
  swap(a.securityProtocol, b.securityProtocol);
  swap(a.gridFTPEndPoints, b.gridFTPEndPoints);
}

const char* LOCALSubmission::ascii_fingerprint = "C9C13E23D75AC7D7DB268099D53EE995";
const uint8_t LOCALSubmission::binary_fingerprint[16] = {0xC9,0xC1,0x3E,0x23,0xD7,0x5A,0xC7,0xD7,0xDB,0x26,0x80,0x99,0xD5,0x3E,0xE9,0x95};

uint32_t LOCALSubmission::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_jobSubmissionInterfaceId = false;
  bool isset_resourceJobManager = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->jobSubmissionInterfaceId);
          isset_jobSubmissionInterfaceId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast8;
          xfer += iprot->readI32(ecast8);
          this->resourceJobManager = (ResourceJobManager::type)ecast8;
          isset_resourceJobManager = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->monitoringMechanism);
          this->__isset.monitoringMechanism = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_jobSubmissionInterfaceId)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_resourceJobManager)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t LOCALSubmission::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("LOCALSubmission");

  xfer += oprot->writeFieldBegin("jobSubmissionInterfaceId", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->jobSubmissionInterfaceId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("resourceJobManager", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32((int32_t)this->resourceJobManager);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.monitoringMechanism) {
    xfer += oprot->writeFieldBegin("monitoringMechanism", ::apache::thrift::protocol::T_STRING, 6);
    xfer += oprot->writeString(this->monitoringMechanism);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(LOCALSubmission &a, LOCALSubmission &b) {
  using ::std::swap;
  swap(a.jobSubmissionInterfaceId, b.jobSubmissionInterfaceId);
  swap(a.resourceJobManager, b.resourceJobManager);
  swap(a.monitoringMechanism, b.monitoringMechanism);
  swap(a.__isset, b.__isset);
}

const char* LOCALDataMovement::ascii_fingerprint = "EFB929595D312AC8F305D5A794CFEDA1";
const uint8_t LOCALDataMovement::binary_fingerprint[16] = {0xEF,0xB9,0x29,0x59,0x5D,0x31,0x2A,0xC8,0xF3,0x05,0xD5,0xA7,0x94,0xCF,0xED,0xA1};

uint32_t LOCALDataMovement::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_dataMovementInterfaceId = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->dataMovementInterfaceId);
          isset_dataMovementInterfaceId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_dataMovementInterfaceId)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t LOCALDataMovement::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("LOCALDataMovement");

  xfer += oprot->writeFieldBegin("dataMovementInterfaceId", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->dataMovementInterfaceId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(LOCALDataMovement &a, LOCALDataMovement &b) {
  using ::std::swap;
  swap(a.dataMovementInterfaceId, b.dataMovementInterfaceId);
}

const char* SSHJobSubmission::ascii_fingerprint = "7AD7C2665ACC6606EC984DACFC74881E";
const uint8_t SSHJobSubmission::binary_fingerprint[16] = {0x7A,0xD7,0xC2,0x66,0x5A,0xCC,0x66,0x06,0xEC,0x98,0x4D,0xAC,0xFC,0x74,0x88,0x1E};

uint32_t SSHJobSubmission::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_jobSubmissionInterfaceId = false;
  bool isset_securityProtocol = false;
  bool isset_resourceJobManager = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->jobSubmissionInterfaceId);
          isset_jobSubmissionInterfaceId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast9;
          xfer += iprot->readI32(ecast9);
          this->securityProtocol = (SecurityProtocol::type)ecast9;
          isset_securityProtocol = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast10;
          xfer += iprot->readI32(ecast10);
          this->resourceJobManager = (ResourceJobManager::type)ecast10;
          isset_resourceJobManager = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->alternativeSSHHostName);
          this->__isset.alternativeSSHHostName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->sshPort);
          this->__isset.sshPort = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->monitoringMechanism);
          this->__isset.monitoringMechanism = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_jobSubmissionInterfaceId)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_securityProtocol)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_resourceJobManager)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t SSHJobSubmission::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("SSHJobSubmission");

  xfer += oprot->writeFieldBegin("jobSubmissionInterfaceId", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->jobSubmissionInterfaceId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("securityProtocol", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32((int32_t)this->securityProtocol);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("resourceJobManager", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32((int32_t)this->resourceJobManager);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.alternativeSSHHostName) {
    xfer += oprot->writeFieldBegin("alternativeSSHHostName", ::apache::thrift::protocol::T_STRING, 4);
    xfer += oprot->writeString(this->alternativeSSHHostName);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.sshPort) {
    xfer += oprot->writeFieldBegin("sshPort", ::apache::thrift::protocol::T_I32, 5);
    xfer += oprot->writeI32(this->sshPort);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.monitoringMechanism) {
    xfer += oprot->writeFieldBegin("monitoringMechanism", ::apache::thrift::protocol::T_STRING, 6);
    xfer += oprot->writeString(this->monitoringMechanism);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(SSHJobSubmission &a, SSHJobSubmission &b) {
  using ::std::swap;
  swap(a.jobSubmissionInterfaceId, b.jobSubmissionInterfaceId);
  swap(a.securityProtocol, b.securityProtocol);
  swap(a.resourceJobManager, b.resourceJobManager);
  swap(a.alternativeSSHHostName, b.alternativeSSHHostName);
  swap(a.sshPort, b.sshPort);
  swap(a.monitoringMechanism, b.monitoringMechanism);
  swap(a.__isset, b.__isset);
}

const char* GlobusJobSubmission::ascii_fingerprint = "DF4253F78D7B543C16FA461660D38A03";
const uint8_t GlobusJobSubmission::binary_fingerprint[16] = {0xDF,0x42,0x53,0xF7,0x8D,0x7B,0x54,0x3C,0x16,0xFA,0x46,0x16,0x60,0xD3,0x8A,0x03};

uint32_t GlobusJobSubmission::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_jobSubmissionInterfaceId = false;
  bool isset_securityProtocol = false;
  bool isset_resourceJobManager = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->jobSubmissionInterfaceId);
          isset_jobSubmissionInterfaceId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast11;
          xfer += iprot->readI32(ecast11);
          this->securityProtocol = (SecurityProtocol::type)ecast11;
          isset_securityProtocol = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast12;
          xfer += iprot->readI32(ecast12);
          this->resourceJobManager = (ResourceJobManager::type)ecast12;
          isset_resourceJobManager = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->globusGateKeeperEndPoint.clear();
            uint32_t _size13;
            ::apache::thrift::protocol::TType _etype16;
            xfer += iprot->readListBegin(_etype16, _size13);
            this->globusGateKeeperEndPoint.resize(_size13);
            uint32_t _i17;
            for (_i17 = 0; _i17 < _size13; ++_i17)
            {
              xfer += iprot->readString(this->globusGateKeeperEndPoint[_i17]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.globusGateKeeperEndPoint = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_jobSubmissionInterfaceId)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_securityProtocol)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_resourceJobManager)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t GlobusJobSubmission::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("GlobusJobSubmission");

  xfer += oprot->writeFieldBegin("jobSubmissionInterfaceId", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->jobSubmissionInterfaceId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("securityProtocol", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32((int32_t)this->securityProtocol);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("resourceJobManager", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32((int32_t)this->resourceJobManager);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.globusGateKeeperEndPoint) {
    xfer += oprot->writeFieldBegin("globusGateKeeperEndPoint", ::apache::thrift::protocol::T_LIST, 4);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->globusGateKeeperEndPoint.size()));
      std::vector<std::string> ::const_iterator _iter18;
      for (_iter18 = this->globusGateKeeperEndPoint.begin(); _iter18 != this->globusGateKeeperEndPoint.end(); ++_iter18)
      {
        xfer += oprot->writeString((*_iter18));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(GlobusJobSubmission &a, GlobusJobSubmission &b) {
  using ::std::swap;
  swap(a.jobSubmissionInterfaceId, b.jobSubmissionInterfaceId);
  swap(a.securityProtocol, b.securityProtocol);
  swap(a.resourceJobManager, b.resourceJobManager);
  swap(a.globusGateKeeperEndPoint, b.globusGateKeeperEndPoint);
  swap(a.__isset, b.__isset);
}

const char* JobSubmissionInterface::ascii_fingerprint = "A0A4DD7B8243FB842E64EAC6E5DA6C7B";
const uint8_t JobSubmissionInterface::binary_fingerprint[16] = {0xA0,0xA4,0xDD,0x7B,0x82,0x43,0xFB,0x84,0x2E,0x64,0xEA,0xC6,0xE5,0xDA,0x6C,0x7B};

uint32_t JobSubmissionInterface::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_jobSubmissionInterfaceId = false;
  bool isset_jobSubmissionProtocol = false;
  bool isset_priorityOrder = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->jobSubmissionInterfaceId);
          isset_jobSubmissionInterfaceId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast19;
          xfer += iprot->readI32(ecast19);
          this->jobSubmissionProtocol = (JobSubmissionProtocol::type)ecast19;
          isset_jobSubmissionProtocol = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->priorityOrder);
          isset_priorityOrder = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_jobSubmissionInterfaceId)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_jobSubmissionProtocol)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_priorityOrder)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t JobSubmissionInterface::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("JobSubmissionInterface");

  xfer += oprot->writeFieldBegin("jobSubmissionInterfaceId", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->jobSubmissionInterfaceId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("jobSubmissionProtocol", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32((int32_t)this->jobSubmissionProtocol);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("priorityOrder", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32(this->priorityOrder);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(JobSubmissionInterface &a, JobSubmissionInterface &b) {
  using ::std::swap;
  swap(a.jobSubmissionInterfaceId, b.jobSubmissionInterfaceId);
  swap(a.jobSubmissionProtocol, b.jobSubmissionProtocol);
  swap(a.priorityOrder, b.priorityOrder);
}

const char* DataMovementInterface::ascii_fingerprint = "A0A4DD7B8243FB842E64EAC6E5DA6C7B";
const uint8_t DataMovementInterface::binary_fingerprint[16] = {0xA0,0xA4,0xDD,0x7B,0x82,0x43,0xFB,0x84,0x2E,0x64,0xEA,0xC6,0xE5,0xDA,0x6C,0x7B};

uint32_t DataMovementInterface::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_dataMovementInterfaceId = false;
  bool isset_dataMovementProtocol = false;
  bool isset_priorityOrder = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->dataMovementInterfaceId);
          isset_dataMovementInterfaceId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast20;
          xfer += iprot->readI32(ecast20);
          this->dataMovementProtocol = (DataMovementProtocol::type)ecast20;
          isset_dataMovementProtocol = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->priorityOrder);
          isset_priorityOrder = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_dataMovementInterfaceId)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_dataMovementProtocol)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_priorityOrder)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t DataMovementInterface::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("DataMovementInterface");

  xfer += oprot->writeFieldBegin("dataMovementInterfaceId", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->dataMovementInterfaceId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("dataMovementProtocol", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32((int32_t)this->dataMovementProtocol);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("priorityOrder", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32(this->priorityOrder);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(DataMovementInterface &a, DataMovementInterface &b) {
  using ::std::swap;
  swap(a.dataMovementInterfaceId, b.dataMovementInterfaceId);
  swap(a.dataMovementProtocol, b.dataMovementProtocol);
  swap(a.priorityOrder, b.priorityOrder);
}

const char* ComputeResourceDescription::ascii_fingerprint = "ADC1452A60F79D933D0EE4B9893AD048";
const uint8_t ComputeResourceDescription::binary_fingerprint[16] = {0xAD,0xC1,0x45,0x2A,0x60,0xF7,0x9D,0x93,0x3D,0x0E,0xE4,0xB9,0x89,0x3A,0xD0,0x48};

uint32_t ComputeResourceDescription::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_isEmpty = false;
  bool isset_computeResourceId = false;
  bool isset_hostName = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->isEmpty);
          isset_isEmpty = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->computeResourceId);
          isset_computeResourceId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->hostName);
          isset_hostName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_SET) {
          {
            this->hostAliases.clear();
            uint32_t _size21;
            ::apache::thrift::protocol::TType _etype24;
            xfer += iprot->readSetBegin(_etype24, _size21);
            uint32_t _i25;
            for (_i25 = 0; _i25 < _size21; ++_i25)
            {
              std::string _elem26;
              xfer += iprot->readString(_elem26);
              this->hostAliases.insert(_elem26);
            }
            xfer += iprot->readSetEnd();
          }
          this->__isset.hostAliases = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_SET) {
          {
            this->ipAddresses.clear();
            uint32_t _size27;
            ::apache::thrift::protocol::TType _etype30;
            xfer += iprot->readSetBegin(_etype30, _size27);
            uint32_t _i31;
            for (_i31 = 0; _i31 < _size27; ++_i31)
            {
              std::string _elem32;
              xfer += iprot->readString(_elem32);
              this->ipAddresses.insert(_elem32);
            }
            xfer += iprot->readSetEnd();
          }
          this->__isset.ipAddresses = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->computeResourceDescription);
          this->__isset.computeResourceDescription = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast33;
          xfer += iprot->readI32(ecast33);
          this->resourceJobManager = (ResourceJobManager::type)ecast33;
          this->__isset.resourceJobManager = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->batchQueues.clear();
            uint32_t _size34;
            ::apache::thrift::protocol::TType _etype37;
            xfer += iprot->readListBegin(_etype37, _size34);
            this->batchQueues.resize(_size34);
            uint32_t _i38;
            for (_i38 = 0; _i38 < _size34; ++_i38)
            {
              xfer += this->batchQueues[_i38].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.batchQueues = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->fileSystems.clear();
            uint32_t _size39;
            ::apache::thrift::protocol::TType _ktype40;
            ::apache::thrift::protocol::TType _vtype41;
            xfer += iprot->readMapBegin(_ktype40, _vtype41, _size39);
            uint32_t _i43;
            for (_i43 = 0; _i43 < _size39; ++_i43)
            {
              FileSystems::type _key44;
              int32_t ecast46;
              xfer += iprot->readI32(ecast46);
              _key44 = (FileSystems::type)ecast46;
              std::string& _val45 = this->fileSystems[_key44];
              xfer += iprot->readString(_val45);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.fileSystems = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->jobSubmissionInterfaces.clear();
            uint32_t _size47;
            ::apache::thrift::protocol::TType _etype50;
            xfer += iprot->readListBegin(_etype50, _size47);
            this->jobSubmissionInterfaces.resize(_size47);
            uint32_t _i51;
            for (_i51 = 0; _i51 < _size47; ++_i51)
            {
              xfer += this->jobSubmissionInterfaces[_i51].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.jobSubmissionInterfaces = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 11:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->dataMovemenetInterfaces.clear();
            uint32_t _size52;
            ::apache::thrift::protocol::TType _etype55;
            xfer += iprot->readListBegin(_etype55, _size52);
            this->dataMovemenetInterfaces.resize(_size52);
            uint32_t _i56;
            for (_i56 = 0; _i56 < _size52; ++_i56)
            {
              xfer += this->dataMovemenetInterfaces[_i56].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.dataMovemenetInterfaces = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_isEmpty)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_computeResourceId)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_hostName)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t ComputeResourceDescription::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("ComputeResourceDescription");

  xfer += oprot->writeFieldBegin("isEmpty", ::apache::thrift::protocol::T_BOOL, 1);
  xfer += oprot->writeBool(this->isEmpty);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("computeResourceId", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->computeResourceId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("hostName", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->hostName);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.hostAliases) {
    xfer += oprot->writeFieldBegin("hostAliases", ::apache::thrift::protocol::T_SET, 4);
    {
      xfer += oprot->writeSetBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->hostAliases.size()));
      std::set<std::string> ::const_iterator _iter57;
      for (_iter57 = this->hostAliases.begin(); _iter57 != this->hostAliases.end(); ++_iter57)
      {
        xfer += oprot->writeString((*_iter57));
      }
      xfer += oprot->writeSetEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.ipAddresses) {
    xfer += oprot->writeFieldBegin("ipAddresses", ::apache::thrift::protocol::T_SET, 5);
    {
      xfer += oprot->writeSetBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->ipAddresses.size()));
      std::set<std::string> ::const_iterator _iter58;
      for (_iter58 = this->ipAddresses.begin(); _iter58 != this->ipAddresses.end(); ++_iter58)
      {
        xfer += oprot->writeString((*_iter58));
      }
      xfer += oprot->writeSetEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.computeResourceDescription) {
    xfer += oprot->writeFieldBegin("computeResourceDescription", ::apache::thrift::protocol::T_STRING, 6);
    xfer += oprot->writeString(this->computeResourceDescription);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.resourceJobManager) {
    xfer += oprot->writeFieldBegin("resourceJobManager", ::apache::thrift::protocol::T_I32, 7);
    xfer += oprot->writeI32((int32_t)this->resourceJobManager);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.batchQueues) {
    xfer += oprot->writeFieldBegin("batchQueues", ::apache::thrift::protocol::T_LIST, 8);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->batchQueues.size()));
      std::vector<BatchQueue> ::const_iterator _iter59;
      for (_iter59 = this->batchQueues.begin(); _iter59 != this->batchQueues.end(); ++_iter59)
      {
        xfer += (*_iter59).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.fileSystems) {
    xfer += oprot->writeFieldBegin("fileSystems", ::apache::thrift::protocol::T_MAP, 9);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_I32, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->fileSystems.size()));
      std::map<FileSystems::type, std::string> ::const_iterator _iter60;
      for (_iter60 = this->fileSystems.begin(); _iter60 != this->fileSystems.end(); ++_iter60)
      {
        xfer += oprot->writeI32((int32_t)_iter60->first);
        xfer += oprot->writeString(_iter60->second);
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.jobSubmissionInterfaces) {
    xfer += oprot->writeFieldBegin("jobSubmissionInterfaces", ::apache::thrift::protocol::T_LIST, 10);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->jobSubmissionInterfaces.size()));
      std::vector<JobSubmissionInterface> ::const_iterator _iter61;
      for (_iter61 = this->jobSubmissionInterfaces.begin(); _iter61 != this->jobSubmissionInterfaces.end(); ++_iter61)
      {
        xfer += (*_iter61).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.dataMovemenetInterfaces) {
    xfer += oprot->writeFieldBegin("dataMovemenetInterfaces", ::apache::thrift::protocol::T_LIST, 11);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->dataMovemenetInterfaces.size()));
      std::vector<DataMovementInterface> ::const_iterator _iter62;
      for (_iter62 = this->dataMovemenetInterfaces.begin(); _iter62 != this->dataMovemenetInterfaces.end(); ++_iter62)
      {
        xfer += (*_iter62).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ComputeResourceDescription &a, ComputeResourceDescription &b) {
  using ::std::swap;
  swap(a.isEmpty, b.isEmpty);
  swap(a.computeResourceId, b.computeResourceId);
  swap(a.hostName, b.hostName);
  swap(a.hostAliases, b.hostAliases);
  swap(a.ipAddresses, b.ipAddresses);
  swap(a.computeResourceDescription, b.computeResourceDescription);
  swap(a.resourceJobManager, b.resourceJobManager);
  swap(a.batchQueues, b.batchQueues);
  swap(a.fileSystems, b.fileSystems);
  swap(a.jobSubmissionInterfaces, b.jobSubmissionInterfaces);
  swap(a.dataMovemenetInterfaces, b.dataMovemenetInterfaces);
  swap(a.__isset, b.__isset);
}


