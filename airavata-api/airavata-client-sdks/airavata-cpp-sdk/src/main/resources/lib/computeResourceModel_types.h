/**
 * Autogenerated by Thrift Compiler (0.9.1)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#ifndef computeResourceModel_TYPES_H
#define computeResourceModel_TYPES_H

#include <thrift/Thrift.h>
#include <thrift/TApplicationException.h>
#include <thrift/protocol/TProtocol.h>
#include <thrift/transport/TTransport.h>

#include <thrift/cxxfunctional.h>




struct ResourceJobManager {
  enum type {
    FORK = 0,
    PBS = 1,
    UGE = 2,
    SLURM = 3
  };
};

extern const std::map<int, const char*> _ResourceJobManager_VALUES_TO_NAMES;

struct FileSystems {
  enum type {
    HOME = 0,
    WORK = 1,
    LOCALTMP = 2,
    SCRATCH = 3,
    ARCHIVE = 4
  };
};

extern const std::map<int, const char*> _FileSystems_VALUES_TO_NAMES;

struct SecurityProtocol {
  enum type {
    USERNAME_PASSWORD = 0,
    SSH_KEYS = 1,
    GSI = 2,
    KERBEROS = 3,
    OAUTH = 4
  };
};

extern const std::map<int, const char*> _SecurityProtocol_VALUES_TO_NAMES;

struct JobSubmissionProtocol {
  enum type {
    LOCAL = 0,
    SSH = 1,
    GSISSH = 2,
    GRAM = 3,
    UNICORE = 4
  };
};

extern const std::map<int, const char*> _JobSubmissionProtocol_VALUES_TO_NAMES;

struct DataMovementProtocol {
  enum type {
    LOCAL = 0,
    SCP = 1,
    SFTP = 2,
    GridFTP = 3,
    UNICORE_STORAGE_SERVICE = 4
  };
};

extern const std::map<int, const char*> _DataMovementProtocol_VALUES_TO_NAMES;

typedef struct _BatchQueue__isset {
  _BatchQueue__isset() : queueDescription(false), maxRunTime(false), maxNodes(false), maxProcessors(false), maxJobsInQueue(false) {}
  bool queueDescription;
  bool maxRunTime;
  bool maxNodes;
  bool maxProcessors;
  bool maxJobsInQueue;
} _BatchQueue__isset;

class BatchQueue {
 public:

  static const char* ascii_fingerprint; // = "DA59FF8EE453E1822971C1CE1471EEA1";
  static const uint8_t binary_fingerprint[16]; // = {0xDA,0x59,0xFF,0x8E,0xE4,0x53,0xE1,0x82,0x29,0x71,0xC1,0xCE,0x14,0x71,0xEE,0xA1};

  BatchQueue() : queueName(), queueDescription(), maxRunTime(0), maxNodes(0), maxProcessors(0), maxJobsInQueue(0) {
  }

  virtual ~BatchQueue() throw() {}

  std::string queueName;
  std::string queueDescription;
  int32_t maxRunTime;
  int32_t maxNodes;
  int32_t maxProcessors;
  int32_t maxJobsInQueue;

  _BatchQueue__isset __isset;

  void __set_queueName(const std::string& val) {
    queueName = val;
  }

  void __set_queueDescription(const std::string& val) {
    queueDescription = val;
    __isset.queueDescription = true;
  }

  void __set_maxRunTime(const int32_t val) {
    maxRunTime = val;
    __isset.maxRunTime = true;
  }

  void __set_maxNodes(const int32_t val) {
    maxNodes = val;
    __isset.maxNodes = true;
  }

  void __set_maxProcessors(const int32_t val) {
    maxProcessors = val;
    __isset.maxProcessors = true;
  }

  void __set_maxJobsInQueue(const int32_t val) {
    maxJobsInQueue = val;
    __isset.maxJobsInQueue = true;
  }

  bool operator == (const BatchQueue & rhs) const
  {
    if (!(queueName == rhs.queueName))
      return false;
    if (__isset.queueDescription != rhs.__isset.queueDescription)
      return false;
    else if (__isset.queueDescription && !(queueDescription == rhs.queueDescription))
      return false;
    if (__isset.maxRunTime != rhs.__isset.maxRunTime)
      return false;
    else if (__isset.maxRunTime && !(maxRunTime == rhs.maxRunTime))
      return false;
    if (__isset.maxNodes != rhs.__isset.maxNodes)
      return false;
    else if (__isset.maxNodes && !(maxNodes == rhs.maxNodes))
      return false;
    if (__isset.maxProcessors != rhs.__isset.maxProcessors)
      return false;
    else if (__isset.maxProcessors && !(maxProcessors == rhs.maxProcessors))
      return false;
    if (__isset.maxJobsInQueue != rhs.__isset.maxJobsInQueue)
      return false;
    else if (__isset.maxJobsInQueue && !(maxJobsInQueue == rhs.maxJobsInQueue))
      return false;
    return true;
  }
  bool operator != (const BatchQueue &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const BatchQueue & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(BatchQueue &a, BatchQueue &b);

typedef struct _SCPDataMovement__isset {
  _SCPDataMovement__isset() : alternativeSCPHostName(false), sshPort(true) {}
  bool alternativeSCPHostName;
  bool sshPort;
} _SCPDataMovement__isset;

class SCPDataMovement {
 public:

  static const char* ascii_fingerprint; // = "63CAE6EE336A7DBD91CCCD6E22628F4A";
  static const uint8_t binary_fingerprint[16]; // = {0x63,0xCA,0xE6,0xEE,0x33,0x6A,0x7D,0xBD,0x91,0xCC,0xCD,0x6E,0x22,0x62,0x8F,0x4A};

  SCPDataMovement() : dataMovementInterfaceId("DO_NOT_SET_AT_CLIENTS"), securityProtocol((SecurityProtocol::type)0), alternativeSCPHostName(), sshPort(22) {
  }

  virtual ~SCPDataMovement() throw() {}

  std::string dataMovementInterfaceId;
  SecurityProtocol::type securityProtocol;
  std::string alternativeSCPHostName;
  int32_t sshPort;

  _SCPDataMovement__isset __isset;

  void __set_dataMovementInterfaceId(const std::string& val) {
    dataMovementInterfaceId = val;
  }

  void __set_securityProtocol(const SecurityProtocol::type val) {
    securityProtocol = val;
  }

  void __set_alternativeSCPHostName(const std::string& val) {
    alternativeSCPHostName = val;
    __isset.alternativeSCPHostName = true;
  }

  void __set_sshPort(const int32_t val) {
    sshPort = val;
    __isset.sshPort = true;
  }

  bool operator == (const SCPDataMovement & rhs) const
  {
    if (!(dataMovementInterfaceId == rhs.dataMovementInterfaceId))
      return false;
    if (!(securityProtocol == rhs.securityProtocol))
      return false;
    if (__isset.alternativeSCPHostName != rhs.__isset.alternativeSCPHostName)
      return false;
    else if (__isset.alternativeSCPHostName && !(alternativeSCPHostName == rhs.alternativeSCPHostName))
      return false;
    if (__isset.sshPort != rhs.__isset.sshPort)
      return false;
    else if (__isset.sshPort && !(sshPort == rhs.sshPort))
      return false;
    return true;
  }
  bool operator != (const SCPDataMovement &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const SCPDataMovement & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(SCPDataMovement &a, SCPDataMovement &b);


class GridFTPDataMovement {
 public:

  static const char* ascii_fingerprint; // = "790EE8B1D56A3B9B76C41DD063726E75";
  static const uint8_t binary_fingerprint[16]; // = {0x79,0x0E,0xE8,0xB1,0xD5,0x6A,0x3B,0x9B,0x76,0xC4,0x1D,0xD0,0x63,0x72,0x6E,0x75};

  GridFTPDataMovement() : dataMovementInterfaceId("DO_NOT_SET_AT_CLIENTS"), securityProtocol((SecurityProtocol::type)0) {
  }

  virtual ~GridFTPDataMovement() throw() {}

  std::string dataMovementInterfaceId;
  SecurityProtocol::type securityProtocol;
  std::vector<std::string>  gridFTPEndPoints;

  void __set_dataMovementInterfaceId(const std::string& val) {
    dataMovementInterfaceId = val;
  }

  void __set_securityProtocol(const SecurityProtocol::type val) {
    securityProtocol = val;
  }

  void __set_gridFTPEndPoints(const std::vector<std::string> & val) {
    gridFTPEndPoints = val;
  }

  bool operator == (const GridFTPDataMovement & rhs) const
  {
    if (!(dataMovementInterfaceId == rhs.dataMovementInterfaceId))
      return false;
    if (!(securityProtocol == rhs.securityProtocol))
      return false;
    if (!(gridFTPEndPoints == rhs.gridFTPEndPoints))
      return false;
    return true;
  }
  bool operator != (const GridFTPDataMovement &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const GridFTPDataMovement & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(GridFTPDataMovement &a, GridFTPDataMovement &b);

typedef struct _LOCALSubmission__isset {
  _LOCALSubmission__isset() : monitoringMechanism(false) {}
  bool monitoringMechanism;
} _LOCALSubmission__isset;

class LOCALSubmission {
 public:

  static const char* ascii_fingerprint; // = "C9C13E23D75AC7D7DB268099D53EE995";
  static const uint8_t binary_fingerprint[16]; // = {0xC9,0xC1,0x3E,0x23,0xD7,0x5A,0xC7,0xD7,0xDB,0x26,0x80,0x99,0xD5,0x3E,0xE9,0x95};

  LOCALSubmission() : jobSubmissionInterfaceId("DO_NOT_SET_AT_CLIENTS"), resourceJobManager((ResourceJobManager::type)0), monitoringMechanism() {
  }

  virtual ~LOCALSubmission() throw() {}

  std::string jobSubmissionInterfaceId;
  ResourceJobManager::type resourceJobManager;
  std::string monitoringMechanism;

  _LOCALSubmission__isset __isset;

  void __set_jobSubmissionInterfaceId(const std::string& val) {
    jobSubmissionInterfaceId = val;
  }

  void __set_resourceJobManager(const ResourceJobManager::type val) {
    resourceJobManager = val;
  }

  void __set_monitoringMechanism(const std::string& val) {
    monitoringMechanism = val;
    __isset.monitoringMechanism = true;
  }

  bool operator == (const LOCALSubmission & rhs) const
  {
    if (!(jobSubmissionInterfaceId == rhs.jobSubmissionInterfaceId))
      return false;
    if (!(resourceJobManager == rhs.resourceJobManager))
      return false;
    if (__isset.monitoringMechanism != rhs.__isset.monitoringMechanism)
      return false;
    else if (__isset.monitoringMechanism && !(monitoringMechanism == rhs.monitoringMechanism))
      return false;
    return true;
  }
  bool operator != (const LOCALSubmission &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const LOCALSubmission & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(LOCALSubmission &a, LOCALSubmission &b);


class LOCALDataMovement {
 public:

  static const char* ascii_fingerprint; // = "EFB929595D312AC8F305D5A794CFEDA1";
  static const uint8_t binary_fingerprint[16]; // = {0xEF,0xB9,0x29,0x59,0x5D,0x31,0x2A,0xC8,0xF3,0x05,0xD5,0xA7,0x94,0xCF,0xED,0xA1};

  LOCALDataMovement() : dataMovementInterfaceId("DO_NOT_SET_AT_CLIENTS") {
  }

  virtual ~LOCALDataMovement() throw() {}

  std::string dataMovementInterfaceId;

  void __set_dataMovementInterfaceId(const std::string& val) {
    dataMovementInterfaceId = val;
  }

  bool operator == (const LOCALDataMovement & rhs) const
  {
    if (!(dataMovementInterfaceId == rhs.dataMovementInterfaceId))
      return false;
    return true;
  }
  bool operator != (const LOCALDataMovement &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const LOCALDataMovement & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(LOCALDataMovement &a, LOCALDataMovement &b);

typedef struct _SSHJobSubmission__isset {
  _SSHJobSubmission__isset() : alternativeSSHHostName(false), sshPort(true), monitoringMechanism(false) {}
  bool alternativeSSHHostName;
  bool sshPort;
  bool monitoringMechanism;
} _SSHJobSubmission__isset;

class SSHJobSubmission {
 public:

  static const char* ascii_fingerprint; // = "7AD7C2665ACC6606EC984DACFC74881E";
  static const uint8_t binary_fingerprint[16]; // = {0x7A,0xD7,0xC2,0x66,0x5A,0xCC,0x66,0x06,0xEC,0x98,0x4D,0xAC,0xFC,0x74,0x88,0x1E};

  SSHJobSubmission() : jobSubmissionInterfaceId("DO_NOT_SET_AT_CLIENTS"), securityProtocol((SecurityProtocol::type)0), resourceJobManager((ResourceJobManager::type)0), alternativeSSHHostName(), sshPort(22), monitoringMechanism() {
  }

  virtual ~SSHJobSubmission() throw() {}

  std::string jobSubmissionInterfaceId;
  SecurityProtocol::type securityProtocol;
  ResourceJobManager::type resourceJobManager;
  std::string alternativeSSHHostName;
  int32_t sshPort;
  std::string monitoringMechanism;

  _SSHJobSubmission__isset __isset;

  void __set_jobSubmissionInterfaceId(const std::string& val) {
    jobSubmissionInterfaceId = val;
  }

  void __set_securityProtocol(const SecurityProtocol::type val) {
    securityProtocol = val;
  }

  void __set_resourceJobManager(const ResourceJobManager::type val) {
    resourceJobManager = val;
  }

  void __set_alternativeSSHHostName(const std::string& val) {
    alternativeSSHHostName = val;
    __isset.alternativeSSHHostName = true;
  }

  void __set_sshPort(const int32_t val) {
    sshPort = val;
    __isset.sshPort = true;
  }

  void __set_monitoringMechanism(const std::string& val) {
    monitoringMechanism = val;
    __isset.monitoringMechanism = true;
  }

  bool operator == (const SSHJobSubmission & rhs) const
  {
    if (!(jobSubmissionInterfaceId == rhs.jobSubmissionInterfaceId))
      return false;
    if (!(securityProtocol == rhs.securityProtocol))
      return false;
    if (!(resourceJobManager == rhs.resourceJobManager))
      return false;
    if (__isset.alternativeSSHHostName != rhs.__isset.alternativeSSHHostName)
      return false;
    else if (__isset.alternativeSSHHostName && !(alternativeSSHHostName == rhs.alternativeSSHHostName))
      return false;
    if (__isset.sshPort != rhs.__isset.sshPort)
      return false;
    else if (__isset.sshPort && !(sshPort == rhs.sshPort))
      return false;
    if (__isset.monitoringMechanism != rhs.__isset.monitoringMechanism)
      return false;
    else if (__isset.monitoringMechanism && !(monitoringMechanism == rhs.monitoringMechanism))
      return false;
    return true;
  }
  bool operator != (const SSHJobSubmission &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const SSHJobSubmission & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(SSHJobSubmission &a, SSHJobSubmission &b);

typedef struct _GlobusJobSubmission__isset {
  _GlobusJobSubmission__isset() : globusGateKeeperEndPoint(false) {}
  bool globusGateKeeperEndPoint;
} _GlobusJobSubmission__isset;

class GlobusJobSubmission {
 public:

  static const char* ascii_fingerprint; // = "DF4253F78D7B543C16FA461660D38A03";
  static const uint8_t binary_fingerprint[16]; // = {0xDF,0x42,0x53,0xF7,0x8D,0x7B,0x54,0x3C,0x16,0xFA,0x46,0x16,0x60,0xD3,0x8A,0x03};

  GlobusJobSubmission() : jobSubmissionInterfaceId("DO_NOT_SET_AT_CLIENTS"), securityProtocol((SecurityProtocol::type)0), resourceJobManager((ResourceJobManager::type)0) {
  }

  virtual ~GlobusJobSubmission() throw() {}

  std::string jobSubmissionInterfaceId;
  SecurityProtocol::type securityProtocol;
  ResourceJobManager::type resourceJobManager;
  std::vector<std::string>  globusGateKeeperEndPoint;

  _GlobusJobSubmission__isset __isset;

  void __set_jobSubmissionInterfaceId(const std::string& val) {
    jobSubmissionInterfaceId = val;
  }

  void __set_securityProtocol(const SecurityProtocol::type val) {
    securityProtocol = val;
  }

  void __set_resourceJobManager(const ResourceJobManager::type val) {
    resourceJobManager = val;
  }

  void __set_globusGateKeeperEndPoint(const std::vector<std::string> & val) {
    globusGateKeeperEndPoint = val;
    __isset.globusGateKeeperEndPoint = true;
  }

  bool operator == (const GlobusJobSubmission & rhs) const
  {
    if (!(jobSubmissionInterfaceId == rhs.jobSubmissionInterfaceId))
      return false;
    if (!(securityProtocol == rhs.securityProtocol))
      return false;
    if (!(resourceJobManager == rhs.resourceJobManager))
      return false;
    if (__isset.globusGateKeeperEndPoint != rhs.__isset.globusGateKeeperEndPoint)
      return false;
    else if (__isset.globusGateKeeperEndPoint && !(globusGateKeeperEndPoint == rhs.globusGateKeeperEndPoint))
      return false;
    return true;
  }
  bool operator != (const GlobusJobSubmission &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const GlobusJobSubmission & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(GlobusJobSubmission &a, GlobusJobSubmission &b);


class JobSubmissionInterface {
 public:

  static const char* ascii_fingerprint; // = "A0A4DD7B8243FB842E64EAC6E5DA6C7B";
  static const uint8_t binary_fingerprint[16]; // = {0xA0,0xA4,0xDD,0x7B,0x82,0x43,0xFB,0x84,0x2E,0x64,0xEA,0xC6,0xE5,0xDA,0x6C,0x7B};

  JobSubmissionInterface() : jobSubmissionInterfaceId(), jobSubmissionProtocol((JobSubmissionProtocol::type)0), priorityOrder(0) {
  }

  virtual ~JobSubmissionInterface() throw() {}

  std::string jobSubmissionInterfaceId;
  JobSubmissionProtocol::type jobSubmissionProtocol;
  int32_t priorityOrder;

  void __set_jobSubmissionInterfaceId(const std::string& val) {
    jobSubmissionInterfaceId = val;
  }

  void __set_jobSubmissionProtocol(const JobSubmissionProtocol::type val) {
    jobSubmissionProtocol = val;
  }

  void __set_priorityOrder(const int32_t val) {
    priorityOrder = val;
  }

  bool operator == (const JobSubmissionInterface & rhs) const
  {
    if (!(jobSubmissionInterfaceId == rhs.jobSubmissionInterfaceId))
      return false;
    if (!(jobSubmissionProtocol == rhs.jobSubmissionProtocol))
      return false;
    if (!(priorityOrder == rhs.priorityOrder))
      return false;
    return true;
  }
  bool operator != (const JobSubmissionInterface &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const JobSubmissionInterface & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(JobSubmissionInterface &a, JobSubmissionInterface &b);


class DataMovementInterface {
 public:

  static const char* ascii_fingerprint; // = "A0A4DD7B8243FB842E64EAC6E5DA6C7B";
  static const uint8_t binary_fingerprint[16]; // = {0xA0,0xA4,0xDD,0x7B,0x82,0x43,0xFB,0x84,0x2E,0x64,0xEA,0xC6,0xE5,0xDA,0x6C,0x7B};

  DataMovementInterface() : dataMovementInterfaceId(), dataMovementProtocol((DataMovementProtocol::type)0), priorityOrder(0) {
  }

  virtual ~DataMovementInterface() throw() {}

  std::string dataMovementInterfaceId;
  DataMovementProtocol::type dataMovementProtocol;
  int32_t priorityOrder;

  void __set_dataMovementInterfaceId(const std::string& val) {
    dataMovementInterfaceId = val;
  }

  void __set_dataMovementProtocol(const DataMovementProtocol::type val) {
    dataMovementProtocol = val;
  }

  void __set_priorityOrder(const int32_t val) {
    priorityOrder = val;
  }

  bool operator == (const DataMovementInterface & rhs) const
  {
    if (!(dataMovementInterfaceId == rhs.dataMovementInterfaceId))
      return false;
    if (!(dataMovementProtocol == rhs.dataMovementProtocol))
      return false;
    if (!(priorityOrder == rhs.priorityOrder))
      return false;
    return true;
  }
  bool operator != (const DataMovementInterface &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const DataMovementInterface & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(DataMovementInterface &a, DataMovementInterface &b);

typedef struct _ComputeResourceDescription__isset {
  _ComputeResourceDescription__isset() : hostAliases(false), ipAddresses(false), computeResourceDescription(false), resourceJobManager(false), batchQueues(false), fileSystems(false), jobSubmissionInterfaces(false), dataMovemenetInterfaces(false) {}
  bool hostAliases;
  bool ipAddresses;
  bool computeResourceDescription;
  bool resourceJobManager;
  bool batchQueues;
  bool fileSystems;
  bool jobSubmissionInterfaces;
  bool dataMovemenetInterfaces;
} _ComputeResourceDescription__isset;

class ComputeResourceDescription {
 public:

  static const char* ascii_fingerprint; // = "ADC1452A60F79D933D0EE4B9893AD048";
  static const uint8_t binary_fingerprint[16]; // = {0xAD,0xC1,0x45,0x2A,0x60,0xF7,0x9D,0x93,0x3D,0x0E,0xE4,0xB9,0x89,0x3A,0xD0,0x48};

  ComputeResourceDescription() : isEmpty(false), computeResourceId("DO_NOT_SET_AT_CLIENTS"), hostName(), computeResourceDescription(), resourceJobManager((ResourceJobManager::type)0) {
  }

  virtual ~ComputeResourceDescription() throw() {}

  bool isEmpty;
  std::string computeResourceId;
  std::string hostName;
  std::set<std::string>  hostAliases;
  std::set<std::string>  ipAddresses;
  std::string computeResourceDescription;
  ResourceJobManager::type resourceJobManager;
  std::vector<BatchQueue>  batchQueues;
  std::map<FileSystems::type, std::string>  fileSystems;
  std::vector<JobSubmissionInterface>  jobSubmissionInterfaces;
  std::vector<DataMovementInterface>  dataMovemenetInterfaces;

  _ComputeResourceDescription__isset __isset;

  void __set_isEmpty(const bool val) {
    isEmpty = val;
  }

  void __set_computeResourceId(const std::string& val) {
    computeResourceId = val;
  }

  void __set_hostName(const std::string& val) {
    hostName = val;
  }

  void __set_hostAliases(const std::set<std::string> & val) {
    hostAliases = val;
    __isset.hostAliases = true;
  }

  void __set_ipAddresses(const std::set<std::string> & val) {
    ipAddresses = val;
    __isset.ipAddresses = true;
  }

  void __set_computeResourceDescription(const std::string& val) {
    computeResourceDescription = val;
    __isset.computeResourceDescription = true;
  }

  void __set_resourceJobManager(const ResourceJobManager::type val) {
    resourceJobManager = val;
    __isset.resourceJobManager = true;
  }

  void __set_batchQueues(const std::vector<BatchQueue> & val) {
    batchQueues = val;
    __isset.batchQueues = true;
  }

  void __set_fileSystems(const std::map<FileSystems::type, std::string> & val) {
    fileSystems = val;
    __isset.fileSystems = true;
  }

  void __set_jobSubmissionInterfaces(const std::vector<JobSubmissionInterface> & val) {
    jobSubmissionInterfaces = val;
    __isset.jobSubmissionInterfaces = true;
  }

  void __set_dataMovemenetInterfaces(const std::vector<DataMovementInterface> & val) {
    dataMovemenetInterfaces = val;
    __isset.dataMovemenetInterfaces = true;
  }

  bool operator == (const ComputeResourceDescription & rhs) const
  {
    if (!(isEmpty == rhs.isEmpty))
      return false;
    if (!(computeResourceId == rhs.computeResourceId))
      return false;
    if (!(hostName == rhs.hostName))
      return false;
    if (__isset.hostAliases != rhs.__isset.hostAliases)
      return false;
    else if (__isset.hostAliases && !(hostAliases == rhs.hostAliases))
      return false;
    if (__isset.ipAddresses != rhs.__isset.ipAddresses)
      return false;
    else if (__isset.ipAddresses && !(ipAddresses == rhs.ipAddresses))
      return false;
    if (__isset.computeResourceDescription != rhs.__isset.computeResourceDescription)
      return false;
    else if (__isset.computeResourceDescription && !(computeResourceDescription == rhs.computeResourceDescription))
      return false;
    if (__isset.resourceJobManager != rhs.__isset.resourceJobManager)
      return false;
    else if (__isset.resourceJobManager && !(resourceJobManager == rhs.resourceJobManager))
      return false;
    if (__isset.batchQueues != rhs.__isset.batchQueues)
      return false;
    else if (__isset.batchQueues && !(batchQueues == rhs.batchQueues))
      return false;
    if (__isset.fileSystems != rhs.__isset.fileSystems)
      return false;
    else if (__isset.fileSystems && !(fileSystems == rhs.fileSystems))
      return false;
    if (__isset.jobSubmissionInterfaces != rhs.__isset.jobSubmissionInterfaces)
      return false;
    else if (__isset.jobSubmissionInterfaces && !(jobSubmissionInterfaces == rhs.jobSubmissionInterfaces))
      return false;
    if (__isset.dataMovemenetInterfaces != rhs.__isset.dataMovemenetInterfaces)
      return false;
    else if (__isset.dataMovemenetInterfaces && !(dataMovemenetInterfaces == rhs.dataMovemenetInterfaces))
      return false;
    return true;
  }
  bool operator != (const ComputeResourceDescription &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ComputeResourceDescription & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(ComputeResourceDescription &a, ComputeResourceDescription &b);



#endif
